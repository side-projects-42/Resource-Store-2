<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>dev-ast-memory</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="libsass-smart-pointer-implementation">LibSass smart pointer implementation</h1>
<p>LibSass uses smart pointers very similar to <code>shared_ptr</code> known by Boost or C++11. Implementation is a bit less modular since it was not needed. Various compile time debug options are available if you need to debug memory life-cycles.</p>
<h2 id="memory-classes">Memory Classes</h2>
<h3 id="sharedobj">SharedObj</h3>
<p>Base class for the actual node implementations. This ensures that every object has a reference counter and other values.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> AST_Node : <span class="kw">public</span> SharedObj { ... };</a></code></pre></div>
<h3 id="sharedptr-base-class-for-sharedimpl">SharedPtr (base class for SharedImpl)</h3>
<p>Base class that holds on to the pointer. The reference counter is stored inside the pointer object directly (<code>SharedObj</code>).</p>
<h3 id="sharedimpl-inherits-from-sharedptr">SharedImpl (inherits from SharedPtr)</h3>
<p>This is the main base class for objects you use in your code. It will make sure that the memory it points at will be deleted once all copies to the same object/memory go out of scope.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1">Class* pointer = <span class="kw">new</span> Class(...);</a>
<a class="sourceLine" id="cb2-2" title="2">SharedImpl&lt;Class&gt; obj(pointer);</a></code></pre></div>
<p>To spare the developer of typing the templated class every time, we created typedefs for each available AST Node specialization.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">typedef</span> SharedImpl&lt;Number&gt; Number_Obj;</a>
<a class="sourceLine" id="cb3-2" title="2">Number_Obj number = SASS_MEMORY_NEW(...);</a></code></pre></div>
<h2 id="memory-life-cycles">Memory life-cycles</h2>
<h3 id="pointer-pickups">Pointer pickups</h3>
<p>I often use the terminology of “pickup”. This means the moment when a raw pointer not under any control is assigned to a reference counted object (<code>XYZ_Obj = XYZ_Ptr</code>). From that point on memory will be automatically released once the object goes out of scope (but only if the reference counter reaches zero). Main point beeing, you don’t have to worry about memory management yourself.</p>
<h3 id="object-detach">Object detach</h3>
<p>Sometimes we can’t return reference counted objects directly (see invalid covariant return types problems below). But we often still need to use reference objects inside a function to avoid leaks when something throws. For this you can use <code>detach</code>, which basically detaches the pointer memory from the reference counted object. So when the reference counted object goes out of scope, it will not free the attached memory. You are now again in charge of freeing the memory (just assign it to a reference counted object again).</p>
<h2 id="circular-references">Circular references</h2>
<p>Reference counted memory implementations are prone to circular references. This can be addressed by using a multi generation garbage collector. But for our use-case that seems overkill. There is no way so far for users (sass code) to create circular references. Therefore we can code around this possible issue. But developers should be aware of this limitation.</p>
<p>There are AFAIR two places where circular references could happen. One is the <code>sources</code> member on every <code>Selector</code>. The other one can happen in the extend code (Node handling). The easy way to avoid this is to only assign complete object clones to these members. If you know the objects lifetime is longer than the reference you create, you can also just store the raw pointer. Once needed this could be solved with weak pointers.</p>
<h2 id="addressing-the-invalid-covariant-return-types-problems">Addressing the invalid covariant return types problems</h2>
<p>If you are not familiar with the mentioned problem, you may want to read up on covariant return types and virtual functions, i.e.</p>
<ul>
<li>http://stackoverflow.com/questions/6924754/return-type-covariance-with-smart-pointers</li>
<li>http://stackoverflow.com/questions/196733/how-can-i-use-covariant-return-types-with-smart-pointers</li>
<li>http://stackoverflow.com/questions/2687790/how-to-accomplish-covariant-return-types-when-returning-a-shared-ptr</li>
</ul>
<p>We hit this issue at least with the CRTP visitor pattern (eval, expand, listize and so forth). This means we cannot return reference counted objects directly. We are forced to return raw pointers or we would need to have a lot of explicit and expensive upcasts by callers/consumers.</p>
<h3 id="simple-functions-that-allocate-new-ast-nodes">Simple functions that allocate new AST Nodes</h3>
<p>In the parser step we often create new objects and can just return a unique pointer (meaning ownership clearly shifts back to the caller). The caller/consumer is responsible that the memory is freed.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">typedef</span> Number* Number_Ptr;</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="dt">int</span> parse_integer() {</a>
<a class="sourceLine" id="cb4-3" title="3">  ... <span class="co">// do the parsing</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="cf">return</span> <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb4-5" title="5">}</a>
<a class="sourceLine" id="cb4-6" title="6">Number_Ptr parse_number() {</a>
<a class="sourceLine" id="cb4-7" title="7">  Number_Ptr p_nr = SASS_MEMORY_NEW(...);</a>
<a class="sourceLine" id="cb4-8" title="8">  p_nr-&gt;value(parse_integer());</a>
<a class="sourceLine" id="cb4-9" title="9">  <span class="cf">return</span> p_nr;</a>
<a class="sourceLine" id="cb4-10" title="10">}</a>
<a class="sourceLine" id="cb4-11" title="11">Number_Obj nr = parse_number();</a></code></pre></div>
<p>The above would be the encouraged pattern for such simple cases.</p>
<h3 id="allocate-new-ast-nodes-in-functions-that-can-throw">Allocate new AST Nodes in functions that can throw</h3>
<p>There is a major caveat with the previous example, considering this more real-life implementation that throws an error. The throw may happen deep down in another function. Holding raw pointers that we need to free would leak in this case.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">int</span> parse_integer() {</a>
<a class="sourceLine" id="cb5-2" title="2">  ... <span class="co">// do the parsing</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="cf">if</span> (error) <span class="cf">throw</span>(error);</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="cf">return</span> <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb5-5" title="5">}</a></code></pre></div>
<p>With this <code>parse_integer</code> function the previous example would leak memory. I guess it is pretty obvious, as the allocated memory will not be freed, as it was never assigned to a SharedObj value. Therefore the above code would better be written as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">typedef</span> Number* Number_Ptr;</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="dt">int</span> parse_integer() {</a>
<a class="sourceLine" id="cb6-3" title="3">  ... <span class="co">// do the parsing</span></a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="cf">if</span> (error) <span class="cf">throw</span>(error);</a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="cf">return</span> <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb6-6" title="6">}</a>
<a class="sourceLine" id="cb6-7" title="7"><span class="co">// this leaks due to pointer return</span></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">// should return Number_Obj instead</span></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="co">// though not possible for virtuals!</span></a>
<a class="sourceLine" id="cb6-10" title="10">Number_Ptr parse_number() {</a>
<a class="sourceLine" id="cb6-11" title="11">  Number_Obj nr = SASS_MEMORY_NEW(...);</a>
<a class="sourceLine" id="cb6-12" title="12">  nr-&gt;value(parse_integer()); <span class="co">// throws</span></a>
<a class="sourceLine" id="cb6-13" title="13">  <span class="cf">return</span> &amp;nr; <span class="co">// Ptr from Obj</span></a>
<a class="sourceLine" id="cb6-14" title="14">}</a>
<a class="sourceLine" id="cb6-15" title="15">Number_Obj nr = parse_number();</a>
<a class="sourceLine" id="cb6-16" title="16"><span class="co">// will now be freed automatically</span></a></code></pre></div>
<p>The example above unfortunately will not work as is, since we return a <code>Number_Ptr</code> from that function. Therefore the object allocated inside the function is already gone when it is picked up again by the caller. The easy fix for the given simplified use case would be to change the return type of <code>parse_number</code> to <code>Number_Obj</code>. Indeed we do it exactly this way in the parser. But as stated above, this will not work for virtual functions due to invalid covariant return types!</p>
<h3 id="return-managed-objects-from-virtual-functions">Return managed objects from virtual functions</h3>
<p>The easy fix would be to just create a new copy on the heap and return that. But this seems like a very inelegant solution to this problem. I mean why can’t we just tell the object to treat it like a newly allocated object? And indeed we can. I’ve added a <code>detach</code> method that will tell the object to survive deallocation until the next pickup. This means that it will leak if it is not picked up by consumer.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">typedef</span> Number* Number_Ptr;</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="dt">int</span> parse_integer() {</a>
<a class="sourceLine" id="cb7-3" title="3">  ... <span class="co">// do the parsing</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="cf">if</span> (error) <span class="cf">throw</span>(error);</a>
<a class="sourceLine" id="cb7-5" title="5">  <span class="cf">return</span> <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb7-6" title="6">}</a>
<a class="sourceLine" id="cb7-7" title="7">Number_Ptr parse_number() {</a>
<a class="sourceLine" id="cb7-8" title="8">  Number_Obj nr = SASS_MEMORY_NEW(...);</a>
<a class="sourceLine" id="cb7-9" title="9">  nr-&gt;value(parse_integer()); <span class="co">// throws</span></a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="cf">return</span> nr.detach();</a>
<a class="sourceLine" id="cb7-11" title="11">}</a>
<a class="sourceLine" id="cb7-12" title="12">Number_Obj nr = parse_number();</a>
<a class="sourceLine" id="cb7-13" title="13"><span class="co">// will now be freed automatically</span></a></code></pre></div>
<h2 id="compile-time-debug-options">Compile time debug options</h2>
<p>To enable memory debugging you need to define <code>DEBUG_SHARED_PTR</code>. This can i.e. be done in <code>include/sass/base.h</code></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1">define DEBUG_SHARED_PTR</a></code></pre></div>
<p>This will print lost memory on exit to stderr. You can also use <code>setDbg(true)</code> on sepecific variables to emit reference counter increase, decrease and other events.</p>
<h2 id="why-reinvent-the-wheel-when-there-is-shared_ptr-from-c11">Why reinvent the wheel when there is <code>shared_ptr</code> from C++11</h2>
<p>First, implementing a smart pointer class is not really that hard. It was indeed also a learning experience for myself. But there are more profound advantages:</p>
<ul>
<li>Better GCC 4.4 compatibility (which most code still has OOTB)</li>
<li>Not thread safe (give us some free performance on some compiler)</li>
<li>Beeing able to track memory allocations for debugging purposes</li>
<li>Adding additional features if needed (as seen in <code>detach</code>)</li>
<li>Optional: optimized weak pointer implementation possible</li>
</ul>
<h3 id="thread-safety">Thread Safety</h3>
<p>As said above, this is not thread safe currently. But we don’t need this ATM anyway. And I guess we probably never will share AST Nodes across different threads.</p>
</body>
</html>
