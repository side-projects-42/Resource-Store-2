<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p><a href="https://travis-ci.org/DirtyHairy/microevent"><img src="https://travis-ci.org/DirtyHairy/microevent.svg?branch=master" alt="Build Status" /></a> <a href="https://badge.fury.io/js/microevent.ts"><img src="https://badge.fury.io/js/microevent.ts.svg" alt="npm version" /></a></p>
<h1 id="what-is-it">What is it?</h1>
<p>This package implements an event system with minimal dispatch overhead. Instead of recording handlers bound to an event in dynamic data structures, this library binds the handlers to autogenerated code. This enables the VM to inline the handler invocation and generate code that is just as fast as invoking the handlers directly.</p>
<p>In a (completely unscientific) benchmark, this library performs bettern than NodeJS events in terms of event dispatch calls per second by about two orders of magnitude.</p>
<h1 id="how-to-use-it">How to use it?</h1>
<h2 id="installation">Installation</h2>
<p>You can install the library into your project via npm</p>
<pre><code>npm install microevent.ts</code></pre>
<p>The library is written in Typescript and will work in any environment that supports ES5. No external typings are required for using this library with Typescript (version &gt;= 2).</p>
<h2 id="importing">Importing</h2>
<p>ES5 / CommonJS</p>
<pre><code>var Event = require(&#39;microevent.ts&#39;).Event;</code></pre>
<p>ES6</p>
<pre><code>import {Event} from &#39;microevent.ts&#39;;</code></pre>
<p>Typescript</p>
<pre><code>import {Event, EventInterface} from &#39;microevent.ts&#39;;</code></pre>
<p>The <code>EventInterface</code> covers only the client side of an event, that is adding and removing handlers.</p>
<h2 id="api">API</h2>
<h3 id="creating">Creating</h3>
<p>ES5/ES6</p>
<pre><code>const event = new Event();</code></pre>
<p>Typescript</p>
<pre><code>const event = new Event&lt;PayloadT&gt;();</code></pre>
<p>Create a new event that will dispatch a payload of type <code>PayloadT</code>.</p>
<h3 id="dispatching">Dispatching</h3>
<pre><code>event.dispatch(payload);</code></pre>
<p>This will call all handlers in the order they were registered, passing <code>payload</code> as first argument.</p>
<p><strong>IMPORTANT</strong> <code>dispatch</code> is a property that refers to dynamically generated code. <strong>DO NOT KEEP ANY REFERENCES</strong> to <code>dispatch</code> as adding and removing handlers will invalidate them.</p>
<h3 id="registering-handlers">Registering handlers</h3>
<pre><code>event.addHandler(handler, context);</code></pre>
<p><code>context</code> is an optional parameter that will be passed to the handler on each invocation.</p>
<h3 id="removing-handlers">Removing handlers</h3>
<pre><code>event.removeHandler(handler, context);</code></pre>
<p>Both <code>handler</code> and <code>context</code> must be identical to the values used when registering the handler in the first place.</p>
<h3 id="checking-for-handlers">Checking for handlers</h3>
<pre><code>event.isHandlerAttached(handler, context)</code></pre>
<p>This will check whether a handler was attached in a given context.</p>
<pre><code>event.hasHandlers</code></pre>
<p><code>true</code> if the event has any handlers attached, false otherwise.</p>
<h1 id="license">License</h1>
<p>Feel free to use this library under the conditions of the MIT license.</p>
</body>
</html>
