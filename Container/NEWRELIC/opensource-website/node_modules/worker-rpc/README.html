<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p><a href="https://travis-ci.org/DirtyHairy/worker-rpc"><img src="https://travis-ci.org/DirtyHairy/worker-rpc.svg?branch=master" alt="Build Status" /></a> <a href="https://badge.fury.io/js/worker-rpc"><img src="https://badge.fury.io/js/worker-rpc.svg" alt="npm version" /></a></p>
<h1 id="what-is-it">What is it?</h1>
<p>This package provides a simple RPC mechanism on top of any transport that transfers JSON data. It was initially conceived to provide communication with web workers (and as such supports transferables), but it can be used on top of many other different transport channels, i.e.Â <code>postMessage</code> between frames, websockets via <code>socket.io</code> or JSON encoded messages over pipes.</p>
<h1 id="how-to-use-it">How to use it?</h1>
<h2 id="installation">Installation</h2>
<p>You can install the library into your project via npm</p>
<pre><code>npm install worker-rpc</code></pre>
<p>The library is written in Typescript and will work in any environment that supports ES5 and ES6-style promises (either native or through a shim). No external typings are required for using this library with Typescript (version &gt;= 2).</p>
<h2 id="web-worker-example">Web worker example</h2>
<p>In this example, we use the library to set up communication with a web worker.</p>
<h3 id="web-worker">Web worker</h3>
<pre><code>import {RpcProvider} from &#39;worker-rpc&#39;;

const rpcProvider = new RpcProvider(
    (message, transfer) =&gt; postMessage(message, transfer)
);

onmessage = e =&gt; rpcProvider.dispatch(e.data);

rpcProvider.registerRpcHandler(&#39;add&#39;, ({x, y}) =&gt; x + y);</code></pre>
<p>The RPC provider is initialized with a function that dispatches a message. This function will receive an opaque message object as first argument, and a list of transferables as second argument. This allows to leverage transfer of ownership instead of copying between worker and host page.</p>
<p>On incoming messages, <code>dispatch</code> is called on the RPC provider in order to handle the message.</p>
<p>Each registered RPC handler is identified by a message ID (<code>add</code> in this example) and has a handler function that receives the message object and can return a result either as an immediate value or as a promise.</p>
<h3 id="page">Page</h3>
<pre><code>import {RpcProvider} from &#39;worker-rpc&#39;;

const worker = new Worker(&#39;worker.js&#39;),
    rpcProvider = new RpcProvider(
        (message, transfer) =&gt; worker.postMessage(message, transfer)
    );

worker.onmessage = e =&gt; rpcProvider.dispatch(e.data);

rpcProvider
    .rpc(&#39;add&#39;, {x: 1, y: 2})
    .then(result =&gt; console.log(result)); // 3</code></pre>
<h2 id="importing">Importing</h2>
<p>ES5 / CommonJS</p>
<pre><code>var RpcProvider = require(&#39;worker-rpc&#39;).RpcProvider;</code></pre>
<p>ES6</p>
<pre><code>import {RpcProvider} from &#39;worker-rpc&#39;;</code></pre>
<p>Typescript</p>
<pre><code>import {RpcProvider, RpcProviderInterface} from &#39;worker-rpc&#39;;</code></pre>
<h2 id="api">API</h2>
<p>The API is built around the <code>RpcProvider</code> class. A <code>RpcProvider</code> acts both as client and server for RPC calls and event-like signals. The library uses ES6 promises and can consume any A+ compliant promises.</p>
<h3 id="creating-a-new-provider">Creating a new provider</h3>
<pre><code>const rpc = new RpcProvider(dispatcher, timeout);</code></pre>
<ul>
<li><code>dispatcher</code>: A function that will be called for dispatching messages. The first argument will be an opaque message object, and the second argument an error of <code>Transferable</code> objects that are to be passed via ownership transfer (if supported by the transport).</li>
<li><code>timeout</code> (optional): The timeout for RPC transactions in milliseconds. Values of <code>0</code> or smaller disable the timeout (this is the default).</li>
</ul>
<h3 id="incoming-messages">Incoming messages</h3>
<pre><code>rpc.dispatch(message);</code></pre>
<p>Similar to message dispatch, <code>worker-rpc</code> does not provide a built-in mechanism for receiving messages. Instead, incoming messages must be relayed to the provider by invoking <code>dispatch</code>.</p>
<ul>
<li><code>message</code>: The received message.</li>
</ul>
<h3 id="registering-rpc-handlers">Registering RPC handlers</h3>
<pre><code>rpc.registerRpcHandler(id, handler);</code></pre>
<p>Register a handler function for RPC calls with id <code>id</code>. Returns the provider instance.</p>
<ul>
<li><code>id</code>: RPC call id. Only a single handler can be registered for any id. Ids should be strings.</li>
<li><code>handler</code>: The handler function. This function receives the payload object as its argument and can return its result either as an immediate value or as a promise.</li>
</ul>
<h3 id="registering-signal-handlers">Registering signal handlers</h3>
<pre><code>rpc.registerSignalHandler(id, handler));</code></pre>
<p>Register a handler function for signals with id <code>id</code>. Returns the provider instance.</p>
<ul>
<li><code>id</code>: Signal id. The namespace for signal ids is seperate from that of RPC ids, and multiple handlers my be attached tp a single signal. Ids should be strings</li>
<li><code>handler</code>: The handler function. This function receives the payload object as its argument; the result is ignored.</li>
</ul>
<h3 id="dispatching-rpc-calls">Dispatching RPC calls</h3>
<pre><code>const result = rpc.rpc(id, payload, transfer);</code></pre>
<p>Dispatch a RPC call and returns a promise for its result. The promise is rejected if the call times out or if no handler is registered (or if the handler rejects the operation).</p>
<ul>
<li><code>id</code>: RPC call id.</li>
<li><code>payload</code> (optional): RPC call payload.</li>
<li><code>transfer</code> (optional): List of <code>Transferables</code> that will be passed to dispatched (see above).</li>
</ul>
<h3 id="dispatching-signals">Dispatching signals</h3>
<pre><code>rpc.signal(id, payload, transfer);</code></pre>
<p>Dispatch a signal. Returns the provider instance.</p>
<ul>
<li><code>id</code>: Signal id.</li>
<li><code>payload</code> (optional): Signal payload.</li>
<li><code>transfer</code> (optional): List of <code>Transferables</code> that will be passed to dispatched (see above).</li>
</ul>
<h3 id="deregistering-rpc-handlers">Deregistering RPC handlers</h3>
<pre><code>rpc.deregisterRpcHandler(id, handler);</code></pre>
<p><code>id</code> and <code>handler</code> must be the same arguments used for <code>registerRpcHandler</code>. Returns the provider instance.</p>
<h3 id="deregistering-signal-handlers">Deregistering signal handlers</h3>
<pre><code>rpc.deregisterSignalHandler(id, handler);</code></pre>
<p><code>id</code> and <code>handler</code> must be the same arguments used for <code>registerSignalHandler</code>. Returns the provider instance.</p>
<h3 id="errors">Errors</h3>
<pre><code>rpc.error.addHandler(errorHandler);</code></pre>
<p>The error event is dispatched if there is either a local or remote communcation error (timeout, invalid id, etc.). Checkout the <a href="https://github.com/DirtyHairy/microevent">microevent.ts</a> documentation for the event API.</p>
<h1 id="license">License</h1>
<p>Feel free to use this library under the conditions of the MIT license.</p>
</body>
</html>
