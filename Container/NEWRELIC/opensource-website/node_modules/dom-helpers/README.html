<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="dom-helpers">dom-helpers</h1>
<p>tiny modular DOM lib for ie8+</p>
<h2 id="install">Install</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="ex">npm</span> i -S dom-helpers</a></code></pre></div>
<p>Mostly just naive wrappers around common DOM API inconsistencies, Cross browser work is minimal and mostly taken from jQuery. This library doesn’t do a lot to normalize behavior across browsers, it mostly seeks to provide a common interface, and eliminate the need to write the same damn <code>if (ie8)</code> statements in every project.</p>
<p>For example <code>events.on</code> works in all browsers ie8+ but it uses the native event system so actual event oddities will continue to exist. If you need <strong>robust</strong> cross-browser support, use jQuery. If you are just tired of rewriting:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="cf">if</span> (<span class="va">document</span>.<span class="at">addEventListener</span>)</a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="cf">return</span> (node<span class="op">,</span> eventName<span class="op">,</span> handler<span class="op">,</span> capture) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="va">node</span>.<span class="at">addEventListener</span>(eventName<span class="op">,</span> handler<span class="op">,</span> capture <span class="op">||</span> <span class="kw">false</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="cf">else</span> <span class="cf">if</span> (<span class="va">document</span>.<span class="at">attachEvent</span>)</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="cf">return</span> (node<span class="op">,</span> eventName<span class="op">,</span> handler) <span class="kw">=&gt;</span></a>
<a class="sourceLine" id="cb2-6" title="6">      <span class="va">node</span>.<span class="at">attachEvent</span>(<span class="st">&#39;on&#39;</span> <span class="op">+</span> eventName<span class="op">,</span> handler)<span class="op">;</span></a></code></pre></div>
<p>over and over again, or you need a ok <code>getComputedStyle</code> polyfill but don’t want to include all of jQuery, use this.</p>
<p>dom-helpers does expect certain, polyfillable, es5 features to be present for which you can use <code>es5-shim</code> for ie8</p>
<p>The real advantage to this collection is that any method can be required individually, meaning tools like Browserify or webpack will only include the exact methods you use. This is great for environments where jQuery doesn’t make sense, such as <code>React</code> where you only occasionally need to do direct DOM manipulation.</p>
<p>Each level of the module can be required as a whole or you can drill down for a specific method or section:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1">    <span class="kw">var</span> helpers <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;dom-helpers&#39;</span>)</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">var</span> query <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;dom-helpers/query&#39;</span>)</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">var</span> offset <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;dom-helpers/query/offset&#39;</span>)</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="co">// style is a function</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="at">require</span>(<span class="st">&#39;dom-helpers/style&#39;</span>)(node<span class="op">,</span> <span class="op">{</span> <span class="dt">width</span><span class="op">:</span> <span class="st">&#39;40px&#39;</span> <span class="op">}</span>)</a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="co">//and a namespace</span></a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="kw">var</span> gcs <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;dom-helpers/style/getComputedStyle&#39;</span>)</a></code></pre></div>
<ul>
<li>dom-helpers
<ul>
<li><code>ownerDocument(element)</code>: returns the element’s document owner</li>
<li><code>ownerWindow(element)</code>: returns the element’s document window</li>
<li><code>activeElement</code>: return focused element safely</li>
<li>query
<ul>
<li><code>querySelectorAll(element, selector)</code>: optimized qsa, uses <code>getElementBy{Id|TagName|ClassName}</code> if it can.</li>
<li><code>contains(container, element)</code></li>
<li><code>height(element, useClientHeight)</code></li>
<li><code>width(element, useClientWidth)</code></li>
<li><code>matches(element, selector)</code>: <code>matches()</code> polyfill that works in ie8</li>
<li><code>offset(element)</code> -&gt; <code>{ top: Number, left: Number, height: Number, width: Number}</code></li>
<li><code>offsetParent(element)</code>: return the parent node that the element is offset from</li>
<li><code>position(element, [offsetParent]</code>: return “offset” of the node to its offsetParent, optionally you can specify the offset parent if different than the “real” one</li>
<li><code>scrollTop(element, [value])</code></li>
<li><code>scrollLeft(element, [value])</code></li>
<li><code>scrollParent(element)</code></li>
</ul></li>
<li>class
<ul>
<li><code>addClass(element, className)</code></li>
<li><code>removeClass(element, className)</code></li>
<li><code>hasClass(element, className)</code></li>
</ul></li>
<li><code>style(element, propName, [value])</code> or <code>style(element, objectOfPropValues)</code>
<ul>
<li><code>removeStyle(element, styleName)</code></li>
<li><code>getComputedStyle(element)</code> -&gt; <code>getPropertyValue(name)</code></li>
</ul></li>
<li>transition
<ul>
<li><code>animate(node, properties, duration, easing, callback)</code> programmatically start css transitions<br />
</li>
<li><code>end(node, handler, [duration])</code> listens for transition end, and ensures that the handler if called even if the transition fails to fire its end event. Will attempt to read duration from the element, otherwise one can be provided</li>
<li><code>properties</code>: Object containing the various vendor specific transition and transform properties for your browser</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1">   <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="dt">transform</span><span class="op">:</span> <span class="co">// transform property: &#39;transform&#39;</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="dt">end</span><span class="op">:</span>       <span class="co">// transitionend</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="dt">property</span><span class="op">:</span>  <span class="co">// transition-property</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="dt">timing</span><span class="op">:</span>    <span class="co">// transition-timing</span></a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="dt">delay</span><span class="op">:</span>     <span class="co">// transition-delay  </span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="dt">duration</span><span class="op">:</span>  <span class="co">// transition-duration</span></a>
<a class="sourceLine" id="cb4-8" title="8">   <span class="op">}</span></a></code></pre></div></li>
<li>events
<ul>
<li><code>on(node, eventName, handler, [capture])</code>: capture is silently ignored in ie8</li>
<li><code>off(node, eventName, handler, [capture])</code>: capture is silently ignored in ie8</li>
<li><code>listen(node, eventName, handler, [capture])</code>: wraps <code>on</code> and returns a function that calls <code>off</code> for you</li>
<li><code>filter(selector, fn)</code>: returns a function handler that only fires when the target matches or is contained in the selector ex: <code>events.on(list, 'click', events.filter('li &gt; a', handler))</code></li>
</ul></li>
<li>util
<ul>
<li><code>requestAnimationFrame(cb)</code> returns an ID for canceling
<ul>
<li><code>requestAnimationFrame.cancel(id)</code></li>
</ul></li>
<li><code>scrollbarSize([recalc])</code> returns the scrollbar’s width size in pixels</li>
<li><code>scrollTo(element, [scrollParent])</code></li>
</ul></li>
</ul></li>
</ul>
</body>
</html>
