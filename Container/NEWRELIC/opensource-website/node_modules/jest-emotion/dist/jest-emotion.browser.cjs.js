'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var css = require('css');
var chalk = _interopDefault(require('chalk'));

function defaultClassNameReplacer(className, index) {
  return "emotion-" + index;
}

var componentSelectorClassNamePattern = /^e[a-zA-Z0-9]+[0-9]+$/;
var replaceClassNames = function replaceClassNames(classNames, styles, code, keys, classNameReplacer) {
  if (classNameReplacer === void 0) {
    classNameReplacer = defaultClassNameReplacer;
  }

  var index = 0;
  var keyPattern = new RegExp("^(" + keys.join('|') + ")-");
  return classNames.reduce(function (acc, className) {
    if (keyPattern.test(className) || componentSelectorClassNamePattern.test(className)) {
      var escapedRegex = new RegExp(className.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&'), 'g');
      return acc.replace(escapedRegex, classNameReplacer(className, index++));
    }

    return acc;
  }, "" + styles + (styles ? '\n\n' : '') + code);
};

function flatMap(arr, iteratee) {
  var _ref;

  return (_ref = []).concat.apply(_ref, arr.map(iteratee));
}

var RULE_TYPES = {
  media: 'media',
  rule: 'rule'
};

function getClassNames(selectors, classes) {
  return classes ? selectors.concat(classes.split(' ')) : selectors;
}

function getClassNamesFromTestRenderer(selectors, _ref2) {
  var _ref2$props = _ref2.props,
      props = _ref2$props === void 0 ? {} : _ref2$props;
  return getClassNames(selectors, props.className || props["class"]);
}

function shouldDive(node) {
  return typeof node.dive === 'function' && typeof node.type() !== 'string';
}

function isTagWithClassName(node) {
  return node.prop('className') && typeof node.type() === 'string';
}

function getClassNamesFromEnzyme(selectors, node) {
  // We need to dive if we have selected a styled child from a shallow render
  var actualComponent = shouldDive(node) ? node.dive() : node; // Find the first node with a className prop

  var components = actualComponent.findWhere(isTagWithClassName);
  var classes = components.length && components.first().prop('className');
  return getClassNames(selectors, classes);
}

function getClassNamesFromCheerio(selectors, node) {
  var classes = node.attr('class');
  return getClassNames(selectors, classes);
}

function getClassNamesFromDOMElement(selectors, node) {
  return getClassNames(selectors, node.getAttribute('class'));
}

function isReactElement(val) {
  return val.$$typeof === Symbol["for"]('react.test.json');
}
function isEmotionCssPropElementType(val) {
  return val.$$typeof === Symbol["for"]('react.element') && val.type.$$typeof === Symbol["for"]('react.forward_ref') && val.type.displayName === 'EmotionCssPropInternal';
}
function isEmotionCssPropEnzymeElement(val) {
  return val.$$typeof === Symbol["for"]('react.test.json') && val.type === 'EmotionCssPropInternal';
}
var domElementPattern = /^((HTML|SVG)\w*)?Element$/;
function isDOMElement(val) {
  return val.nodeType === 1 && val.constructor && val.constructor.name && domElementPattern.test(val.constructor.name);
}

function isEnzymeElement(val) {
  return typeof val.findWhere === 'function';
}

function isCheerioElement(val) {
  return val.cheerio === '[cheerio object]';
}

function getClassNamesFromNodes(nodes) {
  return nodes.reduce(function (selectors, node) {
    if (isReactElement(node)) {
      return getClassNamesFromTestRenderer(selectors, node);
    } else if (isEnzymeElement(node)) {
      return getClassNamesFromEnzyme(selectors, node);
    } else if (isCheerioElement(node)) {
      return getClassNamesFromCheerio(selectors, node);
    }

    return getClassNamesFromDOMElement(selectors, node);
  }, []);
}
var keyframesPattern = /^@keyframes\s+(animation-[^{\s]+)+/;
var removeCommentPattern = /\/\*[\s\S]*?\*\//g;

var getElementRules = function getElementRules(element) {
  var nonSpeedyRule = element.textContent;

  if (nonSpeedyRule) {
    return [nonSpeedyRule];
  }

  if (!element.sheet) {
    return [];
  } // $FlowFixMe - flow doesn't know about `cssRules` property


  return [].slice.call(element.sheet.cssRules).map(function (cssRule) {
    return cssRule.cssText;
  });
};

function getStylesFromClassNames(classNames, elements) {
  if (!classNames.length) {
    return '';
  }

  var keys = getKeys(elements);

  if (!keys.length) {
    return '';
  }

  var keyPatten = new RegExp("^(" + keys.join('|') + ")-");
  var filteredClassNames = classNames.filter(function (className) {
    return keyPatten.test(className);
  });

  if (!filteredClassNames.length) {
    return '';
  }

  var selectorPattern = new RegExp('\\.(' + filteredClassNames.join('|') + ')');
  var keyframes = {};
  var styles = '';
  flatMap(elements, getElementRules).forEach(function (rule) {
    if (selectorPattern.test(rule)) {
      styles += rule;
    }

    var match = rule.match(keyframesPattern);

    if (match !== null) {
      var name = match[1];

      if (keyframes[name] === undefined) {
        keyframes[name] = '';
      }

      keyframes[name] += rule;
    }
  });
  var keyframeNameKeys = Object.keys(keyframes);
  var keyframesStyles = '';

  if (keyframeNameKeys.length) {
    var keyframesNamePattern = new RegExp(keyframeNameKeys.join('|'), 'g');
    var keyframesNameCache = {};
    var index = 0;
    styles = styles.replace(keyframesNamePattern, function (name) {
      if (keyframesNameCache[name] === undefined) {
        keyframesNameCache[name] = "animation-" + index++;
        keyframesStyles += keyframes[name];
      }

      return keyframesNameCache[name];
    });
    keyframesStyles = keyframesStyles.replace(keyframesNamePattern, function (value) {
      return keyframesNameCache[value];
    });
  }

  return (keyframesStyles + styles).replace(removeCommentPattern, '');
}
function getStyleElements() {
  var elements = Array.from(document.querySelectorAll('style[data-emotion]')); // $FlowFixMe

  return elements;
}

var unique = function unique(arr) {
  return Array.from(new Set(arr));
};

function getKeys(elements) {
  var keys = unique(elements.map(function (element) {
    return (// $FlowFixMe we know it exists since we query for elements with this attribute
      element.getAttribute('data-emotion')
    );
  })).filter(Boolean);
  return keys;
}
function hasClassNames(classNames, selectors, target) {
  // selectors is the classNames of specific css rule
  return selectors.some(function (selector) {
    // if no target, use className of the specific css rule and try to find it
    // in the list of received node classNames to make sure this css rule
    // applied for root element
    if (!target) {
      return classNames.includes(selector.slice(1));
    } // check if selector (className) of specific css rule match target


    return target instanceof RegExp ? target.test(selector) : selector.includes(target);
  });
}
function getMediaRules(rules, media) {
  return rules.filter(function (rule) {
    var isMediaMatch = rule.media ? rule.media.replace(/\s/g, '').includes(media.replace(/\s/g, '')) : false;
    return rule.type === RULE_TYPES.media && isMediaMatch;
  }).reduce(function (mediaRules, mediaRule) {
    return mediaRules.concat(mediaRule.rules);
  }, []);
}

/*
 * Taken from
 * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L234
 */

function isA(typeName, value) {
  return Object.prototype.toString.apply(value) === "[object " + typeName + "]";
}
/*
 * Taken from
 * https://github.com/facebook/jest/blob/be4bec387d90ac8d6a7596be88bf8e4994bc3ed9/packages/expect/src/jasmine_utils.js#L36
 */


function isAsymmetric(obj) {
  return obj && isA('Function', obj.asymmetricMatch);
}

function valueMatches(declaration, value) {
  if (value instanceof RegExp) {
    return value.test(declaration.value);
  }

  if (isAsymmetric(value)) {
    return value.asymmetricMatch(declaration.value);
  }

  return value === declaration.value;
}

function toHaveStyleRule(received, property, value, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      target = _options.target,
      media = _options.media;
  var classNames = getClassNamesFromNodes([received]);
  var cssString = getStylesFromClassNames(classNames, getStyleElements());
  var styles = css.parse(cssString);
  var preparedRules = styles.stylesheet.rules;

  if (media) {
    preparedRules = getMediaRules(preparedRules, media);
  }

  var declaration = preparedRules.filter(function (rule) {
    return rule.type === RULE_TYPES.rule && hasClassNames(classNames, rule.selectors, target);
  }).reduce(function (decs, rule) {
    return decs.concat(rule.declarations);
  }, []).filter(function (dec) {
    return dec.type === 'declaration' && dec.property === property;
  }).pop();

  if (!declaration) {
    return {
      pass: false,
      message: function message() {
        return "Property not found: " + property;
      }
    };
  }

  var pass = valueMatches(declaration, value);

  var message = function message() {
    return "Expected " + property + (pass ? ' not ' : ' ') + "to match:\n" + ("  " + chalk.green(value) + "\n") + 'Received:\n' + ("  " + chalk.red(declaration.value));
  };

  return {
    pass: pass,
    message: message
  };
}

var matchers = {
  toHaveStyleRule: toHaveStyleRule
};

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function getNodes(node, nodes) {
  if (nodes === void 0) {
    nodes = [];
  }

  if (Array.isArray(node)) {
    for (var _iterator = node, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var child = _ref;
      getNodes(child, nodes);
    }

    return nodes;
  }

  if (node.children) {
    for (var _iterator2 = node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var _child = _ref2;
      getNodes(_child, nodes);
    }
  }

  if (typeof node === 'object') {
    nodes.push(node);
  }

  return nodes;
}

function getPrettyStylesFromClassNames(classNames, elements) {
  var styles = getStylesFromClassNames(classNames, elements);
  var prettyStyles;

  try {
    prettyStyles = css.stringify(css.parse(styles));
  } catch (e) {
    console.error(e);
    throw new Error("There was an error parsing the following css: \"" + styles + "\"");
  }

  return prettyStyles;
}

function filterEmotionProps(props) {
  if (props === void 0) {
    props = {};
  }

  var _props = props,
      css = _props.css,
      __EMOTION_TYPE_PLEASE_DO_NOT_USE__ = _props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__,
      __EMOTION_LABEL_PLEASE_DO_NOT_USE__ = _props.__EMOTION_LABEL_PLEASE_DO_NOT_USE__,
      rest = _objectWithoutPropertiesLoose(_props, ["css", "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", "__EMOTION_LABEL_PLEASE_DO_NOT_USE__"]);

  rest.css = 'unknown styles';
  return rest;
}

function createSerializer(_temp) {
  var _ref3 = _temp === void 0 ? {} : _temp,
      classNameReplacer = _ref3.classNameReplacer,
      _ref3$DOMElements = _ref3.DOMElements,
      DOMElements = _ref3$DOMElements === void 0 ? true : _ref3$DOMElements;

  var cache = new WeakSet();

  function print(val, printer) {
    if (isEmotionCssPropEnzymeElement(val)) {
      return val.children.map(printer).join('\n');
    }

    if (isEmotionCssPropElementType(val)) {
      return printer(_objectSpread({}, val, {
        props: filterEmotionProps(val.props),
        type: val.props.__EMOTION_TYPE_PLEASE_DO_NOT_USE__
      }));
    }

    var nodes = getNodes(val);
    var classNames = getClassNamesFromNodes(nodes);
    var elements = getStyleElements();
    var styles = getPrettyStylesFromClassNames(classNames, elements);
    nodes.forEach(cache.add, cache);
    var printedVal = printer(val);
    nodes.forEach(cache["delete"], cache);
    var keys = getKeys(elements);
    return replaceClassNames(classNames, styles, printedVal, keys, classNameReplacer);
  }

  function test(val) {
    return val && (!cache.has(val) && (isReactElement(val) || DOMElements && isDOMElement(val)) || isEmotionCssPropEnzymeElement(val) || isEmotionCssPropElementType(val));
  }

  return {
    test: test,
    print: print
  };
}

var _createSerializer = createSerializer(),
    print = _createSerializer.print,
    test = _createSerializer.test;
var index = {
  print: print,
  test: test
};

exports.createSerializer = createSerializer;
exports.default = index;
exports.matchers = matchers;
exports.print = print;
exports.test = test;
