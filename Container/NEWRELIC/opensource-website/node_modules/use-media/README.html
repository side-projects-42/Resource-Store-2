<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="use-media">use-media</h1>
<p><code>useMedia</code> React sensor hook that tracks state of a CSS media query.</p>
<h2 id="usage">Usage</h2>
<p>With <code>useEffect</code></p>
<pre class="jsx"><code>import useMedia from &#39;use-media&#39;;
// Alternatively, you can import as:
// import {useMedia} from &#39;use-media&#39;;

const Demo = () =&gt; {
  // Accepts an object of features to test
  const isWide = useMedia({minWidth: 1000});
  // Or a regular media query string
  const reduceMotion = useMedia(&#39;(prefers-reduced-motion: reduce)&#39;);

  return (
    &lt;div&gt;
      Screen is wide: {isWide ? &#39;ðŸ˜ƒ&#39; : &#39;ðŸ˜¢&#39;}
    &lt;/div&gt;
  );
};</code></pre>
<p>With <code>useLayoutEffect</code></p>
<pre class="jsx"><code>import {useMediaLayout} from &#39;use-media&#39;;

const Demo = () =&gt; {
  // Accepts an object of features to test
  const isWide = useMediaLayout({minWidth: 1000});
  // Or a regular media query string
  const reduceMotion = useMediaLayout(&#39;(prefers-reduced-motion: reduce)&#39;);

  return (
    &lt;div&gt;
      Screen is wide: {isWide ? &#39;ðŸ˜ƒ&#39; : &#39;ðŸ˜¢&#39;}
    &lt;/div&gt;
  );
};</code></pre>
<h2 id="testing">Testing</h2>
<p>Depending on your testing setup, you may need to mock <code>window.matchMedia</code> on components that utilize the <code>useMedia</code> hook. Below is an example of doing this in <code>jest</code>:</p>
<p><strong><code>/test-utilities/index.ts</code></strong></p>
<pre class="jsx"><code>import {mockMediaQueryList} from &#39;use-media/lib/useMedia&#39;;
// Types are also exported for convienence:
// import {Effect, MediaQueryObject} from &#39;use-media/lib/types&#39;;

export interface MockMatchMedia {
  media: string;
  matches?: boolean;
}

function getMockImplementation({media, matches = false}: MockMatchMedia) {
  const mql: MediaQueryList = {
    ...mockMediaQueryList,
    media,
    matches,
  };

  return () =&gt; mql;
}

export function jestMockMatchMedia({media, matches = false}: MockMatchMedia) {
  const mockedImplementation = getMockImplementation({media, matches});
  window.matchMedia = jest.fn().mockImplementation(mockedImplementation);
}</code></pre>
<p><strong><code>/components/MyComponent/MyComponent.test.tsx</code></strong></p>
<pre class="jsx"><code>const mediaQueries = {
  mobile: &#39;(max-width: 767px)&#39;,
  prefersReducedMotion: &#39;(prefers-reduced-motion: reduce)&#39;,
};

describe(&#39;&lt;MyComponent /&gt;&#39;, () =&gt; {
  const defaultProps: Props = {
    duration: 100,
  };

  afterEach(() =&gt; {
    jestMockMatchMedia({
      media: mediaQueries.prefersReducedMotion,
      matches: false,
    });
  });

  it(&#39;sets `duration` to `0` when user-agent `prefers-reduced-motion`&#39;, () =&gt; {
    jestMockMatchMedia({
      media: mediaQueries.prefersReducedMotion,
      matches: true,
    });

    const wrapper = mount(&lt;MyComponent {...defaultProps} /&gt;);
    const child = wrapper.find(TransitionComponent);

    expect(child.prop(&#39;duration&#39;)).toBe(0);
  });
});</code></pre>
<h2 id="storing-in-context">Storing in Context</h2>
<p>Depending on your app, you may be using the <code>useMedia</code> hook to register many <code>matchMedia</code> listeners across multiple components. It may help to elevate these listeners to <code>Context</code>.</p>
<p><strong><code>/components/MediaQueryProvider/MediaQueryProvider.tsx</code></strong></p>
<pre class="jsx"><code>import React, {createContext, useContext, useMemo} from &#39;react&#39;;
import useMedia from &#39;use-media&#39;;

interface Props {
  children: React.ReactNode;
}

export const MediaQueryContext = createContext(null);

const mediaQueries = {
  mobile: &#39;(max-width: 767px)&#39;,
  prefersReducedMotion: &#39;(prefers-reduced-motion: reduce)&#39;,
};

export default function MediaQueryProvider({children}: Props) {
  const mobileView = useMedia(mediaQueries.mobile);
  const prefersReducedMotion = useMedia(mediaQueries.prefersReducedMotion);
  const value = useMemo(() =&gt; ({mobileView, prefersReducedMotion}), [
    mobileView,
    prefersReducedMotion,
  ]);

  return (
    &lt;MediaQueryContext.Provider value={value}&gt;
      {children}
    &lt;/MediaQueryContext.Provider&gt;
  );
}

export function useMediaQueryContext() {
  return useContext(MediaQueryContext);
}</code></pre>
<p><strong><code>/components/App/App.tsx</code></strong></p>
<pre class="jsx"><code>import React from &#39;react&#39;;
import MediaQueryProvider from &#39;../MediaQueryProvider&#39;;
import MyComponent from &#39;../MyComponent&#39;;

export default function App() {
  return (
    &lt;MediaQueryProvider&gt;
      &lt;div id=&quot;MyApp&quot;&gt;
        &lt;MyComponent /&gt;
      &lt;/div&gt;
    &lt;/MediaQueryProvider&gt;
  );
}</code></pre>
<p><strong><code>/components/MyComponent/MyComponent.tsx</code></strong></p>
<pre class="jsx"><code>import React from &#39;react&#39;;
import {useMediaQueryContext} from &#39;../MediaQueryProvider&#39;;

export default function MyComponent() {
  const {mobileView, prefersReducedMotion} = useMediaQueryContext();

  return (
    &lt;div&gt;
      &lt;p&gt;mobileView: {Boolean(mobileView).toString()}&lt;/p&gt;
      &lt;p&gt;prefersReducedMotion: {Boolean(prefersReducedMotion).toString()}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
</body>
</html>
