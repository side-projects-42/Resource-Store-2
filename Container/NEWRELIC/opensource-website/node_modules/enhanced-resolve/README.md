enhanced-resolve
================

Offers an async require.resolve function. It’s highly configurable.

Features
--------

-   plugin system
-   provide a custom filesystem
-   sync and async node.js filesystems included

Getting Started
---------------

### Install

    # npm
    npm install enhanced-resolve
    # or Yarn
    yarn add enhanced-resolve

### Resolve

There is a Node.js API which allows to resolve requests according to the Node.js resolving rules. Sync and async APIs are offered. A `create` method allows to create a custom resolve function.

    const resolve = require("enhanced-resolve");

    resolve("/some/path/to/folder", "module/dir", (err, result) => {
        result; // === "/some/path/node_modules/module/dir/index.js"
    });

    resolve.sync("/some/path/to/folder", "../../dir");
    // === "/some/path/dir/index.js"

    const myResolve = resolve.create({
        // or resolve.create.sync
        extensions: [".ts", ".js"]
        // see more options below
    });

    myResolve("/some/path/to/folder", "ts-module", (err, result) => {
        result; // === "/some/node_modules/ts-module/index.ts"
    });

### Creating a Resolver

The easiest way to create a resolver is to use the `createResolver` function on `ResolveFactory`, along with one of the supplied File System implementations.

    const fs = require("fs");
    const { CachedInputFileSystem, ResolverFactory } = require("enhanced-resolve");

    // create a resolver
    const myResolver = ResolverFactory.createResolver({
        // Typical usage will consume the `fs` + `CachedInputFileSystem`, which wraps Node.js `fs` to add caching.
        fileSystem: new CachedInputFileSystem(fs, 4000),
        extensions: [".js", ".json"]
        /* any other resolver options here. Options/defaults can be seen below */
    });

    // resolve a file with the new resolver
    const context = {};
    const resolveContext = {};
    const lookupStartPath = "/Users/webpack/some/root/dir";
    const request = "./path/to-look-up.js";
    myResolver.resolve({}, lookupStartPath, request, resolveContext, (
        err /*Error*/,
        filepath /*string*/
    ) => {
        // Do something with the path
    });

#### Resolver Options

<table style="width:99%;"><colgroup><col style="width: 8%" /><col style="width: 13%" /><col style="width: 78%" /></colgroup><thead><tr class="header"><th>Field</th><th>Default</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>alias</td><td>[]</td><td>A list of module alias configurations or an object which maps key to value</td></tr><tr class="even"><td>aliasFields</td><td>[]</td><td>A list of alias fields in description files</td></tr><tr class="odd"><td>cachePredicate</td><td>function() { return true };</td><td>A function which decides whether a request should be cached or not. An object is passed to the function with <code>path</code> and <code>request</code> properties.</td></tr><tr class="even"><td>cacheWithContext</td><td>true</td><td>If unsafe cache is enabled, includes <code>request.context</code> in the cache key</td></tr><tr class="odd"><td>conditionNames</td><td>[“node”]</td><td>A list of exports field condition names</td></tr><tr class="even"><td>descriptionFiles</td><td>[“package.json”]</td><td>A list of description files to read from</td></tr><tr class="odd"><td>enforceExtension</td><td>false</td><td>Enforce that a extension from extensions must be used</td></tr><tr class="even"><td>exportsFields</td><td>[“exports”]</td><td>A list of exports fields in description files</td></tr><tr class="odd"><td>extensions</td><td>[“.js”, “.json”, “.node”]</td><td>A list of extensions which should be tried for files</td></tr><tr class="even"><td>fileSystem</td><td></td><td>The file system which should be used</td></tr><tr class="odd"><td>fullySpecified</td><td>false</td><td>Request passed to resolve is already fully specified and extensions or main files are not resolved for it (they are still resolved for internal requests)</td></tr><tr class="even"><td>mainFields</td><td>[“main”]</td><td>A list of main fields in description files</td></tr><tr class="odd"><td>mainFiles</td><td>[“index”]</td><td>A list of main files in directories</td></tr><tr class="even"><td>modules</td><td>[“node_modules”]</td><td>A list of directories to resolve modules from, can be absolute path or folder name</td></tr><tr class="odd"><td>plugins</td><td>[]</td><td>A list of additional resolve plugins which should be applied</td></tr><tr class="even"><td>resolver</td><td>undefined</td><td>A prepared Resolver to which the plugins are attached</td></tr><tr class="odd"><td>resolveToContext</td><td>false</td><td>Resolve to a context instead of a file</td></tr><tr class="even"><td>preferRelative</td><td>false</td><td>Prefer to resolve module requests as relative request and fallback to resolving as module</td></tr><tr class="odd"><td>preferAbsolute</td><td>false</td><td>Prefer to resolve server-relative urls as absolute paths before falling back to resolve in roots</td></tr><tr class="even"><td>restrictions</td><td>[]</td><td>A list of resolve restrictions</td></tr><tr class="odd"><td>roots</td><td>[]</td><td>A list of root paths</td></tr><tr class="even"><td>symlinks</td><td>true</td><td>Whether to resolve symlinks to their symlinked location</td></tr><tr class="odd"><td>unsafeCache</td><td>false</td><td>Use this cache object to unsafely cache the successful requests</td></tr></tbody></table>

Plugins
-------

Similar to `webpack`, the core of `enhanced-resolve` functionality is implemented as individual plugins that are executed using [`tapable`](https://github.com/webpack/tapable). These plugins can extend the functionality of the library, adding other ways for files/contexts to be resolved.

A plugin should be a `class` (or its ES5 equivalent) with an `apply` method. The `apply` method will receive a `resolver` instance, that can be used to hook in to the event system.

### Plugin Boilerplate

    class MyResolverPlugin {
        constructor(source, target) {
            this.source = source;
            this.target = target;
        }

        apply(resolver) {
            const target = resolver.ensureHook(this.target);
            resolver
                .getHook(this.source)
                .tapAsync("MyResolverPlugin", (request, resolveContext, callback) => {
                    // Any logic you need to create a new `request` can go here
                    resolver.doResolve(target, request, null, resolveContext, callback);
                });
        }
    }

Plugins are executed in a pipeline, and register which event they should be executed before/after. In the example above, `source` is the name of the event that starts the pipeline, and `target` is what event this plugin should fire, which is what continues the execution of the pipeline. For an example of how these different plugin events create a chain, see `lib/ResolverFactory.js`, in the `//// pipeline ////` section.

Escaping
--------

It’s allowed to escape `#` as `\0#` to avoid parsing it as fragment.

enhanced-resolve will try to resolve requests containing `#` as path and as fragment, so it will automatically figure out if `./some#thing` means `.../some.js#thing` or `.../some#thing.js`. When a `#` is resolved as path it will be escaped in the result. Here: `.../some\0#thing.js`.

Tests
-----

    npm test

[![Build Status](https://secure.travis-ci.org/webpack/enhanced-resolve.png?branch=main)](http://travis-ci.org/webpack/enhanced-resolve)

Passing options from webpack
----------------------------

If you are using `webpack`, and you want to pass custom options to `enhanced-resolve`, the options are passed from the `resolve` key of your webpack configuration e.g.:

    resolve: {
      extensions: ['.js', '.jsx'],
      modules: [path.resolve(__dirname, 'src'), 'node_modules'],
      plugins: [new DirectoryNamedWebpackPlugin()]
      ...
    },

License
-------

Copyright (c) 2012-2019 JS Foundation and other contributors

MIT (http://www.opensource.org/licenses/mit-license.php)
