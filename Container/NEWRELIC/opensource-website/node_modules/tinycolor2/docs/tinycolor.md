<table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th><h1 id="tinycolor.js">tinycolor.js</h1></th><th></th></tr></thead><tbody><tr class="odd"><td><div class="pilwrap"><a href="#section-1" class="pilcrow">¶</a></div><p>TinyColor v1.4.2 https://github.com/bgrins/TinyColor Brian Grinstead, MIT License</p></td><td><div class="highlight"><pre><code>(function(Math) {

var trimLeft = /^\s+/,
    trimRight = /\s+$/,
    tinyCounter = 0,
    mathRound = Math.round,
    mathMin = Math.min,
    mathMax = Math.max,
    mathRandom = Math.random;

function tinycolor (color, opts) {

    color = (color) ? color : &#39;&#39;;
    opts = opts || { };</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-2" class="pilcrow">¶</a></div><p>If input is already a tinycolor, return itself</p></td><td><div class="highlight"><pre><code>    if (color instanceof tinycolor) {
       return color;
    }</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-3" class="pilcrow">¶</a></div><p>If we are called as a function, call using new instead</p></td><td><div class="highlight"><pre><code>    if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
    }

    var rgb = inputToRGB(color);
    this._originalInput = color,
    this._r = rgb.r,
    this._g = rgb.g,
    this._b = rgb.b,
    this._a = rgb.a,
    this._roundA = mathRound(100*this._a) / 100,
    this._format = opts.format || rgb.format;
    this._gradientType = opts.gradientType;</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-4" class="pilcrow">¶</a></div><p>Don't let the range of [0,255] come back in [0,1]. Potentially lose a little bit of precision here, but will fix issues where .5 gets interpreted as half of the total, instead of half of 1 If it was supposed to be 128, this was already taken care of by <code>inputToRgb</code></p></td><td><div class="highlight"><pre><code>    if (this._r &lt; 1) { this._r = mathRound(this._r); }
    if (this._g &lt; 1) { this._g = mathRound(this._g); }
    if (this._b &lt; 1) { this._b = mathRound(this._b); }

    this._ok = rgb.ok;
    this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() &lt; 128;
    },
    isLight: function() {
        return !this.isDark();
    },
    isValid: function() {
        return this._ok;
    },
    getOriginalInput: function() {
      return this._originalInput;
    },
    getFormat: function() {
        return this._format;
    },
    getAlpha: function() {
        return this._a;
    },
    getBrightness: function() {</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-5" class="pilcrow">¶</a></div><p>http://www.w3.org/TR/AERT#color-contrast</p></td><td><div class="highlight"><pre><code>        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
    },
    getLuminance: function() {</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-6" class="pilcrow">¶</a></div><p>http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef</p></td><td><div class="highlight"><pre><code>        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r/255;
        GsRGB = rgb.g/255;
        BsRGB = rgb.b/255;

        if (RsRGB &lt;= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
        if (GsRGB &lt;= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
        if (BsRGB &lt;= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value);
        this._roundA = mathRound(100*this._a) / 100;
        return this;
    },
    toHsv: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
    },
    toHsvString: function() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
        return (this._a == 1) ?
          &quot;hsv(&quot;  + h + &quot;, &quot; + s + &quot;%, &quot; + v + &quot;%)&quot; :
          &quot;hsva(&quot; + h + &quot;, &quot; + s + &quot;%, &quot; + v + &quot;%, &quot;+ this._roundA + &quot;)&quot;;
    },
    toHsl: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
    },
    toHslString: function() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
        return (this._a == 1) ?
          &quot;hsl(&quot;  + h + &quot;, &quot; + s + &quot;%, &quot; + l + &quot;%)&quot; :
          &quot;hsla(&quot; + h + &quot;, &quot; + s + &quot;%, &quot; + l + &quot;%, &quot;+ this._roundA + &quot;)&quot;;
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
    },
    toHexString: function(allow3Char) {
        return &#39;#&#39; + this.toHex(allow3Char);
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
    },
    toHex8String: function(allow4Char) {
        return &#39;#&#39; + this.toHex8(allow4Char);
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
    },
    toRgbString: function() {
        return (this._a == 1) ?
          &quot;rgb(&quot;  + mathRound(this._r) + &quot;, &quot; + mathRound(this._g) + &quot;, &quot; + mathRound(this._b) + &quot;)&quot; :
          &quot;rgba(&quot; + mathRound(this._r) + &quot;, &quot; + mathRound(this._g) + &quot;, &quot; + mathRound(this._b) + &quot;, &quot; + this._roundA + &quot;)&quot;;
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + &quot;%&quot;, g: mathRound(bound01(this._g, 255) * 100) + &quot;%&quot;, b: mathRound(bound01(this._b, 255) * 100) + &quot;%&quot;, a: this._a };
    },
    toPercentageRgbString: function() {
        return (this._a == 1) ?
          &quot;rgb(&quot;  + mathRound(bound01(this._r, 255) * 100) + &quot;%, &quot; + mathRound(bound01(this._g, 255) * 100) + &quot;%, &quot; + mathRound(bound01(this._b, 255) * 100) + &quot;%)&quot; :
          &quot;rgba(&quot; + mathRound(bound01(this._r, 255) * 100) + &quot;%, &quot; + mathRound(bound01(this._g, 255) * 100) + &quot;%, &quot; + mathRound(bound01(this._b, 255) * 100) + &quot;%, &quot; + this._roundA + &quot;)&quot;;
    },
    toName: function() {
        if (this._a === 0) {
            return &quot;transparent&quot;;
        }

        if (this._a &lt; 1) {
            return false;
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
    },
    toFilter: function(secondColor) {
        var hex8String = &#39;#&#39; + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? &quot;GradientType = 1, &quot; : &quot;&quot;;

        if (secondColor) {
            var s = tinycolor(secondColor);
            secondHex8String = &#39;#&#39; + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }

        return &quot;progid:DXImageTransform.Microsoft.gradient(&quot;+gradientType+&quot;startColorstr=&quot;+hex8String+&quot;,endColorstr=&quot;+secondHex8String+&quot;)&quot;;
    },
    toString: function(format) {
        var formatSet = !!format;
        format = format || this._format;

        var formattedString = false;
        var hasAlpha = this._a &lt; 1 &amp;&amp; this._a &gt;= 0;
        var needsAlphaFormat = !formatSet &amp;&amp; hasAlpha &amp;&amp; (format === &quot;hex&quot; || format === &quot;hex6&quot; || format === &quot;hex3&quot; || format === &quot;hex4&quot; || format === &quot;hex8&quot; || format === &quot;name&quot;);

        if (needsAlphaFormat) {</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-7" class="pilcrow">¶</a></div><p>Special case for "transparent", all other non-alpha formats will return rgba when there is transparency.</p></td><td><div class="highlight"><pre><code>            if (format === &quot;name&quot; &amp;&amp; this._a === 0) {
                return this.toName();
            }
            return this.toRgbString();
        }
        if (format === &quot;rgb&quot;) {
            formattedString = this.toRgbString();
        }
        if (format === &quot;prgb&quot;) {
            formattedString = this.toPercentageRgbString();
        }
        if (format === &quot;hex&quot; || format === &quot;hex6&quot;) {
            formattedString = this.toHexString();
        }
        if (format === &quot;hex3&quot;) {
            formattedString = this.toHexString(true);
        }
        if (format === &quot;hex4&quot;) {
            formattedString = this.toHex8String(true);
        }
        if (format === &quot;hex8&quot;) {
            formattedString = this.toHex8String();
        }
        if (format === &quot;name&quot;) {
            formattedString = this.toName();
        }
        if (format === &quot;hsl&quot;) {
            formattedString = this.toHslString();
        }
        if (format === &quot;hsv&quot;) {
            formattedString = this.toHsvString();
        }

        return formattedString || this.toHexString();
    },
    clone: function() {
        return tinycolor(this.toString());
    },

    _applyModification: function(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
    },
    lighten: function() {
        return this._applyModification(lighten, arguments);
    },
    brighten: function() {
        return this._applyModification(brighten, arguments);
    },
    darken: function() {
        return this._applyModification(darken, arguments);
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments);
    },
    saturate: function() {
        return this._applyModification(saturate, arguments);
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments);
    },
    spin: function() {
        return this._applyModification(spin, arguments);
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments);
    },
    complement: function() {
        return this._applyCombination(complement, arguments);
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments);
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments);
    },
    triad: function() {
        return this._applyCombination(triad, arguments);
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments);
    }
};</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-8" class="pilcrow">¶</a></div><p>If input is an object, force 1 into "1.0" to handle ratios properly String input requires "1.0" as input, so 1 will be treated as 1</p></td><td><div class="highlight"><pre><code>tinycolor.fromRatio = function(color, opts) {
    if (typeof color == &quot;object&quot;) {
        var newColor = {};
        for (var i in color) {
            if (color.hasOwnProperty(i)) {
                if (i === &quot;a&quot;) {
                    newColor[i] = color[i];
                }
                else {
                    newColor[i] = convertToPercentage(color[i]);
                }
            }
        }
        color = newColor;
    }

    return tinycolor(color, opts);
};</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-9" class="pilcrow">¶</a></div><p>Given a string or object, convert that input to RGB Possible string inputs:</p><pre><code>&quot;red&quot;
&quot;#f00&quot; or &quot;f00&quot;
&quot;#ff0000&quot; or &quot;ff0000&quot;
&quot;#ff000000&quot; or &quot;ff000000&quot;
&quot;rgb 255 0 0&quot; or &quot;rgb (255, 0, 0)&quot;
&quot;rgb 1.0 0 0&quot; or &quot;rgb (1, 0, 0)&quot;
&quot;rgba (255, 0, 0, 1)&quot; or &quot;rgba 255, 0, 0, 1&quot;
&quot;rgba (1.0, 0, 0, 1)&quot; or &quot;rgba 1.0, 0, 0, 1&quot;
&quot;hsl(0, 100%, 50%)&quot; or &quot;hsl 0 100% 50%&quot;
&quot;hsla(0, 100%, 50%, 1)&quot; or &quot;hsla 0 100% 50%, 1&quot;
&quot;hsv(0, 100%, 100%)&quot; or &quot;hsv 0 100% 100%&quot;</code></pre></td><td><div class="highlight"><pre><code>function inputToRGB(color) {

    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v = null;
    var l = null;
    var ok = false;
    var format = false;

    if (typeof color == &quot;string&quot;) {
        color = stringInputToObject(color);
    }

    if (typeof color == &quot;object&quot;) {
        if (isValidCSSUnit(color.r) &amp;&amp; isValidCSSUnit(color.g) &amp;&amp; isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b);
            ok = true;
            format = String(color.r).substr(-1) === &quot;%&quot; ? &quot;prgb&quot; : &quot;rgb&quot;;
        }
        else if (isValidCSSUnit(color.h) &amp;&amp; isValidCSSUnit(color.s) &amp;&amp; isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s);
            v = convertToPercentage(color.v);
            rgb = hsvToRgb(color.h, s, v);
            ok = true;
            format = &quot;hsv&quot;;
        }
        else if (isValidCSSUnit(color.h) &amp;&amp; isValidCSSUnit(color.s) &amp;&amp; isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s);
            l = convertToPercentage(color.l);
            rgb = hslToRgb(color.h, s, l);
            ok = true;
            format = &quot;hsl&quot;;
        }

        if (color.hasOwnProperty(&quot;a&quot;)) {
            a = color.a;
        }
    }

    a = boundAlpha(a);

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    };
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-10" class="pilcrow">¶</a></div><h2 id="conversion-functions">Conversion Functions</h2></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-11" class="pilcrow">¶</a></div><p><code>rgbToHsl</code>, <code>rgbToHsv</code>, <code>hslToRgb</code>, <code>hsvToRgb</code> modified from: <a href="http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript">http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript</a></p></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-12" class="pilcrow">¶</a></div><p><code>rgbToRgb</code> Handle bounds / percentage checking to conform to CSS color spec <a href="http://www.w3.org/TR/css3-color/">http://www.w3.org/TR/css3-color/</a> <em>Assumes:</em> r, g, b in [0, 255] or [0, 1] <em>Returns:</em> { r, g, b } in [0, 255]</p></td><td><div class="highlight"><pre><code>function rgbToRgb(r, g, b){
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    };
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-13" class="pilcrow">¶</a></div><p><code>rgbToHsl</code> Converts an RGB color value to HSL. <em>Assumes:</em> r, g, and b are contained in [0, 255] or [0, 1] <em>Returns:</em> { h, s, l } in [0,1]</p></td><td><div class="highlight"><pre><code>function rgbToHsl(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, l = (max + min) / 2;

    if(max == min) {
        h = s = 0; // achromatic
    }
    else {
        var d = max - min;
        s = l &gt; 0.5 ? d / (2 - max - min) : d / (max + min);
        switch(max) {
            case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }

        h /= 6;
    }

    return { h: h, s: s, l: l };
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-14" class="pilcrow">¶</a></div><p><code>hslToRgb</code> Converts an HSL color value to RGB. <em>Assumes:</em> h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100] <em>Returns:</em> { r, g, b } in the set [0, 255]</p></td><td><div class="highlight"><pre><code>function hslToRgb(h, s, l) {
    var r, g, b;

    h = bound01(h, 360);
    s = bound01(s, 100);
    l = bound01(l, 100);

    function hue2rgb(p, q, t) {
        if(t &lt; 0) t += 1;
        if(t &gt; 1) t -= 1;
        if(t &lt; 1/6) return p + (q - p) * 6 * t;
        if(t &lt; 1/2) return q;
        if(t &lt; 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }

    if(s === 0) {
        r = g = b = l; // achromatic
    }
    else {
        var q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }

    return { r: r * 255, g: g * 255, b: b * 255 };
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-15" class="pilcrow">¶</a></div><p><code>rgbToHsv</code> Converts an RGB color value to HSV <em>Assumes:</em> r, g, and b are contained in the set [0, 255] or [0, 1] <em>Returns:</em> { h, s, v } in [0,1]</p></td><td><div class="highlight"><pre><code>function rgbToHsv(r, g, b) {

    r = bound01(r, 255);
    g = bound01(g, 255);
    b = bound01(b, 255);

    var max = mathMax(r, g, b), min = mathMin(r, g, b);
    var h, s, v = max;

    var d = max - min;
    s = max === 0 ? 0 : d / max;

    if(max == min) {
        h = 0; // achromatic
    }
    else {
        switch(max) {
            case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-16" class="pilcrow">¶</a></div><p><code>hsvToRgb</code> Converts an HSV color value to RGB. <em>Assumes:</em> h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100] <em>Returns:</em> { r, g, b } in the set [0, 255]</p></td><td><div class="highlight"><pre><code> function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6;
    s = bound01(s, 100);
    v = bound01(v, 100);

    var i = Math.floor(h),
        f = h - i,
        p = v * (1 - s),
        q = v * (1 - f * s),
        t = v * (1 - (1 - f) * s),
        mod = i % 6,
        r = [v, q, p, p, t, v][mod],
        g = [t, v, v, q, p, p][mod],
        b = [p, p, t, v, v, q][mod];

    return { r: r * 255, g: g * 255, b: b * 255 };
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-17" class="pilcrow">¶</a></div><p><code>rgbToHex</code> Converts an RGB color to hex Assumes r, g, and b are contained in the set [0, 255] Returns a 3 or 6 character hex</p></td><td><div class="highlight"><pre><code>function rgbToHex(r, g, b, allow3Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-18" class="pilcrow">¶</a></div><p>Return a 3 character hex if possible</p></td><td><div class="highlight"><pre><code>    if (allow3Char &amp;&amp; hex[0].charAt(0) == hex[0].charAt(1) &amp;&amp; hex[1].charAt(0) == hex[1].charAt(1) &amp;&amp; hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
    }

    return hex.join(&quot;&quot;);
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-19" class="pilcrow">¶</a></div><p><code>rgbaToHex</code> Converts an RGBA color plus alpha transparency to hex Assumes r, g, b are contained in the set [0, 255] and a in [0, 1]. Returns a 4 or 8 character rgba hex</p></td><td><div class="highlight"><pre><code>function rgbaToHex(r, g, b, a, allow4Char) {

    var hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ];</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-20" class="pilcrow">¶</a></div><p>Return a 4 character hex if possible</p></td><td><div class="highlight"><pre><code>    if (allow4Char &amp;&amp; hex[0].charAt(0) == hex[0].charAt(1) &amp;&amp; hex[1].charAt(0) == hex[1].charAt(1) &amp;&amp; hex[2].charAt(0) == hex[2].charAt(1) &amp;&amp; hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
    }

    return hex.join(&quot;&quot;);
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-21" class="pilcrow">¶</a></div><p><code>rgbaToArgbHex</code> Converts an RGBA color to an ARGB Hex8 string Rarely used, but required for "toFilter()"</p></td><td><div class="highlight"><pre><code>function rgbaToArgbHex(r, g, b, a) {

    var hex = [
        pad2(convertDecimalToHex(a)),
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ];

    return hex.join(&quot;&quot;);
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-22" class="pilcrow">¶</a></div><p><code>equals</code> Can be called with any tinycolor input</p></td><td><div class="highlight"><pre><code>tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) { return false; }
    return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    });
};</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-23" class="pilcrow">¶</a></div><h2 id="modification-functions">Modification Functions</h2><p>Thanks to less.js for some of the basics here <a href="https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js">https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js</a></p></td><td><div class="highlight"><pre><code>function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return tinycolor(hsl);
}

function greyscale(color) {
    return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var rgb = tinycolor(color).toRgb();
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
    return tinycolor(rgb);
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10);
    var hsl = tinycolor(color).toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return tinycolor(hsl);
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-24" class="pilcrow">¶</a></div><p>Spin takes a positive or negative amount within [-360, 360] indicating the change of hue. Values outside of this range will be wrapped into this range.</p></td><td><div class="highlight"><pre><code>function spin(color, amount) {
    var hsl = tinycolor(color).toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue &lt; 0 ? 360 + hue : hue;
    return tinycolor(hsl);
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-25" class="pilcrow">¶</a></div><h2 id="combination-functions">Combination Functions</h2><p>Thanks to jQuery xColor for some of the ideas behind these <a href="https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js">https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js</a></p></td><td><div class="highlight"><pre><code>function complement(color) {
    var hsl = tinycolor(color).toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return tinycolor(hsl);
}

function triad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ];
}

function tetrad(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ];
}

function splitcomplement(color) {
    var hsl = tinycolor(color).toHsl();
    var h = hsl.h;
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
    ];
}

function analogous(color, results, slices) {
    results = results || 6;
    slices = slices || 30;

    var hsl = tinycolor(color).toHsl();
    var part = 360 / slices;
    var ret = [tinycolor(color)];

    for (hsl.h = ((hsl.h - (part * results &gt;&gt; 1)) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
    }
    return ret;
}

function monochromatic(color, results) {
    results = results || 6;
    var hsv = tinycolor(color).toHsv();
    var h = hsv.h, s = hsv.s, v = hsv.v;
    var ret = [];
    var modification = 1 / results;

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v}));
        v = (v + modification) % 1;
    }

    return ret;
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-26" class="pilcrow">¶</a></div><h2 id="utility-functions">Utility Functions</h2></td><td><div class="highlight"><pre><code>tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50);

    var rgb1 = tinycolor(color1).toRgb();
    var rgb2 = tinycolor(color2).toRgb();

    var p = amount / 100;

    var rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    };

    return tinycolor(rgba);
};</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-27" class="pilcrow">¶</a></div><h2 id="readability-functions">Readability Functions</h2></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-28" class="pilcrow">¶</a></div><p><code>contrast</code> Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)</p></td><td><div class="highlight"><pre><code>tinycolor.readability = function(color1, color2) {
    var c1 = tinycolor(color1);
    var c2 = tinycolor(color2);
    return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-29" class="pilcrow">¶</a></div><p><code>isReadable</code> Ensure that foreground and background color combinations meet WCAG2 guidelines. The third argument is an optional Object. the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA'; the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'. If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.</p></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-30" class="pilcrow">¶</a></div><p><em>Example</em> tinycolor.isReadable("#000", "#111") =&gt; false tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) =&gt; false</p></td><td><div class="highlight"><pre><code>tinycolor.isReadable = function(color1, color2, wcag2) {
    var readability = tinycolor.readability(color1, color2);
    var wcag2Parms, out;

    out = false;

    wcag2Parms = validateWCAG2Parms(wcag2);
    switch (wcag2Parms.level + wcag2Parms.size) {
        case &quot;AAsmall&quot;:
        case &quot;AAAlarge&quot;:
            out = readability &gt;= 4.5;
            break;
        case &quot;AAlarge&quot;:
            out = readability &gt;= 3;
            break;
        case &quot;AAAsmall&quot;:
            out = readability &gt;= 7;
            break;
    }
    return out;

};</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-31" class="pilcrow">¶</a></div><p><code>mostReadable</code> Given a base color and a list of possible foreground or background colors for that base, returns the most readable color. Optionally returns Black or White if the most readable color is unreadable. <em>Example</em> tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255" tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString(); // "#ffffff" tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3" tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"</p></td><td><div class="highlight"><pre><code>tinycolor.mostReadable = function(baseColor, colorList, args) {
    var bestColor = null;
    var bestScore = 0;
    var readability;
    var includeFallbackColors, level, size ;
    args = args || {};
    includeFallbackColors = args.includeFallbackColors ;
    level = args.level;
    size = args.size;

    for (var i= 0; i &lt; colorList.length ; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability &gt; bestScore) {
            bestScore = readability;
            bestColor = tinycolor(colorList[i]);
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, {&quot;level&quot;:level,&quot;size&quot;:size}) || !includeFallbackColors) {
        return bestColor;
    }
    else {
        args.includeFallbackColors=false;
        return tinycolor.mostReadable(baseColor,[&quot;#fff&quot;, &quot;#000&quot;],args);
    }
};</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-32" class="pilcrow">¶</a></div><h2 id="big-list-of-colors">Big List of Colors</h2><p><a href="http://www.w3.org/TR/css3-color/#svg-color">http://www.w3.org/TR/css3-color/#svg-color</a></p></td><td><div class="highlight"><pre><code>var names = tinycolor.names = {
    aliceblue: &quot;f0f8ff&quot;,
    antiquewhite: &quot;faebd7&quot;,
    aqua: &quot;0ff&quot;,
    aquamarine: &quot;7fffd4&quot;,
    azure: &quot;f0ffff&quot;,
    beige: &quot;f5f5dc&quot;,
    bisque: &quot;ffe4c4&quot;,
    black: &quot;000&quot;,
    blanchedalmond: &quot;ffebcd&quot;,
    blue: &quot;00f&quot;,
    blueviolet: &quot;8a2be2&quot;,
    brown: &quot;a52a2a&quot;,
    burlywood: &quot;deb887&quot;,
    burntsienna: &quot;ea7e5d&quot;,
    cadetblue: &quot;5f9ea0&quot;,
    chartreuse: &quot;7fff00&quot;,
    chocolate: &quot;d2691e&quot;,
    coral: &quot;ff7f50&quot;,
    cornflowerblue: &quot;6495ed&quot;,
    cornsilk: &quot;fff8dc&quot;,
    crimson: &quot;dc143c&quot;,
    cyan: &quot;0ff&quot;,
    darkblue: &quot;00008b&quot;,
    darkcyan: &quot;008b8b&quot;,
    darkgoldenrod: &quot;b8860b&quot;,
    darkgray: &quot;a9a9a9&quot;,
    darkgreen: &quot;006400&quot;,
    darkgrey: &quot;a9a9a9&quot;,
    darkkhaki: &quot;bdb76b&quot;,
    darkmagenta: &quot;8b008b&quot;,
    darkolivegreen: &quot;556b2f&quot;,
    darkorange: &quot;ff8c00&quot;,
    darkorchid: &quot;9932cc&quot;,
    darkred: &quot;8b0000&quot;,
    darksalmon: &quot;e9967a&quot;,
    darkseagreen: &quot;8fbc8f&quot;,
    darkslateblue: &quot;483d8b&quot;,
    darkslategray: &quot;2f4f4f&quot;,
    darkslategrey: &quot;2f4f4f&quot;,
    darkturquoise: &quot;00ced1&quot;,
    darkviolet: &quot;9400d3&quot;,
    deeppink: &quot;ff1493&quot;,
    deepskyblue: &quot;00bfff&quot;,
    dimgray: &quot;696969&quot;,
    dimgrey: &quot;696969&quot;,
    dodgerblue: &quot;1e90ff&quot;,
    firebrick: &quot;b22222&quot;,
    floralwhite: &quot;fffaf0&quot;,
    forestgreen: &quot;228b22&quot;,
    fuchsia: &quot;f0f&quot;,
    gainsboro: &quot;dcdcdc&quot;,
    ghostwhite: &quot;f8f8ff&quot;,
    gold: &quot;ffd700&quot;,
    goldenrod: &quot;daa520&quot;,
    gray: &quot;808080&quot;,
    green: &quot;008000&quot;,
    greenyellow: &quot;adff2f&quot;,
    grey: &quot;808080&quot;,
    honeydew: &quot;f0fff0&quot;,
    hotpink: &quot;ff69b4&quot;,
    indianred: &quot;cd5c5c&quot;,
    indigo: &quot;4b0082&quot;,
    ivory: &quot;fffff0&quot;,
    khaki: &quot;f0e68c&quot;,
    lavender: &quot;e6e6fa&quot;,
    lavenderblush: &quot;fff0f5&quot;,
    lawngreen: &quot;7cfc00&quot;,
    lemonchiffon: &quot;fffacd&quot;,
    lightblue: &quot;add8e6&quot;,
    lightcoral: &quot;f08080&quot;,
    lightcyan: &quot;e0ffff&quot;,
    lightgoldenrodyellow: &quot;fafad2&quot;,
    lightgray: &quot;d3d3d3&quot;,
    lightgreen: &quot;90ee90&quot;,
    lightgrey: &quot;d3d3d3&quot;,
    lightpink: &quot;ffb6c1&quot;,
    lightsalmon: &quot;ffa07a&quot;,
    lightseagreen: &quot;20b2aa&quot;,
    lightskyblue: &quot;87cefa&quot;,
    lightslategray: &quot;789&quot;,
    lightslategrey: &quot;789&quot;,
    lightsteelblue: &quot;b0c4de&quot;,
    lightyellow: &quot;ffffe0&quot;,
    lime: &quot;0f0&quot;,
    limegreen: &quot;32cd32&quot;,
    linen: &quot;faf0e6&quot;,
    magenta: &quot;f0f&quot;,
    maroon: &quot;800000&quot;,
    mediumaquamarine: &quot;66cdaa&quot;,
    mediumblue: &quot;0000cd&quot;,
    mediumorchid: &quot;ba55d3&quot;,
    mediumpurple: &quot;9370db&quot;,
    mediumseagreen: &quot;3cb371&quot;,
    mediumslateblue: &quot;7b68ee&quot;,
    mediumspringgreen: &quot;00fa9a&quot;,
    mediumturquoise: &quot;48d1cc&quot;,
    mediumvioletred: &quot;c71585&quot;,
    midnightblue: &quot;191970&quot;,
    mintcream: &quot;f5fffa&quot;,
    mistyrose: &quot;ffe4e1&quot;,
    moccasin: &quot;ffe4b5&quot;,
    navajowhite: &quot;ffdead&quot;,
    navy: &quot;000080&quot;,
    oldlace: &quot;fdf5e6&quot;,
    olive: &quot;808000&quot;,
    olivedrab: &quot;6b8e23&quot;,
    orange: &quot;ffa500&quot;,
    orangered: &quot;ff4500&quot;,
    orchid: &quot;da70d6&quot;,
    palegoldenrod: &quot;eee8aa&quot;,
    palegreen: &quot;98fb98&quot;,
    paleturquoise: &quot;afeeee&quot;,
    palevioletred: &quot;db7093&quot;,
    papayawhip: &quot;ffefd5&quot;,
    peachpuff: &quot;ffdab9&quot;,
    peru: &quot;cd853f&quot;,
    pink: &quot;ffc0cb&quot;,
    plum: &quot;dda0dd&quot;,
    powderblue: &quot;b0e0e6&quot;,
    purple: &quot;800080&quot;,
    rebeccapurple: &quot;663399&quot;,
    red: &quot;f00&quot;,
    rosybrown: &quot;bc8f8f&quot;,
    royalblue: &quot;4169e1&quot;,
    saddlebrown: &quot;8b4513&quot;,
    salmon: &quot;fa8072&quot;,
    sandybrown: &quot;f4a460&quot;,
    seagreen: &quot;2e8b57&quot;,
    seashell: &quot;fff5ee&quot;,
    sienna: &quot;a0522d&quot;,
    silver: &quot;c0c0c0&quot;,
    skyblue: &quot;87ceeb&quot;,
    slateblue: &quot;6a5acd&quot;,
    slategray: &quot;708090&quot;,
    slategrey: &quot;708090&quot;,
    snow: &quot;fffafa&quot;,
    springgreen: &quot;00ff7f&quot;,
    steelblue: &quot;4682b4&quot;,
    tan: &quot;d2b48c&quot;,
    teal: &quot;008080&quot;,
    thistle: &quot;d8bfd8&quot;,
    tomato: &quot;ff6347&quot;,
    turquoise: &quot;40e0d0&quot;,
    violet: &quot;ee82ee&quot;,
    wheat: &quot;f5deb3&quot;,
    white: &quot;fff&quot;,
    whitesmoke: &quot;f5f5f5&quot;,
    yellow: &quot;ff0&quot;,
    yellowgreen: &quot;9acd32&quot;
};</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-33" class="pilcrow">¶</a></div><p>Make it easy to access colors via <code>hexNames[hex]</code></p></td><td><div class="highlight"><pre><code>var hexNames = tinycolor.hexNames = flip(names);</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-34" class="pilcrow">¶</a></div><h2 id="utilities">Utilities</h2></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-35" class="pilcrow">¶</a></div><p><code>{ 'name1': 'val1' }</code> becomes <code>{ 'val1': 'name1' }</code></p></td><td><div class="highlight"><pre><code>function flip(o) {
    var flipped = { };
    for (var i in o) {
        if (o.hasOwnProperty(i)) {
            flipped[o[i]] = i;
        }
    }
    return flipped;
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-36" class="pilcrow">¶</a></div><p>Return a valid alpha value [0,1] with all invalid values being set to 1</p></td><td><div class="highlight"><pre><code>function boundAlpha(a) {
    a = parseFloat(a);

    if (isNaN(a) || a &lt; 0 || a &gt; 1) {
        a = 1;
    }

    return a;
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-37" class="pilcrow">¶</a></div><p>Take input from [0, n] and return it as [0, 1]</p></td><td><div class="highlight"><pre><code>function bound01(n, max) {
    if (isOnePointZero(n)) { n = &quot;100%&quot;; }

    var processPercent = isPercentage(n);
    n = mathMin(max, mathMax(0, parseFloat(n)));</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-38" class="pilcrow">¶</a></div><p>Automatically convert percentage into number</p></td><td><div class="highlight"><pre><code>    if (processPercent) {
        n = parseInt(n * max, 10) / 100;
    }</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-39" class="pilcrow">¶</a></div><p>Handle floating point rounding errors</p></td><td><div class="highlight"><pre><code>    if ((Math.abs(n - max) &lt; 0.000001)) {
        return 1;
    }</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-40" class="pilcrow">¶</a></div><p>Convert into [0, 1] range if it isn't already</p></td><td><div class="highlight"><pre><code>    return (n % max) / parseFloat(max);
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-41" class="pilcrow">¶</a></div><p>Force a number between 0 and 1</p></td><td><div class="highlight"><pre><code>function clamp01(val) {
    return mathMin(1, mathMax(0, val));
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-42" class="pilcrow">¶</a></div><p>Parse a base-16 hex value into a base-10 integer</p></td><td><div class="highlight"><pre><code>function parseIntFromHex(val) {
    return parseInt(val, 16);
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-43" class="pilcrow">¶</a></div><p>Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1 <a href="http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0">http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0</a></p></td><td><div class="highlight"><pre><code>function isOnePointZero(n) {
    return typeof n == &quot;string&quot; &amp;&amp; n.indexOf(&#39;.&#39;) != -1 &amp;&amp; parseFloat(n) === 1;
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-44" class="pilcrow">¶</a></div><p>Check to see if string passed in is a percentage</p></td><td><div class="highlight"><pre><code>function isPercentage(n) {
    return typeof n === &quot;string&quot; &amp;&amp; n.indexOf(&#39;%&#39;) != -1;
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-45" class="pilcrow">¶</a></div><p>Force a hex value to have 2 characters</p></td><td><div class="highlight"><pre><code>function pad2(c) {
    return c.length == 1 ? &#39;0&#39; + c : &#39;&#39; + c;
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-46" class="pilcrow">¶</a></div><p>Replace a decimal with it's percentage value</p></td><td><div class="highlight"><pre><code>function convertToPercentage(n) {
    if (n &lt;= 1) {
        n = (n * 100) + &quot;%&quot;;
    }

    return n;
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-47" class="pilcrow">¶</a></div><p>Converts a decimal to a hex value</p></td><td><div class="highlight"><pre><code>function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16);
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-48" class="pilcrow">¶</a></div><p>Converts a hex value to a decimal</p></td><td><div class="highlight"><pre><code>function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255);
}

var matchers = (function() {</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-49" class="pilcrow">¶</a></div><p><a href="http://www.w3.org/TR/css3-values/#integers">http://www.w3.org/TR/css3-values/#integers</a></p></td><td><div class="highlight"><pre><code>    var CSS_INTEGER = &quot;[-\\+]?\\d+%?&quot;;</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-50" class="pilcrow">¶</a></div><p><a href="http://www.w3.org/TR/css3-values/#number-value">http://www.w3.org/TR/css3-values/#number-value</a></p></td><td><div class="highlight"><pre><code>    var CSS_NUMBER = &quot;[-\\+]?\\d*\\.\\d+%?&quot;;</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-51" class="pilcrow">¶</a></div><p>Allow positive/negative integer/number. Don't capture the either/or, just the entire outcome.</p></td><td><div class="highlight"><pre><code>    var CSS_UNIT = &quot;(?:&quot; + CSS_NUMBER + &quot;)|(?:&quot; + CSS_INTEGER + &quot;)&quot;;</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-52" class="pilcrow">¶</a></div><p>Actual matching. Parentheses and commas are optional, but not required. Whitespace can take the place of commas or opening paren</p></td><td><div class="highlight"><pre><code>    var PERMISSIVE_MATCH3 = &quot;[\\s|\\(]+(&quot; + CSS_UNIT + &quot;)[,|\\s]+(&quot; + CSS_UNIT + &quot;)[,|\\s]+(&quot; + CSS_UNIT + &quot;)\\s*\\)?&quot;;
    var PERMISSIVE_MATCH4 = &quot;[\\s|\\(]+(&quot; + CSS_UNIT + &quot;)[,|\\s]+(&quot; + CSS_UNIT + &quot;)[,|\\s]+(&quot; + CSS_UNIT + &quot;)[,|\\s]+(&quot; + CSS_UNIT + &quot;)\\s*\\)?&quot;;

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp(&quot;rgb&quot; + PERMISSIVE_MATCH3),
        rgba: new RegExp(&quot;rgba&quot; + PERMISSIVE_MATCH4),
        hsl: new RegExp(&quot;hsl&quot; + PERMISSIVE_MATCH3),
        hsla: new RegExp(&quot;hsla&quot; + PERMISSIVE_MATCH4),
        hsv: new RegExp(&quot;hsv&quot; + PERMISSIVE_MATCH3),
        hsva: new RegExp(&quot;hsva&quot; + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    };
})();</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-53" class="pilcrow">¶</a></div><p><code>isValidCSSUnit</code> Take in a single string / number and check to see if it looks like a CSS unit (see <code>matchers</code> above for definition).</p></td><td><div class="highlight"><pre><code>function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color);
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-54" class="pilcrow">¶</a></div><p><code>stringInputToObject</code> Permissive string parsing. Take in a number of formats, and output an object based on detected format. Returns <code>{ r, g, b }</code> or <code>{ h, s, l }</code> or <code>{ h, s, v}</code></p></td><td><div class="highlight"><pre><code>function stringInputToObject(color) {

    color = color.replace(trimLeft,&#39;&#39;).replace(trimRight, &#39;&#39;).toLowerCase();
    var named = false;
    if (names[color]) {
        color = names[color];
        named = true;
    }
    else if (color == &#39;transparent&#39;) {
        return { r: 0, g: 0, b: 0, a: 0, format: &quot;name&quot; };
    }</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-55" class="pilcrow">¶</a></div><p>Try to match string input using regular expressions. Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360] Just return an object and let the conversion functions handle that. This way the result will be the same whether the tinycolor is initialized with string or object.</p></td><td><div class="highlight"><pre><code>    var match;
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] };
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] };
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] };
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] };
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] };
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] };
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? &quot;name&quot; : &quot;hex8&quot;
        };
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? &quot;name&quot; : &quot;hex&quot;
        };
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + &#39;&#39; + match[1]),
            g: parseIntFromHex(match[2] + &#39;&#39; + match[2]),
            b: parseIntFromHex(match[3] + &#39;&#39; + match[3]),
            a: convertHexToDecimal(match[4] + &#39;&#39; + match[4]),
            format: named ? &quot;name&quot; : &quot;hex8&quot;
        };
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + &#39;&#39; + match[1]),
            g: parseIntFromHex(match[2] + &#39;&#39; + match[2]),
            b: parseIntFromHex(match[3] + &#39;&#39; + match[3]),
            format: named ? &quot;name&quot; : &quot;hex&quot;
        };
    }

    return false;
}

function validateWCAG2Parms(parms) {</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-56" class="pilcrow">¶</a></div><p>return valid WCAG2 parms for isReadable. If input parms are invalid, return {"level":"AA", "size":"small"}</p></td><td><div class="highlight"><pre><code>    var level, size;
    parms = parms || {&quot;level&quot;:&quot;AA&quot;, &quot;size&quot;:&quot;small&quot;};
    level = (parms.level || &quot;AA&quot;).toUpperCase();
    size = (parms.size || &quot;small&quot;).toLowerCase();
    if (level !== &quot;AA&quot; &amp;&amp; level !== &quot;AAA&quot;) {
        level = &quot;AA&quot;;
    }
    if (size !== &quot;small&quot; &amp;&amp; size !== &quot;large&quot;) {
        size = &quot;small&quot;;
    }
    return {&quot;level&quot;:level, &quot;size&quot;:size};
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-57" class="pilcrow">¶</a></div><p>Node: Export function</p></td><td><div class="highlight"><pre><code>if (typeof module !== &quot;undefined&quot; &amp;&amp; module.exports) {
    module.exports = tinycolor;
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-58" class="pilcrow">¶</a></div><p>AMD/requirejs: Define the module</p></td><td><div class="highlight"><pre><code>else if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
    define(function () {return tinycolor;});
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-59" class="pilcrow">¶</a></div><p>Browser: Expose to window</p></td><td><div class="highlight"><pre><code>else {
    window.tinycolor = tinycolor;
}

})(Math);
</code></pre></div></td></tr></tbody></table>
