import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { startsWith } from '../utils/lang';
var everythingAtTheEnd = /[^.]+$/;
var everythingAfterCount = /count\.([^/]+)$/;
var latencyMetricNameAndBucket = /latency\.([^/]+)\.bucket\.([0-9]+)$/;

var KeyBuilder = /*#__PURE__*/function () {
  function KeyBuilder(settings) {
    _classCallCheck(this, KeyBuilder);

    this.settings = settings;
  }

  _createClass(KeyBuilder, [{
    key: "buildSplitKey",
    value: function buildSplitKey(splitName) {
      return "".concat(this.settings.storage.prefix, ".split.").concat(splitName);
    }
  }, {
    key: "buildTrafficTypeKey",
    value: function buildTrafficTypeKey(trafficType) {
      return "".concat(this.settings.storage.prefix, ".trafficType.").concat(trafficType);
    }
  }, {
    key: "buildSplitsTillKey",
    value: function buildSplitsTillKey() {
      return "".concat(this.settings.storage.prefix, ".splits.till");
    }
  }, {
    key: "buildSplitsReady",
    value: function buildSplitsReady() {
      return "".concat(this.settings.storage.prefix, ".splits.ready");
    }
  }, {
    key: "isSplitKey",
    value: function isSplitKey(key) {
      return startsWith(key, "".concat(this.settings.storage.prefix, ".split."));
    }
  }, {
    key: "buildSegmentNameKey",
    value: function buildSegmentNameKey(segmentName) {
      return "".concat(this.settings.storage.prefix, ".segment.").concat(segmentName);
    }
  }, {
    key: "buildSegmentTillKey",
    value: function buildSegmentTillKey(segmentName) {
      return "".concat(this.settings.storage.prefix, ".segment.").concat(segmentName, ".till");
    }
  }, {
    key: "buildRegisteredSegmentsKey",
    value: function buildRegisteredSegmentsKey() {
      return "".concat(this.settings.storage.prefix, ".segments.registered");
    }
  }, {
    key: "buildSegmentsReady",
    value: function buildSegmentsReady() {
      return "".concat(this.settings.storage.prefix, ".segments.ready");
    }
  }, {
    key: "buildVersionablePrefix",
    value: function buildVersionablePrefix() {
      return "".concat(this.settings.storage.prefix, "/").concat(this.settings.version, "/").concat(this.settings.runtime.ip);
    }
  }, {
    key: "buildImpressionsKey",
    value: function buildImpressionsKey() {
      return "".concat(this.settings.storage.prefix, ".impressions");
    }
  }, {
    key: "buildEventsKey",
    value: function buildEventsKey() {
      return "".concat(this.settings.storage.prefix, ".events");
    }
  }, {
    key: "buildLatencyKeyPrefix",
    value: function buildLatencyKeyPrefix() {
      return "".concat(this.buildVersionablePrefix(), "/latency");
    }
  }, {
    key: "buildLatencyKey",
    value: function buildLatencyKey(metricName, bucketNumber) {
      return "".concat(this.buildLatencyKeyPrefix(), ".").concat(metricName, ".bucket.").concat(bucketNumber);
    }
  }, {
    key: "buildCountKey",
    value: function buildCountKey(metricName) {
      return "".concat(this.buildVersionablePrefix(), "/count.").concat(metricName);
    }
  }, {
    key: "buildGaugeKey",
    value: function buildGaugeKey(metricName) {
      return "".concat(this.buildVersionablePrefix(), "/gauge.").concat(metricName);
    }
  }, {
    key: "searchPatternForCountKeys",
    value: function searchPatternForCountKeys() {
      return "".concat(this.buildVersionablePrefix(), "/count.*");
    }
  }, {
    key: "searchPatternForSplitKeys",
    value: function searchPatternForSplitKeys() {
      return "".concat(this.settings.storage.prefix, ".split.*");
    }
  }, {
    key: "searchPatternForLatency",
    value: function searchPatternForLatency() {
      return "".concat(this.buildLatencyKeyPrefix(), ".*");
    }
  }, {
    key: "extractKey",
    value: function extractKey(builtKey) {
      var s = builtKey.match(everythingAtTheEnd);

      if (s && s.length) {
        return s[0];
      } else {
        throw new Error('Invalid latency key provided');
      }
    }
  }, {
    key: "extractCounterName",
    value: function extractCounterName(counterKey) {
      var m = counterKey.match(everythingAfterCount);

      if (m && m.length) {
        return m[1]; // everything after count
      } else {
        throw new Error('Invalid counter key provided');
      }
    }
  }, {
    key: "extractLatencyMetricNameAndBucket",
    value: function extractLatencyMetricNameAndBucket(latencyKey) {
      var parts = latencyKey.match(latencyMetricNameAndBucket);

      if (parts && parts.length > 2) {
        return {
          metricName: parts[1],
          bucketNumber: parts[2]
        };
      } else {
        throw new Error('Invalid counter key provided');
      }
    }
  }]);

  return KeyBuilder;
}();

export default KeyBuilder;