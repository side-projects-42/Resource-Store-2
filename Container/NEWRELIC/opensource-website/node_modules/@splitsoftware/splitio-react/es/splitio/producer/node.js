/**
Copyright 2016 Split Software

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**/
import logFactory from '../utils/logger';
var log = logFactory('splitio-producer:updater');
import repeat from '../utils/fn/repeat';
import SplitChangesUpdater from './updater/SplitChanges';
import SegmentChangesUpdater from './updater/SegmentChanges';
/**
 * Expose start / stop mechanism for pulling data from services.
 */

var NodeUpdater = function NodeUpdater(context) {
  var splitsUpdater = SplitChangesUpdater(context, true
  /* tell split updater we are in node */
  );
  var segmentsUpdater = SegmentChangesUpdater(context);
  var settings = context.get(context.constants.SETTINGS);
  var stopSplitsUpdate = false;
  var stopSegmentsUpdate = false;
  var splitFetchCompleted = false;
  var _isRunning = false;
  var _isSynchronizingSplits = false;
  var _isSynchronizingSegments = false;
  /**
   * @param {boolean | undefined} noCache true to revalidate data to fetch
   */

  function synchronizeSplits(noCache) {
    _isSynchronizingSplits = true; // `splitsUpdater` promise always resolves, and with a false value if it fails to fetch or store splits

    return splitsUpdater(0, noCache).then(function (res) {
      // Mark splits as ready (track first successfull call to start downloading segments)
      splitFetchCompleted = true;
      _isSynchronizingSplits = false;
      return res;
    });
  }
  /**
   * @param {string[] | undefined} segmentNames list of segment names to fetch. By passing `undefined` it fetches the list of segments registered at the storage
   * @param {boolean | undefined} noCache true to revalidate data to fetch on a SEGMENT_UPDATE notifications.
   * @param {boolean | undefined} fetchOnlyNew if true, only fetch the segments that not exists, i.e., which `changeNumber` is equal to -1.
   * This param is used by SplitUpdateWorker on server-side SDK, to fetch new registered segments on SPLIT_UPDATE notifications.
   */


  function synchronizeSegment(segmentNames, noCache, fetchOnlyNew) {
    _isSynchronizingSegments = true; // `segmentsUpdater` promise always resolves, and with a false value if it fails to fetch or store some segment

    return segmentsUpdater(segmentNames, noCache, fetchOnlyNew).then(function (res) {
      _isSynchronizingSegments = false;
      return res;
    });
  }

  return {
    // Start periodic fetching (polling)
    start: function start() {
      log.info('Starting NODEJS updater');
      log.debug("Splits will be refreshed each ".concat(settings.scheduler.featuresRefreshRate, " millis"));
      log.debug("Segments will be refreshed each ".concat(settings.scheduler.segmentsRefreshRate, " millis")); // Schedule incremental update of segments only if needed

      var spinUpSegmentUpdater = function spinUpSegmentUpdater() {
        // We must check that Split polling is running (i.e. `stopSplitsUpdate !== false`),
        // in case that `spinUpSegmentUpdater` is called once the client has been destroyed.
        if (stopSplitsUpdate && !stopSegmentsUpdate) {
          stopSegmentsUpdate = repeat(function (scheduleSegmentsUpdate) {
            if (splitFetchCompleted) {
              log.debug('Fetching segments');
              synchronizeSegment().then(function () {
                return scheduleSegmentsUpdate();
              });
            } else {
              scheduleSegmentsUpdate();
            }
          }, settings.scheduler.segmentsRefreshRate);
        }
      };

      stopSplitsUpdate = repeat(function (scheduleSplitsUpdate) {
        log.debug('Fetching splits');
        synchronizeSplits().then(function () {
          // Spin up the segments update if needed
          spinUpSegmentUpdater(); // Re-schedule update

          scheduleSplitsUpdate();
        });
      }, settings.scheduler.featuresRefreshRate);
      _isRunning = true;
    },
    // Stop periodic fetching (polling)
    stop: function stop() {
      log.info('Stopping NODEJS updater');
      stopSplitsUpdate && stopSplitsUpdate();
      stopSplitsUpdate = false; // Mark polling stopped, to be able to call `start` again and to avoid polling segments if `spinUpSegmentUpdater` is called after the client has been destroyed.

      stopSegmentsUpdate && stopSegmentsUpdate();
      stopSegmentsUpdate = false;
      _isRunning = false;
    },
    // Used by SyncManager to know if running in polling mode.
    isRunning: function isRunning() {
      return _isRunning;
    },
    // Used by SplitUpdateWorker
    isSynchronizingSplits: function isSynchronizingSplits() {
      return _isSynchronizingSplits;
    },
    synchronizeSplits: synchronizeSplits,
    // Used by SegmentUpdateWorker
    isSynchronizingSegments: function isSynchronizingSegments() {
      return _isSynchronizingSegments;
    },
    synchronizeSegment: synchronizeSegment
  };
};

export default NodeUpdater;