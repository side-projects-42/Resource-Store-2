"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSplits = exports.checkHooks = exports.getStatus = exports.getIsDestroyed = exports.getHasTimedout = exports.getIsReadyFromCache = exports.getIsReady = exports.destroySplitFactory = exports.getSplitSharedClient = exports.getSplitFactory = exports.__factories = void 0;
var react_1 = __importDefault(require("react"));
var splitio_1 = require("./splitio");
// exported for testing purposes
exports.__factories = new Map();
// idempotent operation
function getSplitFactory(config) {
    if (!exports.__factories.has(config)) {
        // SplitSDK is not an idempotent operation
        var newFactory = splitio_1.SplitFactory(config);
        newFactory.sharedClientInstances = new Set();
        newFactory.config = config;
        exports.__factories.set(config, newFactory);
    }
    return exports.__factories.get(config);
}
exports.getSplitFactory = getSplitFactory;
// idempotent operation
function getSplitSharedClient(factory, key, trafficType) {
    // factory.client is an idempotent operation
    var client = factory.client(key, trafficType);
    if (factory.sharedClientInstances) {
        factory.sharedClientInstances.add(client);
    }
    return client;
}
exports.getSplitSharedClient = getSplitSharedClient;
function destroySplitFactory(factory) {
    // call destroy of shared clients and main one
    var destroyPromises = [];
    factory.sharedClientInstances.forEach(function (client) { return destroyPromises.push(client.destroy()); });
    destroyPromises.push(factory.client().destroy());
    // remove references to release allocated memory
    factory.sharedClientInstances.clear();
    exports.__factories.delete(factory.config);
    return Promise.all(destroyPromises);
}
exports.destroySplitFactory = destroySplitFactory;
function getIsReady(client) {
    return client.__context.get(client.__context.constants.READY, true) ? true : false;
}
exports.getIsReady = getIsReady;
function getIsReadyFromCache(client) {
    return client.__context.get(client.__context.constants.READY_FROM_CACHE, true) ? true : false;
}
exports.getIsReadyFromCache = getIsReadyFromCache;
function getHasTimedout(client) {
    return client.__context.get(client.__context.constants.HAS_TIMEDOUT, true) ? true : false;
}
exports.getHasTimedout = getHasTimedout;
function getIsDestroyed(client) {
    return client.__context.get(client.__context.constants.DESTROYED, true) ? true : false;
}
exports.getIsDestroyed = getIsDestroyed;
function getStatus(client) {
    var isReady = client ? getIsReady(client) : false;
    var hasTimedout = client ? getHasTimedout(client) : false;
    return {
        isReady: isReady,
        isReadyFromCache: client ? getIsReadyFromCache(client) : false,
        isTimedout: hasTimedout && !isReady,
        hasTimedout: hasTimedout,
        isDestroyed: client ? getIsDestroyed(client) : false,
    };
}
exports.getStatus = getStatus;
// Other utils
/**
 * Checks if React.useContext is available, and logs given message if not
 *
 * @param message
 * @returns boolean indicating if React.useContext is available
 */
function checkHooks(message) {
    if (!react_1.default.useContext) {
        console.log(message);
        return false;
    }
    else {
        return true;
    }
}
exports.checkHooks = checkHooks;
// Input validation utils that will be replaced eventually
function validateSplits(maybeSplits, listName) {
    if (listName === void 0) { listName = 'split names'; }
    if (Array.isArray(maybeSplits) && maybeSplits.length > 0) {
        var validatedArray_1 = [];
        // Remove invalid values
        maybeSplits.forEach(function (maybeSplit) {
            var splitName = validateSplit(maybeSplit);
            if (splitName)
                validatedArray_1.push(splitName);
        });
        // Strip off duplicated values if we have valid split names then return
        if (validatedArray_1.length)
            return uniq(validatedArray_1);
    }
    console.log("[ERROR] " + listName + " must be a non-empty array.");
    return false;
}
exports.validateSplits = validateSplits;
var TRIMMABLE_SPACES_REGEX = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/;
function validateSplit(maybeSplit, item) {
    if (item === void 0) { item = 'split name'; }
    // tslint:disable-next-line: triple-equals
    if (maybeSplit == undefined) {
        console.log("[ERROR] you passed a null or undefined " + item + ", " + item + " must be a non-empty string.");
    }
    else if (!isString(maybeSplit)) {
        console.log("[ERROR] you passed an invalid " + item + ", " + item + " must be a non-empty string.");
    }
    else {
        if (TRIMMABLE_SPACES_REGEX.test(maybeSplit)) {
            console.log("[WARN] " + item + " \"" + maybeSplit + "\" has extra whitespace, trimming.");
            maybeSplit = maybeSplit.trim();
        }
        if (maybeSplit.length > 0) {
            return maybeSplit;
        }
        else {
            console.log("[ERROR] you passed an empty " + item + ", " + item + " must be a non-empty string.");
        }
    }
    return false;
}
/**
 * Removes duplicate items on an array of strings.
 */
function uniq(arr) {
    var seen = {};
    return arr.filter(function (item) {
        return Object.prototype.hasOwnProperty.call(seen, item) ? false : seen[item] = true;
    });
}
/**
 * Checks if a given value is a string.
 */
function isString(val) {
    return typeof val === 'string' || val instanceof String;
}
