"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _backoff = _interopRequireDefault(require("../../utils/backoff"));

/**
 * SplitUpdateWorker class
 */
var SplitUpdateWorker = /*#__PURE__*/function () {
  /**
   * @param {Object} splitStorage splits cache
   * @param {Object} splitProducer node producer or full browser producer
   * @param {Object} splitsEventEmitter
   */
  function SplitUpdateWorker(splitStorage, splitProducer, splitsEventEmitter) {
    (0, _classCallCheck2.default)(this, SplitUpdateWorker);
    this.splitStorage = splitStorage;
    this.splitProducer = splitProducer;
    this.maxChangeNumber = 0;
    this.splitsEventEmitter = splitsEventEmitter;
    this.put = this.put.bind(this);
    this.killSplit = this.killSplit.bind(this);
    this.__handleSplitUpdateCall = this.__handleSplitUpdateCall.bind(this);
    this.backoff = new _backoff.default(this.__handleSplitUpdateCall);
  } // Private method
  // Preconditions: this.splitProducer.isSynchronizingSplits === false


  (0, _createClass2.default)(SplitUpdateWorker, [{
    key: "__handleSplitUpdateCall",
    value: function __handleSplitUpdateCall() {
      var _this = this;

      if (this.maxChangeNumber > this.splitStorage.getChangeNumber()) {
        this.handleNewEvent = false; // fetch splits revalidating data if cached

        this.splitProducer.synchronizeSplits(true).then(function () {
          if (_this.handleNewEvent) {
            _this.__handleSplitUpdateCall();
          } else {
            // fetch new registered segments for server-side API. Not retrying on error
            if (_this.splitProducer.synchronizeSegment) _this.splitProducer.synchronizeSegment(undefined, false, true);

            _this.backoff.scheduleCall();
          }
        });
      }
    }
    /**
     * Invoked by NotificationProcessor on SPLIT_UPDATE event
     *
     * @param {number} changeNumber change number of the SPLIT_UPDATE notification
     */

  }, {
    key: "put",
    value: function put(changeNumber) {
      var currentChangeNumber = this.splitStorage.getChangeNumber();
      if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumber) return;
      this.maxChangeNumber = changeNumber;
      this.handleNewEvent = true;
      this.backoff.reset();
      if (this.splitProducer.isSynchronizingSplits()) return;

      this.__handleSplitUpdateCall();
    }
    /**
     * Invoked by NotificationProcessor on SPLIT_KILL event
     *
     * @param {number} changeNumber change number of the SPLIT_UPDATE notification
     * @param {string} splitName name of split to kill
     * @param {string} defaultTreatment default treatment value
     */

  }, {
    key: "killSplit",
    value: function killSplit(changeNumber, splitName, defaultTreatment) {
      var _this2 = this;

      // @TODO handle retry due to errors in storage, once we allow the definition of custom async storages
      this.splitStorage.killLocally(splitName, defaultTreatment, changeNumber).then(function (updated) {
        // trigger an SDK_UPDATE if Split was killed locally
        if (updated) _this2.splitsEventEmitter.emit(_this2.splitsEventEmitter.SDK_SPLITS_ARRIVED, true); // queues the SplitChanges fetch (only if changeNumber is newer)

        _this2.put(changeNumber);
      });
    }
  }]);
  return SplitUpdateWorker;
}();

exports.default = SplitUpdateWorker;