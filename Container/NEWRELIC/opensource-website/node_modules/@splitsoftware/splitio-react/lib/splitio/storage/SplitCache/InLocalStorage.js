"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _lang = require("../../utils/lang");

var _usesSegments = _interopRequireDefault(require("../../utils/splits/usesSegments"));

var _logger = _interopRequireDefault(require("../../utils/logger"));

var _killLocally = _interopRequireDefault(require("./killLocally"));

var log = (0, _logger.default)('splitio-storage:localstorage');

var SplitCacheLocalStorage = /*#__PURE__*/function () {
  /**
   * @param {Object} keys
   * @param {number} expirationTimestamp
   * @param {Object} splitFiltersValidation
   */
  function SplitCacheLocalStorage(keys, expirationTimestamp, splitFiltersValidation) {
    (0, _classCallCheck2.default)(this, SplitCacheLocalStorage);
    this.keys = keys;
    this.splitFiltersValidation = splitFiltersValidation;

    this.__checkExpiration(expirationTimestamp);

    this.__checkFilterQuery();
  }

  (0, _createClass2.default)(SplitCacheLocalStorage, [{
    key: "decrementCount",
    value: function decrementCount(key) {
      var count = (0, _lang.toNumber)(localStorage.getItem(key)) - 1;
      if (count > 0) localStorage.setItem(key, count);else localStorage.removeItem(key);
    }
  }, {
    key: "decrementCounts",
    value: function decrementCounts(split) {
      try {
        if (split) {
          if (split.trafficTypeName) {
            var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);
            this.decrementCount(ttKey);
          }

          if ((0, _usesSegments.default)(split.conditions)) {
            var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();
            this.decrementCount(segmentsCountKey);
          }
        }
      } catch (e) {
        log.error(e);
      }
    }
  }, {
    key: "incrementCounts",
    value: function incrementCounts(split) {
      try {
        if (split) {
          if (split.trafficTypeName) {
            var ttKey = this.keys.buildTrafficTypeKey(split.trafficTypeName);
            localStorage.setItem(ttKey, (0, _lang.toNumber)(localStorage.getItem(ttKey)) + 1);
          }

          if ((0, _usesSegments.default)(split.conditions)) {
            var segmentsCountKey = this.keys.buildSplitsWithSegmentCountKey();
            localStorage.setItem(segmentsCountKey, (0, _lang.toNumber)(localStorage.getItem(segmentsCountKey)) + 1);
          }
        }
      } catch (e) {
        log.error(e);
      }
    }
  }, {
    key: "addSplit",
    value: function addSplit(splitName, split) {
      try {
        var splitKey = this.keys.buildSplitKey(splitName);
        var splitFromLocalStorage = localStorage.getItem(splitKey);
        var previousSplit = splitFromLocalStorage ? JSON.parse(splitFromLocalStorage) : null;
        this.decrementCounts(previousSplit);
        localStorage.setItem(splitKey, split);
        var parsedSplit = split ? JSON.parse(split) : null;
        this.incrementCounts(parsedSplit);
        return true;
      } catch (e) {
        log.error(e);
        return false;
      }
    }
  }, {
    key: "addSplits",
    value: function addSplits(entries) {
      var _this = this;

      var results = [];
      entries.forEach(function (keyValuePair) {
        results.push(_this.addSplit(keyValuePair[0], keyValuePair[1]));
      });
      return results;
    }
  }, {
    key: "removeSplit",
    value: function removeSplit(splitName) {
      try {
        var split = this.getSplit(splitName);
        localStorage.removeItem(this.keys.buildSplitKey(splitName));
        var parsedSplit = JSON.parse(split);
        this.decrementCounts(parsedSplit);
        return 1;
      } catch (e) {
        log.error(e);
        return 0;
      }
    }
    /**
     * Bulk delete of splits from LocalStorage. Returns the number of deleted keys.
     */

  }, {
    key: "removeSplits",
    value: function removeSplits(names) {
      var i = 0;
      var len = names.length;
      var counter = 0;

      for (; i < len; i++) {
        counter += this.removeSplit(names[i]);
      }

      return counter;
    }
  }, {
    key: "getSplit",
    value: function getSplit(splitName) {
      return localStorage.getItem(this.keys.buildSplitKey(splitName));
    }
  }, {
    key: "setChangeNumber",
    value: function setChangeNumber(changeNumber) {
      // when cache is ready but using a new split query, we must flush all split data
      if (this.cacheReadyButNeedsToFlush) {
        this.flush();
        this.cacheReadyButNeedsToFlush = false;
      } // when using a new split query, we must update it at the store


      if (this.updateNewFilter) {
        log.info('Split filter query was modified. Updating cache.');
        var queryKey = this.keys.buildSplitsFilterQueryKey();
        var queryString = this.splitFiltersValidation.queryString;

        try {
          if (queryString) localStorage.setItem(queryKey, queryString);else localStorage.removeItem(queryKey);
        } catch (e) {
          log.error(e);
        }

        this.updateNewFilter = false;
      }

      try {
        localStorage.setItem(this.keys.buildSplitsTillKey(), changeNumber + ''); // update "last updated" timestamp with current time

        localStorage.setItem(this.keys.buildLastUpdatedKey(), Date.now() + '');
        this.hasSync = true;
        return true;
      } catch (e) {
        log.error(e);
        return false;
      }
    }
  }, {
    key: "getChangeNumber",
    value: function getChangeNumber() {
      var n = -1;
      var value = localStorage.getItem(this.keys.buildSplitsTillKey());

      if (value !== null) {
        value = parseInt(value, 10);
        return (0, _lang.numberIsNaN)(value) ? n : value;
      }

      return n;
    }
  }, {
    key: "getAll",
    value: function getAll() {
      var len = localStorage.length;
      var accum = [];
      var cur = 0;

      while (cur < len) {
        var key = localStorage.key(cur);
        var value = key && localStorage.getItem(key);
        if (key != null && this.keys.isSplitKey(key) && value) accum.push(value);
        cur++;
      }

      return accum;
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      var len = localStorage.length;
      var accum = [];
      var cur = 0;

      while (cur < len) {
        var key = localStorage.key(cur);
        if (key != null && this.keys.isSplitKey(key)) accum.push(this.keys.extractKey(key));
        cur++;
      }

      return accum;
    }
  }, {
    key: "trafficTypeExists",
    value: function trafficTypeExists(trafficType) {
      var ttCount = (0, _lang.toNumber)(localStorage.getItem(this.keys.buildTrafficTypeKey(trafficType)));
      return (0, _lang.numberIsFinite)(ttCount) && ttCount > 0;
    }
  }, {
    key: "usesSegments",
    value: function usesSegments() {
      // If cache hasn't been synchronized with the cloud, assume we need them.
      if (!this.hasSync) return true;
      var storedCount = localStorage.getItem(this.keys.buildSplitsWithSegmentCountKey());
      var splitsWithSegmentsCount = storedCount === null ? 0 : (0, _lang.toNumber)(storedCount);

      if ((0, _lang.numberIsFinite)(splitsWithSegmentsCount)) {
        return splitsWithSegmentsCount > 0;
      } else {
        return true;
      }
    }
    /**
     * Removes all splits cache related data from localStorage (splits, counters, changeNumber and lastUpdated).
     * We cannot simply call `localStorage.clear()` since that implies removing user items from the storage.
     */

  }, {
    key: "flush",
    value: function flush() {
      log.info('Flushing Splits data from localStorage'); // collect item keys

      var len = localStorage.length;
      var accum = [];

      for (var cur = 0; cur < len; cur++) {
        var key = localStorage.key(cur);
        if (key != null && this.keys.isSplitCacheKey(key)) accum.push(key);
      } // remove items


      accum.forEach(function (key) {
        localStorage.removeItem(key);
      });
      this.hasSync = false;
    }
    /**
     * Fetches multiple splits definitions.
     */

  }, {
    key: "fetchMany",
    value: function fetchMany(splitNames) {
      var _this2 = this;

      var splits = {};
      splitNames.forEach(function (splitName) {
        splits[splitName] = localStorage.getItem(_this2.keys.buildSplitKey(splitName));
      });
      return splits;
    }
    /**
     * Check if the splits information is already stored in cache.
     * It is used as condition to emit SDK_SPLITS_CACHE_LOADED, and then SDK_READY_FROM_CACHE.
     * In this function we could add more code to check if the data is valid.
     */

  }, {
    key: "checkCache",
    value: function checkCache() {
      return this.getChangeNumber() > -1 || this.cacheReadyButNeedsToFlush;
    }
    /**
     * Clean Splits cache if its `lastUpdated` timestamp is older than the given `expirationTimestamp`,
     * Clean operation (flush) also updates `lastUpdated` timestamp with current time.
     *
     * @param {number | undefined} expirationTimestamp if the value is not a number, data will not be cleaned
     */

  }, {
    key: "__checkExpiration",
    value: function __checkExpiration(expirationTimestamp) {
      var value = localStorage.getItem(this.keys.buildLastUpdatedKey());

      if (value !== null) {
        value = parseInt(value, 10);
        if (!(0, _lang.numberIsNaN)(value) && value < expirationTimestamp) this.flush();
      }
    }
  }, {
    key: "__checkFilterQuery",
    value: function __checkFilterQuery() {
      var _this3 = this;

      var _this$splitFiltersVal = this.splitFiltersValidation,
          queryString = _this$splitFiltersVal.queryString,
          groupedFilters = _this$splitFiltersVal.groupedFilters;
      var queryKey = this.keys.buildSplitsFilterQueryKey();
      var currentQueryString = localStorage.getItem(queryKey);

      if (currentQueryString !== queryString) {
        try {
          // mark cache to update the new query filter on first successful splits fetch
          this.updateNewFilter = true; // if cache is ready:

          if (this.checkCache()) {
            // * set change number to -1, to fetch splits with -1 `since` value.
            localStorage.setItem(this.keys.buildSplitsTillKey(), '-1'); // * remove from cache splits that doesn't match with the new filters

            this.getKeys().forEach(function (splitName) {
              if (queryString && (groupedFilters.byName.indexOf(splitName) > -1 || groupedFilters.byPrefix.some(function (prefix) {
                return splitName.startsWith(prefix + '__');
              }))) {
                // * set `cacheReadyButNeedsToFlush` so that `checkCache` returns true (the storage is ready to be used) and the data is flushed before updating on first successful splits fetch
                _this3.cacheReadyButNeedsToFlush = true;
                return;
              }

              _this3.removeSplit(splitName);
            });
          }
        } catch (e) {
          log.error(e);
        }
      } // if the filter didn't change, nothing is done

    }
  }]);
  return SplitCacheLocalStorage;
}();

SplitCacheLocalStorage.prototype.killLocally = _killLocally.default;
var _default = SplitCacheLocalStorage;
exports.default = _default;