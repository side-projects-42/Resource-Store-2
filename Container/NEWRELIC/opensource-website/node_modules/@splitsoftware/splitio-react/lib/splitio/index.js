"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SplitFactory = SplitFactory;

var _manager = _interopRequireDefault(require("./manager"));

var _storage = _interopRequireDefault(require("./storage"));

var _readiness2 = _interopRequireDefault(require("./readiness"));

var _settings = _interopRequireDefault(require("./utils/settings"));

var _context = _interopRequireDefault(require("./utils/context"));

var _parser = _interopRequireDefault(require("./utils/key/parser"));

var _logger = _interopRequireWildcard(require("./utils/logger"));

var _timeTracker = _interopRequireDefault(require("./utils/timeTracker"));

var _online = _interopRequireDefault(require("./factory/online"));

var _offline = _interopRequireDefault(require("./factory/offline"));

var _statusManager = _interopRequireDefault(require("./readiness/statusManager"));

var _constants = require("./utils/constants");

var _inputValidation = require("./utils/inputValidation");

var _integrations = _interopRequireDefault(require("./integrations"));

var _counter = _interopRequireDefault(require("./impressions/counter"));

var log = (0, _logger.default)('splitio');

var buildInstanceId = function buildInstanceId(key, trafficType) {
  return "".concat(key.matchingKey ? key.matchingKey : key, "-").concat(key.bucketingKey ? key.bucketingKey : key, "-").concat(trafficType !== undefined ? trafficType : '');
};

function SplitFactory(config) {
  // Cache instances created per factory.
  var clientInstances = {}; // Tracking times. We need to do it here because we need the storage created.

  var readyLatencyTrackers = {
    splitsReadyTracker: _timeTracker.default.start(_timeTracker.default.TaskNames.SPLITS_READY),
    segmentsReadyTracker: _timeTracker.default.start(_timeTracker.default.TaskNames.SEGMENTS_READY),
    sdkReadyTracker: _timeTracker.default.start(_timeTracker.default.TaskNames.SDK_READY)
  };
  var context = new _context.default(); // Put settings config within context

  var settings = (0, _settings.default)(config);
  context.put(context.constants.SETTINGS, settings); // We will just log and allow for the SDK to end up throwing an SDK_TIMEOUT event for devs to handle.

  (0, _inputValidation.validateApiKey)(settings.core.authorizationKey); // Put readiness and statusManager within context
  // Done before adding storage, to let it access readiness gate synchronously

  var gateFactory = (0, _readiness2.default)();
  var readiness = gateFactory(settings.startup.readyTimeout);
  context.put(context.constants.READINESS, readiness);
  var statusManager = (0, _statusManager.default)(context);
  context.put(context.constants.STATUS_MANAGER, statusManager); // Put storage config within context

  var storage = (0, _storage.default)(context);
  context.put(context.constants.STORAGE, storage); // Put counter

  var impressionsCounter = new _counter.default(); // Instantiates new counter for Impressions

  context.put(context.constants.IMPRESSIONS_COUNTER, impressionsCounter); // Put integrationsManager within context.
  // It needs to access the storage, settings and potentially other pieces, so it's registered after them.

  var integrationsManager = (0, _integrations.default)(context);
  context.put(context.constants.INTEGRATIONS_MANAGER, integrationsManager); // Define which type of factory to use

  var splitFactory = settings.mode === _constants.LOCALHOST_MODE ? _offline.default : _online.default;

  var _splitFactory = splitFactory(context, readyLatencyTrackers),
      mainClientInstance = _splitFactory.api,
      mainClientMetricCollectors = _splitFactory.metricCollectors; // It makes no sense to have multiple instances of the manager.


  var managerInstance = (0, _manager.default)(storage.splits, context);
  var parsedDefaultKey = (0, _parser.default)(settings.core.key);
  var defaultInstanceId = buildInstanceId(parsedDefaultKey, settings.core.trafficType);
  clientInstances[defaultInstanceId] = mainClientInstance;
  log.info('New Split SDK instance created.');
  return {
    // Split evaluation and event tracking engine
    client: function client(key, trafficType) {
      if (key === undefined) {
        log.debug('Retrieving default SDK client.');
        return mainClientInstance;
      }

      if (typeof storage.shared != 'function') {
        throw new Error('Shared Client not supported by the storage mechanism. Create isolated instances instead.');
      } // Validate the key value


      var validKey = (0, _inputValidation.validateKey)(key, 'Shared Client instantiation');

      if (validKey === false) {
        throw new Error('Shared Client needs a valid key.');
      }

      var validTrafficType;

      if (trafficType !== undefined) {
        validTrafficType = (0, _inputValidation.validateTrafficType)(trafficType, 'Shared Client instantiation');

        if (validTrafficType === false) {
          throw new Error('Shared Client needs a valid traffic type or no traffic type at all.');
        }
      }

      var instanceId = buildInstanceId(validKey, validTrafficType);

      if (!clientInstances[instanceId]) {
        var sharedSettings = settings.overrideKeyAndTT(validKey, validTrafficType);
        var sharedContext = new _context.default();

        var _readiness = gateFactory(sharedSettings.startup.readyTimeout);

        sharedContext.put(context.constants.READY_FROM_CACHE, context.get(context.constants.READY_FROM_CACHE, true));
        sharedContext.put(context.constants.READINESS, _readiness); // for shared clients, the internal offset of added/removed SDK_READY callbacks is -1

        sharedContext.put(context.constants.STATUS_MANAGER, (0, _statusManager.default)(sharedContext, -1));
        sharedContext.put(context.constants.SETTINGS, sharedSettings);
        sharedContext.put(context.constants.STORAGE, storage.shared(sharedSettings));
        sharedContext.put(context.constants.IMPRESSIONS_COUNTER, impressionsCounter); // As shared clients reuse all the storage information, we don't need to check here if we
        // will use offline or online mode. We should stick with the original decision.

        clientInstances[instanceId] = splitFactory(sharedContext, false, mainClientMetricCollectors).api;
        log.info('New shared client instance created.');
      } else {
        log.debug('Retrieving existing SDK client.');
      }

      return clientInstances[instanceId];
    },
    // Manager API to explore available information
    manager: function manager() {
      log.info('Manager instance retrieved.');
      return managerInstance;
    },
    // Logger wrapper API
    Logger: _logger.API,
    // Expose SDK settings
    settings: settings
  };
}