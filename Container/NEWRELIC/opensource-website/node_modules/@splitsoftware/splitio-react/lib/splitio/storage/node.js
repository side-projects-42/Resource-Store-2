"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _RedisAdapter = _interopRequireDefault(require("./RedisAdapter"));

var _InMemory = _interopRequireDefault(require("./SplitCache/InMemory"));

var _InRedis = _interopRequireDefault(require("./SplitCache/InRedis"));

var _InMemory2 = _interopRequireDefault(require("./SegmentCache/InMemory"));

var _InRedis2 = _interopRequireDefault(require("./SegmentCache/InRedis"));

var _InMemory3 = _interopRequireDefault(require("./ImpressionsCache/InMemory"));

var _InRedis3 = _interopRequireDefault(require("./ImpressionsCache/InRedis"));

var _InMemory4 = _interopRequireDefault(require("./LatencyCache/InMemory"));

var _InRedis4 = _interopRequireDefault(require("./LatencyCache/InRedis"));

var _InMemory5 = _interopRequireDefault(require("./CountCache/InMemory"));

var _InRedis5 = _interopRequireDefault(require("./CountCache/InRedis"));

var _InMemory6 = _interopRequireDefault(require("./EventsCache/InMemory"));

var _InRedis6 = _interopRequireDefault(require("./EventsCache/InRedis"));

var _Keys = _interopRequireDefault(require("./Keys"));

var _Meta = _interopRequireDefault(require("./Meta"));

var _constants = require("../utils/constants");

var NodeStorageFactory = function NodeStorageFactory(context) {
  var settings = context.get(context.constants.SETTINGS);
  var storage = settings.storage;
  var keys = new _Keys.default(settings);

  switch (storage.type) {
    case _constants.STORAGE_REDIS:
      {
        var redis = new _RedisAdapter.default(storage.options);
        var meta = (0, _Meta.default)(settings); // subscription to Redis connect event in order to emit SDK_READY

        var _context$get = context.get(context.constants.READINESS),
            splits = _context$get.splits,
            segments = _context$get.segments;

        redis.on('connect', function () {
          splits.emit(splits.SDK_SPLITS_ARRIVED);
          segments.emit(segments.SDK_SEGMENTS_ARRIVED);
        });
        return {
          splits: new _InRedis.default(keys, redis),
          segments: new _InRedis2.default(keys, redis),
          impressions: new _InRedis3.default(keys, redis, meta),
          metrics: new _InRedis4.default(keys, redis),
          count: new _InRedis5.default(keys, redis),
          events: new _InRedis6.default(keys, redis, meta),
          // When using REDIS we should:
          // 1- Disconnect from the storage
          // 2- Stop sending data to Redis and instance using empty in memory implementation
          destroy: function destroy() {
            redis.disconnect();
            this.splits = new _InMemory.default();
            this.segments = new _InMemory2.default(keys);
            this.impressions = new _InMemory3.default();
            this.metrics = new _InMemory4.default();
            this.count = new _InMemory5.default();
            this.events = new _InMemory6.default(context);
          }
        };
      }

    case _constants.STORAGE_MEMORY:
    default:
      return {
        splits: new _InMemory.default(),
        segments: new _InMemory2.default(keys),
        impressions: new _InMemory3.default(),
        metrics: new _InMemory4.default(),
        count: new _InMemory5.default(),
        events: new _InMemory6.default(context),
        // When using MEMORY we should flush all the storages and leave them empty
        destroy: function destroy() {
          this.splits.flush();
          this.segments.flush();
          this.impressions.clear();
          this.metrics.clear();
          this.count.clear();
          this.events.clear();
        }
      };
  }
};

var _default = NodeStorageFactory;
exports.default = _default;