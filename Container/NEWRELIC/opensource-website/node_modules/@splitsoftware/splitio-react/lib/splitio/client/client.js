"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _logger = _interopRequireDefault(require("../utils/logger"));

var _evaluator = require("../engine/evaluator");

var _impressions = _interopRequireDefault(require("../trackers/impressions"));

var _event = _interopRequireDefault(require("../trackers/event"));

var _timeTracker = _interopRequireDefault(require("../utils/timeTracker"));

var _thenable = _interopRequireDefault(require("../utils/promise/thenable"));

var _factory = require("../utils/key/factory");

var _inputValidation = require("../utils/inputValidation");

var _labels = require("../utils/labels");

var _constants = require("../utils/constants");

var log = (0, _logger.default)('splitio-client');

function ClientFactory(context) {
  var storage = context.get(context.constants.STORAGE);
  var metricCollectors = context.get(context.constants.COLLECTORS);
  var impressionsTracker = (0, _impressions.default)(context);
  var eventTracker = (0, _event.default)(context);

  function getTreatment(key, splitName, attributes) {
    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var taskToBeTracked = _timeTracker.default.TaskNames[withConfig ? 'SDK_GET_TREATMENT_WITH_CONFIG' : 'SDK_GET_TREATMENT'];

    var stopLatencyTracker = _timeTracker.default.start(taskToBeTracked, metricCollectors);

    var evaluation = (0, _evaluator.evaluateFeature)(key, splitName, attributes, storage);

    var wrapUp = function wrapUp(evaluationResult) {
      var treatment = processEvaluation(evaluationResult, splitName, key, attributes, withConfig, "getTreatment".concat(withConfig ? 'withConfig' : ''));
      impressionsTracker.track();
      stopLatencyTracker();
      return treatment;
    };

    return (0, _thenable.default)(evaluation) ? evaluation.then(function (res) {
      return wrapUp(res);
    }) : wrapUp(evaluation);
  }

  function getTreatmentWithConfig(key, splitName, attributes) {
    return getTreatment(key, splitName, attributes, true);
  }

  function getTreatments(key, splitNames, attributes) {
    var withConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var taskToBeTracked = _timeTracker.default.TaskNames[withConfig ? 'SDK_GET_TREATMENTS_WITH_CONFIG' : 'SDK_GET_TREATMENTS'];

    var stopLatencyTracker = _timeTracker.default.start(taskToBeTracked, metricCollectors);

    var wrapUp = function wrapUp(evaluationResults) {
      var results = {};
      Object.keys(evaluationResults).forEach(function (splitName) {
        results[splitName] = processEvaluation(evaluationResults[splitName], splitName, key, attributes, withConfig, "getTreatments".concat(withConfig ? 'withConfig' : ''));
      });
      impressionsTracker.track();
      stopLatencyTracker();
      return results;
    };

    var evaluations = (0, _evaluator.evaluateFeatures)(key, splitNames, attributes, storage);
    return (0, _thenable.default)(evaluations) ? evaluations.then(function (res) {
      return wrapUp(res);
    }) : wrapUp(evaluations);
  }

  function getTreatmentsWithConfig(key, splitNames, attributes) {
    return getTreatments(key, splitNames, attributes, true);
  } // Internal function


  function processEvaluation(evaluation, splitName, key, attributes, withConfig, invokingMethodName) {
    var isSdkReady = context.get(context.constants.READY, true) || context.get(context.constants.READY_FROM_CACHE, true);
    var matchingKey = (0, _factory.matching)(key);
    var bucketingKey = (0, _factory.bucketing)(key); // If the SDK was not ready, treatment may be incorrect due to having Splits but not segments data.

    if (!isSdkReady) {
      evaluation = {
        treatment: _constants.CONTROL,
        label: _labels.SDK_NOT_READY
      };
    }

    var _evaluation = evaluation,
        treatment = _evaluation.treatment,
        label = _evaluation.label,
        changeNumber = _evaluation.changeNumber,
        _evaluation$config = _evaluation.config,
        config = _evaluation$config === void 0 ? null : _evaluation$config;
    log.info("Split: ".concat(splitName, ". Key: ").concat(matchingKey, ". Evaluation: ").concat(treatment, ". Label: ").concat(label));

    if ((0, _inputValidation.validateSplitExistance)(context, splitName, label, invokingMethodName)) {
      log.info('Queueing corresponding impression.');
      impressionsTracker.queue({
        feature: splitName,
        keyName: matchingKey,
        treatment: treatment,
        time: Date.now(),
        bucketingKey: bucketingKey,
        label: label,
        changeNumber: changeNumber
      }, attributes);
    }

    if (withConfig) {
      return {
        treatment: treatment,
        config: config
      };
    }

    return treatment;
  }

  function track(key, trafficTypeName, eventTypeId) {
    var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var properties = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    var size = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1024;
    var matchingKey = (0, _factory.matching)(key);
    var timestamp = Date.now();
    var eventData = {
      eventTypeId: eventTypeId,
      trafficTypeName: trafficTypeName,
      value: value,
      timestamp: timestamp,
      key: matchingKey,
      properties: properties
    }; // This may be async but we only warn, we don't actually care if it is valid or not in terms of queueing the event.

    (0, _inputValidation.validateTrafficTypeExistance)(trafficTypeName, context, 'track');
    return eventTracker.track(eventData, size);
  }

  return {
    getTreatment: getTreatment,
    getTreatmentWithConfig: getTreatmentWithConfig,
    getTreatments: getTreatments,
    getTreatmentsWithConfig: getTreatmentsWithConfig,
    track: track
  };
}

var _default = ClientFactory;
exports.default = _default;