"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _ioredis2 = _interopRequireDefault(require("ioredis"));

var _lang = require("../utils/lang");

var _Sets = require("../utils/lang/Sets");

var _thenable = _interopRequireDefault(require("../utils/promise/thenable"));

var _timeout = _interopRequireDefault(require("../utils/promise/timeout"));

var _logger = _interopRequireDefault(require("../utils/logger"));

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var log = (0, _logger.default)('splitio-storage:redis-adapter'); // If we ever decide to fully wrap every method, there's a Commander.getBuiltinCommands from ioredis.

var METHODS_TO_PROMISE_WRAP = ['set', 'exec', 'del', 'get', 'keys', 'sadd', 'srem', 'sismember', 'smembers', 'incr', 'rpush', 'pipeline', 'expire', 'mget']; // Not part of the settings since it'll vary on each storage. We should be removing storage specific logic from elsewhere.

var DEFAULT_OPTIONS = {
  connectionTimeout: 10000,
  operationTimeout: 5000
}; // Library specifics.

var DEFAULT_LIBRARY_OPTIONS = {
  enableOfflineQueue: false,
  connectTimeout: DEFAULT_OPTIONS.connectionTimeout,
  lazyConnect: false
};
/**
 * Redis adapter on top of the library of choice (written with ioredis) for some extra control.
 */

var RedisAdapter = /*#__PURE__*/function (_ioredis) {
  (0, _inherits2.default)(RedisAdapter, _ioredis);

  var _super = _createSuper(RedisAdapter);

  function RedisAdapter(storageSettings) {
    var _this;

    (0, _classCallCheck2.default)(this, RedisAdapter);

    var options = RedisAdapter._defineOptions(storageSettings); // Call the ioredis constructor


    _this = _super.call.apply(_super, [this].concat((0, _toConsumableArray2.default)(RedisAdapter._defineLibrarySettings(options))));
    _this._options = options;
    _this._notReadyCommandsQueue = [];
    _this._runningCommands = new _Sets._Set();

    _this._listenToEvents();

    _this._setTimeoutWrappers();

    _this._setDisconnectWrapper();

    return _this;
  }

  (0, _createClass2.default)(RedisAdapter, [{
    key: "_listenToEvents",
    value: function _listenToEvents() {
      var _this2 = this;

      this.once('ready', function () {
        var commandsCount = _this2._notReadyCommandsQueue ? _this2._notReadyCommandsQueue.length : 0;
        log.info("Redis connection established. Queued commands: ".concat(commandsCount, "."));
        commandsCount && _this2._notReadyCommandsQueue.forEach(function (queued) {
          log.info("Executing queued ".concat(queued.name, " command."));
          queued.command().then(queued.resolve).catch(queued.reject);
        }); // After the SDK is ready for the first time we'll stop queueing commands. This is just so we can keep handling BUR for them.

        _this2._notReadyCommandsQueue = false;
      });
      this.once('close', function () {
        log.info('Redis connection closed.');
      });
    }
  }, {
    key: "_setTimeoutWrappers",
    value: function _setTimeoutWrappers() {
      var instance = this;
      METHODS_TO_PROMISE_WRAP.forEach(function (method) {
        var originalMethod = instance[method];

        instance[method] = function () {
          var params = arguments;

          function commandWrapper() {
            log.debug("Executing ".concat(method, ".")); // Return original method

            var result = originalMethod.apply(instance, params);

            if ((0, _thenable.default)(result)) {
              // For handling pending commands on disconnect, add to the set and remove once finished.
              // On sync commands there's no need, only thenables.
              instance._runningCommands.add(result);

              var cleanUpRunningCommandsCb = function cleanUpRunningCommandsCb(res) {
                instance._runningCommands.delete(result);

                return res;
              }; // Both success and error remove from queue.


              result.then(cleanUpRunningCommandsCb, cleanUpRunningCommandsCb);
              return (0, _timeout.default)(instance._options.operationTimeout, result).catch(function (err) {
                log.error("".concat(method, " operation threw an error or exceeded configured timeout of ").concat(instance._options.operationTimeout, "ms. Message: ").concat(err)); // Handling is not the adapter responsibility.

                throw err;
              });
            }

            return result;
          }

          if (instance._notReadyCommandsQueue) {
            return new Promise(function (res, rej) {
              instance._notReadyCommandsQueue.unshift({
                resolve: res,
                reject: rej,
                command: commandWrapper,
                name: method.toUpperCase()
              });
            });
          } else {
            return commandWrapper();
          }
        };
      });
    }
  }, {
    key: "_setDisconnectWrapper",
    value: function _setDisconnectWrapper() {
      var instance = this;
      var originalMethod = instance.disconnect;

      instance.disconnect = function disconnect() {
        var params = arguments;
        setTimeout(function deferedDisconnect() {
          if (instance._runningCommands.size > 0) {
            log.info("Attempting to disconnect but there are ".concat(instance._runningCommands.size, " commands still waiting for resolution. Defering disconnection until those finish."));
            Promise.all((0, _Sets.setToArray)(instance._runningCommands)).then(function () {
              log.debug('Pending commands finished successfully, disconnecting.');
              originalMethod.apply(instance, params);
            }).catch(function (e) {
              log.warn("Pending commands finished with error: ".concat(e, ". Proceeding with disconnection."));
              originalMethod.apply(instance, params);
            });
          } else {
            log.debug('No commands pending execution, disconnect.'); // Nothing pending, just proceed.

            originalMethod.apply(instance, params);
          }
        }, 10);
      };
    }
    /**
     * Receives the options and returns an array of parameters for the ioredis constructor.
     * Keeping both redis setup options for backwards compatibility.
     */

  }], [{
    key: "_defineLibrarySettings",
    value: function _defineLibrarySettings(options) {
      var opts = (0, _lang.merge)({}, DEFAULT_LIBRARY_OPTIONS);
      var result = [opts];

      if (!(0, _lang.isString)(options.url)) {
        (0, _lang.merge)(opts, {
          // If it's not the string URL, merge the params separately.
          host: options.host,
          port: options.port,
          db: options.db,
          password: options.pass
        });
      } else {
        // If it IS the string URL, that'll be the first param for ioredis.
        result.unshift(options.url);
      }

      return result;
    }
    /**
     * Parses the options into what we care about.
     */

  }, {
    key: "_defineOptions",
    value: function _defineOptions(_ref) {
      var connectionTimeout = _ref.connectionTimeout,
          operationTimeout = _ref.operationTimeout,
          url = _ref.url,
          host = _ref.host,
          port = _ref.port,
          db = _ref.db,
          pass = _ref.pass;
      var parsedOptions = {
        connectionTimeout: connectionTimeout,
        operationTimeout: operationTimeout,
        url: url,
        host: host,
        port: port,
        db: db,
        pass: pass
      };
      return (0, _lang.merge)({}, DEFAULT_OPTIONS, parsedOptions);
    }
  }]);
  return RedisAdapter;
}(_ioredis2.default);

exports.default = RedisAdapter;