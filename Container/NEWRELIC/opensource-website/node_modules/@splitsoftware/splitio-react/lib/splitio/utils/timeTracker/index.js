"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _lang = require("../lang");

var _LoggerFactory = require("../logger/LoggerFactory");

var _timer = _interopRequireDefault(require("./timer"));

var _thenable = _interopRequireDefault(require("../promise/thenable"));

var _CALLBACKS;

// logger to be used on this module
var logger = new _LoggerFactory.Logger('[TIME TRACKER]', {
  showLevel: false
}); // Map we will use for storing timers data

var timers = {}; // Tasks constants

var CONSTANTS = {
  SDK_READY: 'Getting ready - Split SDK',
  SDK_GET_TREATMENT: 'SDK - Get Treatment',
  SDK_GET_TREATMENTS: 'SDK - Get Treatments',
  SDK_GET_TREATMENT_WITH_CONFIG: 'SDK - Get Treatment with config',
  SDK_GET_TREATMENTS_WITH_CONFIG: 'SDK - Get Treatments with config',
  SPLITS_READY: 'Getting ready - Splits',
  SEGMENTS_READY: 'Getting ready - Segments',
  METRICS_PUSH: 'Pushing - Metrics',
  IMPRESSIONS_PUSH: 'Pushing - Impressions',
  EVENTS_PUSH: 'Pushing - Events',
  MY_SEGMENTS_FETCH: 'Fetching - My Segments',
  SEGMENTS_FETCH: 'Fetching - Segments',
  SPLITS_FETCH: 'Fetching - Splits'
}; // Tasks callbacks, if any

var CALLBACKS = (_CALLBACKS = {}, (0, _defineProperty2.default)(_CALLBACKS, CONSTANTS.SDK_READY, {
  collector: 'client',
  method: 'ready'
}), (0, _defineProperty2.default)(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENT, {
  collector: 'client',
  method: 'getTreatment'
}), (0, _defineProperty2.default)(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENTS, {
  collector: 'client',
  method: 'getTreatments'
}), (0, _defineProperty2.default)(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENT_WITH_CONFIG, {
  collector: 'client',
  method: 'getTreatmentWithConfig'
}), (0, _defineProperty2.default)(_CALLBACKS, CONSTANTS.SDK_GET_TREATMENTS_WITH_CONFIG, {
  collector: 'client',
  method: 'getTreatmentsWithConfig'
}), (0, _defineProperty2.default)(_CALLBACKS, CONSTANTS.MY_SEGMENTS_FETCH, {
  collector: 'mySegments',
  method: 'latency'
}), (0, _defineProperty2.default)(_CALLBACKS, CONSTANTS.SEGMENTS_FETCH, {
  collector: 'segmentChanges',
  method: 'latency'
}), (0, _defineProperty2.default)(_CALLBACKS, CONSTANTS.SPLITS_FETCH, {
  collector: 'splitChanges',
  method: 'latency'
}), _CALLBACKS);
/**
 * Generates the timer keys using the task name and a modifier, if any.
 * @param {string} task - The task name
 * @param {string} modifier - (optional) The modifier, if any.
 * @return {string} The generated timer key
 */

var generateTimerKey = function generateTimerKey(task, modifier) {
  return typeof modifier === 'string' ? task + modifier : task;
};
/**
 * Given the collectors map, it returns the specific collector for a given task.
 *
 * @param {string} task - The task name
 * @param {Object} collectors - The collectors map
 */


var getCollectorForTask = function getCollectorForTask(task, collectors) {
  var callbackData = CALLBACKS[task];
  if (callbackData && collectors) return collectors[callbackData.collector];
  return false;
};
/**
 * Given a collector and a task, returns the callback function that should be called when we stop the timer.
 *
 * @param {string} task - The task name
 * @param {Object} collector - The collector object for the task
 */


var getCallbackForTask = function getCallbackForTask(task, collector) {
  var callbackData = CALLBACKS[task];
  if (callbackData && collector) return collector[callbackData.method];
  return false;
};

var TrackerAPI = {
  /**
   * "Private" method, used to attach count/countException and stop callbacks to a promise.
   *
   * @param {Promise} promise - The promise we want to attach the callbacks.
   * @param {string} task - The name of the task.
   * @param {string} modifier - (optional) The modifier for the task, if any.
   */
  __attachToPromise: function __attachToPromise(promise, task, collector, modifier) {
    var _this = this;

    return promise.then(function (resp) {
      _this.stop(task, modifier);

      if (collector && collector.count) collector.count(resp.status);
      return resp;
    }).catch(function (err) {
      _this.stop(task, modifier);

      if (collector && collector.countException) collector.countException();
      throw err;
    });
  },

  /**
   * Starts tracking the time for a given task. All tasks tracked are considered "unique" because
   * there may be multiple SDK instances tracking a "generic" task, making any task non-generic.
   *
   * @param {string} task - The task we are starting.
   * @param {Object} collectors - The collectors map.
   * @param {Promise} promise - (optional) The promise we are tracking.
   * @return {Function | Promise} The stop function for this specific task or the promise received with the callbacks registered.
   */
  start: function start(task, collectors, promise) {
    var taskUniqueId = (0, _lang.uniqueId)();
    var taskCollector = getCollectorForTask(task, collectors);
    var result; // If we are registering a promise with this task, we should count the status and the exceptions as well
    // as stopping the task when the promise resolves. Then return the promise

    if ((0, _thenable.default)(promise)) {
      result = this.__attachToPromise(promise, task, taskCollector, taskUniqueId);
    } else {
      // If not, we return the stop function, as it will be stopped manually.
      result = this.stop.bind(this, task, taskUniqueId);

      if (CALLBACKS[task] && !taskCollector) {
        // and provide a way for a defered setup of the collector, if needed.
        result.setCollectorForTask = this.setCollectorForTask.bind(this, task, taskUniqueId);
      }
    } // We start the timer, with an uniqueId attached to it's name, and save tracking info for this task.


    var trackingKey = generateTimerKey(task, taskUniqueId);
    var cb = getCallbackForTask(task, taskCollector);
    timers[trackingKey] = {
      cb: cb,
      timer: (0, _timer.default)()
    };
    return result;
  },

  /**
   * Setup the collector for a task that reports metrics.
   *
   * @param {string} task - The task name
   * @param {string} taskUniqueId - The unique identifier for this task
   * @param {Object} collectors - The collectors map.
   */
  setCollectorForTask: function setCollectorForTask(task, taskUniqueId, collectors) {
    var taskCollector = getCollectorForTask(task, collectors);

    if (taskCollector) {
      var trackingKey = generateTimerKey(task, taskUniqueId);
      timers[trackingKey].cb = getCallbackForTask(task, taskCollector);
    }
  },

  /**
   * Stops the tracking of a given task.
   *
   * @param {string} task - The task we are starting.
   * @param {string} modifier - (optional) The modifier for that specific task.
   */
  stop: function stop(task, modifier) {
    var timerName = generateTimerKey(task, modifier);
    var timerData = timers[timerName];

    if (timerData) {
      // Stop the timer and round result for readability.
      var et = timerData.timer();
      logger.debug("[".concat(task, "] took ").concat(et, "ms to finish.")); // Check if we have a tracker callback.

      if (timerData.cb) {
        // If we have a callback, we call it with the elapsed time of the task and then delete the reference.
        timerData.cb(et);
      } // Remove the task tracking reference.


      delete timers[timerName];
      return et;
    }
  },

  /**
   * The constants shortcut for the task names.
   */
  TaskNames: CONSTANTS
}; // Our "time tracker" API

var _default = TrackerAPI;
exports.default = _default;