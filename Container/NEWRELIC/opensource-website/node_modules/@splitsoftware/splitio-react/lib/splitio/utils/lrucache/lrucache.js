"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _linkedlist = require("./linkedlist");

var _Map = typeof Map !== 'undefined' ? Map : /*#__PURE__*/function () {
  // @TODO move this util into its own file
  function MapPoly() {
    (0, _classCallCheck2.default)(this, MapPoly);
  }

  (0, _createClass2.default)(MapPoly, [{
    key: "set",
    value: function set(key, value) {
      this[key] = value;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this[key];
    }
  }, {
    key: "delete",
    value: function _delete(key) {
      delete this[key];
    }
  }, {
    key: "size",
    get: function get() {
      return Object.keys(this).length;
    }
  }]);
  return MapPoly;
}();

var LRUCache = /*#__PURE__*/function () {
  function LRUCache(maxSize) {
    (0, _classCallCheck2.default)(this, LRUCache);
    this.maxLen = maxSize || 1;
    this.items = new _Map();
    this.lru = new _linkedlist.LinkedList();
  }

  (0, _createClass2.default)(LRUCache, [{
    key: "get",
    value: function get(key) {
      var node = this.items.get(key);
      if (!node || !(node instanceof _linkedlist.Node)) return undefined;
      this.lru.unshiftNode(node); // Move to front

      return node.value.value;
    }
  }, {
    key: "set",
    value: function set(key, value) {
      var node = this.items.get(key);

      if (node) {
        if (!(node instanceof _linkedlist.Node)) return false;
        this.lru.unshiftNode(node); // Move to front

        this.lru.head.value.value = value; // Update value
      } else {
        if (this.lru.length === this.maxLen) {
          // Remove last
          var last = this.lru.tail;
          if (!last) return false;
          this.items.delete(last.value.key);
          this.lru.removeNode(this.lru.tail); // Remove node
        }

        this.lru.unshift({
          key: key,
          value: value
        }); // Push front

        this.items.set(key, this.lru.head);
      }

      return true;
    }
  }]);
  return LRUCache;
}();

var _default = LRUCache;
exports.default = _default;