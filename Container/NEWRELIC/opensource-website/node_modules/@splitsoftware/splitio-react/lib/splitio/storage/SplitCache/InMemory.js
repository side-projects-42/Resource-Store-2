"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _lang = require("../../utils/lang");

var _usesSegments = _interopRequireDefault(require("../../utils/splits/usesSegments"));

var _killLocally = _interopRequireDefault(require("./killLocally"));

var SplitCacheInMemory = /*#__PURE__*/function () {
  function SplitCacheInMemory() {
    (0, _classCallCheck2.default)(this, SplitCacheInMemory);
    this.flush();
  }

  (0, _createClass2.default)(SplitCacheInMemory, [{
    key: "addSplit",
    value: function addSplit(splitName, split) {
      var splitFromMemory = this.getSplit(splitName);

      if (splitFromMemory) {
        // We had this Split already
        var previousSplit = JSON.parse(splitFromMemory);

        if (previousSplit.trafficTypeName) {
          var previousTtName = previousSplit.trafficTypeName;
          this.ttCache[previousTtName]--;
          if (!this.ttCache[previousTtName]) delete this.ttCache[previousTtName];
        }

        if ((0, _usesSegments.default)(previousSplit.conditions)) {
          // Substract from segments count for the previous version of this Split.
          this.splitsWithSegmentsCount--;
        }
      }

      var parsedSplit = JSON.parse(split);

      if (parsedSplit) {
        // Store the Split.
        this.splitCache[splitName] = split; // Update TT cache

        var ttName = parsedSplit.trafficTypeName;

        if (ttName) {
          // safeguard
          if (!this.ttCache[ttName]) this.ttCache[ttName] = 0;
          this.ttCache[ttName]++;
        } // Add to segments count for the new version of the Split


        if ((0, _usesSegments.default)(parsedSplit.conditions)) this.splitsWithSegmentsCount++;
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "addSplits",
    value: function addSplits(entries) {
      var _this = this;

      var results = [];
      entries.forEach(function (keyValuePair) {
        results.push(_this.addSplit(keyValuePair[0], keyValuePair[1]));
      });
      return results;
    }
  }, {
    key: "removeSplit",
    value: function removeSplit(splitName) {
      var split = this.getSplit(splitName);

      if (split) {
        // Delete the Split
        delete this.splitCache[splitName];
        var parsedSplit = JSON.parse(split);
        var ttName = parsedSplit.trafficTypeName;

        if (ttName) {
          // safeguard
          this.ttCache[ttName]--; // Update tt cache

          if (!this.ttCache[ttName]) delete this.ttCache[ttName];
        } // Update the segments count.


        if ((0, _usesSegments.default)(parsedSplit.conditions)) this.splitsWithSegmentsCount--;
        return 1;
      } else {
        return 0;
      }
    }
  }, {
    key: "removeSplits",
    value: function removeSplits(splitNames) {
      var _this2 = this;

      splitNames.forEach(function (n) {
        return _this2.removeSplit(n);
      });
      return splitNames.length;
    }
  }, {
    key: "getSplit",
    value: function getSplit(splitName) {
      return this.splitCache[splitName];
    }
  }, {
    key: "setChangeNumber",
    value: function setChangeNumber(changeNumber) {
      this.changeNumber = changeNumber;
      return true;
    }
  }, {
    key: "getChangeNumber",
    value: function getChangeNumber() {
      return this.changeNumber;
    }
  }, {
    key: "getAll",
    value: function getAll() {
      var _this3 = this;

      return this.getKeys().map(function (key) {
        return _this3.splitCache[key];
      });
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      return Object.keys(this.splitCache);
    }
  }, {
    key: "trafficTypeExists",
    value: function trafficTypeExists(trafficType) {
      return (0, _lang.numberIsFinite)(this.ttCache[trafficType]) && this.ttCache[trafficType] > 0;
    }
  }, {
    key: "usesSegments",
    value: function usesSegments() {
      return this.getChangeNumber() === -1 || this.splitsWithSegmentsCount > 0;
    }
  }, {
    key: "flush",
    value: function flush() {
      this.splitCache = {};
      this.ttCache = {};
      this.changeNumber = -1;
      this.splitsWithSegmentsCount = 0;
    }
    /**
     * Fetches multiple splits definitions.
     */

  }, {
    key: "fetchMany",
    value: function fetchMany(splitNames) {
      var _this4 = this;

      var splits = {};
      splitNames.forEach(function (splitName) {
        splits[splitName] = _this4.splitCache[splitName] || null;
      });
      return splits;
    }
    /**
     * Check if the splits information is already stored in cache. In memory there is no cache to check.
     */

  }, {
    key: "checkCache",
    value: function checkCache() {
      return false;
    }
  }]);
  return SplitCacheInMemory;
}();

SplitCacheInMemory.prototype.killLocally = _killLocally.default;
var _default = SplitCacheInMemory;
exports.default = _default;