"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = NodeSyncManagerFactory;

var _PushManager = _interopRequireDefault(require("./PushManager"));

var _producer = _interopRequireDefault(require("../producer"));

var _logger = _interopRequireDefault(require("../utils/logger"));

var _constants = require("./constants");

var log = (0, _logger.default)('splitio-sync:sync-manager');
/**
 * Factory of SyncManager for node
 *
 * @param context main client context
 */

function NodeSyncManagerFactory(context) {
  var producer = (0, _producer.default)(context);
  var settings = context.get(context.constants.SETTINGS); // add producer into the context before creating the PushManager

  context.put(context.constants.PRODUCER, producer);
  var pushManager = settings.streamingEnabled ? (0, _PushManager.default)(context) : undefined;

  function startPolling() {
    if (!producer.isRunning()) {
      log.info('Streaming not available. Starting periodic fetch of data.');
      producer.start();
    } else {
      log.info('Streaming couldn\'t connect. Continue periodic fetch of data.');
    }
  }

  function stopPollingAndSyncAll() {
    log.info('PUSH (re)connected. Syncing and stopping periodic fetch of data.'); // if polling, stop

    if (producer.isRunning()) producer.stop();
    syncAll();
  }

  function syncAll() {
    // fetch splits and segments. There is no need to catch this promise (it is handled by `SplitChangesUpdater`)
    producer.synchronizeSplits().then(function () {
      producer.synchronizeSegment();
    });
  }

  return {
    start: function start() {
      // start syncing
      if (pushManager) {
        syncAll();
        pushManager.on(_constants.PUSH_SUBSYSTEM_UP, stopPollingAndSyncAll);
        pushManager.on(_constants.PUSH_SUBSYSTEM_DOWN, startPolling);
        setTimeout(pushManager.start); // Run in next event-loop cycle as in browser
      } else {
        producer.start();
      }
    },
    stop: function stop() {
      // stop syncing
      if (pushManager) pushManager.stop();
      if (producer.isRunning()) producer.stop();
    }
  };
}