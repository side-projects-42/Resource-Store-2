"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SSEHandlerFactory;

var _NotificationParser = require("./NotificationParser");

var _NotificationKeeper = _interopRequireDefault(require("./NotificationKeeper"));

var _constants = require("../constants");

var _logger = _interopRequireDefault(require("../../utils/logger"));

var log = (0, _logger.default)('splitio-sync:sse-handler');

function isRetryableError(error) {
  if (error.parsedData && error.parsedData.code) {
    var code = error.parsedData.code; // 401 errors due to invalid or expired token (e.g., if refresh token coudn't be executed)

    if (40140 <= code && code <= 40149) return true; // Others 4XX errors (e.g., bad request from the SDK)

    if (40000 <= code && code <= 49999) return false;
  } // network errors or 5XX HTTP errors


  return true;
}
/**
 * Factory for SSEHandler
 *
 * @param {Object} pushEmitter emitter for emitting events related to feedback-loop & update queues
 */


function SSEHandlerFactory(pushEmitter) {
  var notificationKeeper = (0, _NotificationKeeper.default)(pushEmitter);
  return {
    handleOpen: function handleOpen() {
      notificationKeeper.handleOpen();
    },

    /* HTTP & Network errors */
    handleError: function handleError(error) {
      var errorWithParsedData = error;

      try {
        errorWithParsedData = (0, _NotificationParser.errorParser)(error);
      } catch (err) {
        log.warn("Error parsing SSE error notification: ".concat(err));
      }

      var errorMessage = errorWithParsedData.parsedData && errorWithParsedData.parsedData.message;
      log.error("Fail to connect to streaming".concat(errorMessage ? ", with error message: \"".concat(errorMessage, "\"") : ''));

      if (isRetryableError(errorWithParsedData)) {
        pushEmitter.emit(_constants.PUSH_RETRYABLE_ERROR);
      } else {
        pushEmitter.emit(_constants.PUSH_NONRETRYABLE_ERROR);
      }
    },

    /* NotificationProcessor */
    handleMessage: function handleMessage(message) {
      var messageWithParsedData;

      try {
        messageWithParsedData = (0, _NotificationParser.messageParser)(message);
      } catch (err) {
        log.warn("Error parsing new SSE message notification: ".concat(err));
        return;
      }

      var _messageWithParsedDat = messageWithParsedData,
          parsedData = _messageWithParsedDat.parsedData,
          data = _messageWithParsedDat.data,
          channel = _messageWithParsedDat.channel,
          timestamp = _messageWithParsedDat.timestamp;
      log.debug("New SSE message received, with data: ".concat(data, ".")); // we only handle update events if streaming is up.

      if (!notificationKeeper.isStreamingUp() && parsedData.type !== _constants.OCCUPANCY && parsedData.type !== _constants.CONTROL) return;

      switch (parsedData.type) {
        /* update events */
        case _constants.SPLIT_UPDATE:
          pushEmitter.emit(_constants.SPLIT_UPDATE, parsedData.changeNumber);
          break;

        case _constants.SEGMENT_UPDATE:
          pushEmitter.emit(_constants.SEGMENT_UPDATE, parsedData.changeNumber, parsedData.segmentName);
          break;

        case _constants.MY_SEGMENTS_UPDATE:
          pushEmitter.emit(_constants.MY_SEGMENTS_UPDATE, parsedData, channel);
          break;

        case _constants.SPLIT_KILL:
          pushEmitter.emit(_constants.SPLIT_KILL, parsedData.changeNumber, parsedData.splitName, parsedData.defaultTreatment);
          break;

        /* occupancy & control events, handled by NotificationManagerKeeper */

        case _constants.OCCUPANCY:
          notificationKeeper.handleOccupancyEvent(parsedData.metrics.publishers, channel, timestamp);
          break;

        case _constants.CONTROL:
          notificationKeeper.handleControlEvent(parsedData.controlType, channel, timestamp);
          break;

        default:
          break;
      }
    }
  };
}