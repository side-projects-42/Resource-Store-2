"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _bulk = _interopRequireDefault(require("../services/events/bulk"));

var _events = _interopRequireDefault(require("../services/events"));

var _bulk2 = _interopRequireDefault(require("../services/impressions/bulk"));

var _count = _interopRequireDefault(require("../services/impressions/count"));

var _impressions = _interopRequireDefault(require("../services/impressions"));

var _dto = require("../services/impressions/dto");

var _logger = _interopRequireDefault(require("../utils/logger"));

var _constants = require("../utils/constants");

var _objectAssign = _interopRequireDefault(require("object-assign"));

var log = (0, _logger.default)('splitio-client:cleanup'); // 'unload' event is used instead of 'beforeunload', since 'unload' is not a cancelable event, so no other listeners can stop the event from occurring.

var UNLOAD_DOM_EVENT = 'unload';
/**
 * We'll listen for 'unload' event over the window object, since it's the standard way to listen page reload and close.
 *
 */

var BrowserSignalListener = /*#__PURE__*/function () {
  function BrowserSignalListener(context) {
    (0, _classCallCheck2.default)(this, BrowserSignalListener);
    this.storage = context.get(context.constants.STORAGE);
    this.settings = context.get(context.constants.SETTINGS);
    this.flushData = this.flushData.bind(this);

    if (this.settings.sync.impressionsMode === _constants.OPTIMIZED) {
      this.impressionsCounter = context.get(context.constants.IMPRESSIONS_COUNTER);
    }
  }
  /**
   * start method.
   * Called when SplitFactory is initialized.
   * We add a handler on unload events. The handler flushes remaining impressions and events to the backend.
   */


  (0, _createClass2.default)(BrowserSignalListener, [{
    key: "start",
    value: function start() {
      if (typeof window !== 'undefined' && window.addEventListener) {
        log.debug('Registering flush handler when unload page event is triggered.');
        window.addEventListener(UNLOAD_DOM_EVENT, this.flushData);
      }
    }
    /**
     * stop method.
     * Called when client is destroyed.
     * We need to remove the handler for unload events, since it can break if called when Split context was destroyed.
     */

  }, {
    key: "stop",
    value: function stop() {
      if (typeof window !== 'undefined' && window.removeEventListener) {
        log.debug('Deregistering flush handler when unload page event is triggered.');
        window.removeEventListener(UNLOAD_DOM_EVENT, this.flushData);
      }
    }
    /**
     * _flushData method.
     * Called when unload event is triggered. It flushed remaining impressions and events to the backend,
     * using beacon API if possible, or falling back to regular post transport.
     */

  }, {
    key: "flushData",
    value: function flushData() {
      this._flushImpressions();

      this._flushEvents();

      if (this.impressionsCounter) {
        this._flushImpressionsCount();
      }
    }
  }, {
    key: "_flushImpressions",
    value: function _flushImpressions() {
      var impressions = this.storage.impressions; // if there are impressions in storage, send them to backend

      if (!impressions.isEmpty()) {
        var url = this.settings.url('/testImpressions/beacon');
        var impressionsPayload = (0, _dto.fromImpressionsCollector)(impressions, this.settings);
        var extraMetadata = {
          // sim stands for Sync/Split Impressions Mode
          sim: this.settings.sync.impressionsMode === _constants.OPTIMIZED ? _constants.OPTIMIZED : _constants.DEBUG
        };

        if (!this._sendBeacon(url, impressionsPayload, extraMetadata)) {
          (0, _impressions.default)((0, _bulk2.default)(this.settings, {
            body: JSON.stringify(impressionsPayload)
          }));
        }

        impressions.clear();
      }
    }
  }, {
    key: "_flushImpressionsCount",
    value: function _flushImpressionsCount() {
      var impressionsCountPayload = {
        pf: (0, _dto.fromImpressionsCountCollector)(this.impressionsCounter)
      };
      var imprCounts = impressionsCountPayload.pf.length;
      if (imprCounts === 0) return;
      var url = this.settings.url('/testImpressions/count/beacon');

      if (!this._sendBeacon(url, impressionsCountPayload)) {
        (0, _impressions.default)((0, _count.default)(this.settings, {
          body: JSON.stringify(impressionsCountPayload)
        }));
      }
    }
  }, {
    key: "_flushEvents",
    value: function _flushEvents() {
      var events = this.storage.events; // if there are events in storage, send them to backend

      if (!events.isEmpty()) {
        var url = this.settings.url('/events/beacon');
        var eventsPayload = events.toJSON();

        if (!this._sendBeacon(url, eventsPayload)) {
          (0, _events.default)((0, _bulk.default)(this.settings, {
            body: JSON.stringify(eventsPayload)
          }));
        }

        events.clear();
      }
    }
    /**
     * _sendBeacon method.
     * Util method that check if beacon API is available, build the payload and send it.
     */

  }, {
    key: "_sendBeacon",
    value: function _sendBeacon(url, data, extraMetadata) {
      // eslint-disable-next-line compat/compat
      if (typeof navigator !== 'undefined' && navigator.sendBeacon) {
        var json = {
          entries: data,
          token: this.settings.core.authorizationKey,
          sdk: this.settings.version
        }; // Extend with endpoint specific metadata where needed

        if (extraMetadata) (0, _objectAssign.default)(json, extraMetadata); // Stringify the payload

        var payload = JSON.stringify(json); // eslint-disable-next-line compat/compat

        return navigator.sendBeacon(url, payload);
      }

      return false;
    }
  }]);
  return BrowserSignalListener;
}();

exports.default = BrowserSignalListener;