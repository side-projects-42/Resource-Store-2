"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _lang = require("../../utils/lang");

var _logger = _interopRequireDefault(require("../../utils/logger"));

var log = (0, _logger.default)('splitio-storage:redis');
/**
 * Discard errors for an answer of multiple operations.
 */

var processPipelineAnswer = function processPipelineAnswer(results) {
  return results.reduce(function (accum, errValuePair) {
    if (errValuePair[0] === null) accum.push(errValuePair[1]);
    return accum;
  }, []);
};

var SplitCacheInRedis = /*#__PURE__*/function () {
  function SplitCacheInRedis(keys, redis) {
    var _this = this;

    (0, _classCallCheck2.default)(this, SplitCacheInRedis);
    this.redis = redis;
    this.keys = keys;
    this.redisError = false;
    this.redis.on('error', function (e) {
      _this.redisError = e;
    });
    this.redis.on('connect', function () {
      _this.redisError = false;
    });
  }

  (0, _createClass2.default)(SplitCacheInRedis, [{
    key: "addSplit",
    value: function addSplit(splitName, split) {
      return this.redis.set(this.keys.buildSplitKey(splitName), split).then(function (status) {
        return status === 'OK';
      });
    }
  }, {
    key: "addSplits",
    value: function addSplits(entries) {
      var _this2 = this;

      if (entries.length) {
        var cmds = entries.map(function (keyValuePair) {
          return ['set', _this2.keys.buildSplitKey(keyValuePair[0]), keyValuePair[1]];
        });
        return this.redis.pipeline(cmds).exec().then(processPipelineAnswer).then(function (answers) {
          return answers.map(function (status) {
            return status === 'OK';
          });
        });
      } else {
        return [true];
      }
    }
    /**
     * Remove a given split from Redis. Returns the number of deleted keys.
     */

  }, {
    key: "removeSplit",
    value: function removeSplit(splitName) {
      return this.redis.del(this.keys.buildSplitKey(splitName));
    }
    /**
     * Bulk delete of splits from Redis. Returns the number of deleted keys.
     */

  }, {
    key: "removeSplits",
    value: function removeSplits(names) {
      var _this3 = this;

      if (names.length) {
        return this.redis.del(names.map(function (n) {
          return _this3.keys.buildSplitKey(n);
        }));
      } else {
        return Promise.resolve(0);
      }
    }
    /**
     * Get split definition or null if it's not defined.
     */

  }, {
    key: "getSplit",
    value: function getSplit(splitName) {
      if (this.redisError) {
        log.error(this.redisError);
        throw this.redisError;
      }

      return this.redis.get(this.keys.buildSplitKey(splitName));
    }
    /**
     * Set till number.
     *
     * @TODO pending error handling
     */

  }, {
    key: "setChangeNumber",
    value: function setChangeNumber(changeNumber) {
      return this.redis.set(this.keys.buildSplitsTillKey(), changeNumber + '').then(function (status) {
        return status === 'OK';
      });
    }
    /**
     * Get till number or null if it's not defined.
     *
     * @TODO pending error handling
     */

  }, {
    key: "getChangeNumber",
    value: function getChangeNumber() {
      return this.redis.get(this.keys.buildSplitsTillKey()).then(function (value) {
        var i = parseInt(value, 10);
        return (0, _lang.numberIsNaN)(i) ? -1 : i;
      });
    }
    /**
     * @TODO we need to benchmark which is the maximun number of commands we could
     *       pipeline without kill redis performance.
     */

  }, {
    key: "getAll",
    value: function getAll() {
      var _this4 = this;

      return this.redis.keys(this.keys.searchPatternForSplitKeys()).then(function (listOfKeys) {
        return _this4.redis.pipeline(listOfKeys.map(function (k) {
          return ['get', k];
        })).exec();
      }).then(processPipelineAnswer);
    }
  }, {
    key: "getKeys",
    value: function getKeys() {
      var _this5 = this;

      return this.redis.keys(this.keys.searchPatternForSplitKeys()).then(function (listOfKeys) {
        return listOfKeys.map(_this5.keys.extractKey);
      });
    }
  }, {
    key: "trafficTypeExists",
    value: function trafficTypeExists(trafficType) {
      // If there is a number there should be > 0, otherwise the TT is considered as not existent.
      return this.redis.get(this.keys.buildTrafficTypeKey(trafficType)).then(function (ttCount) {
        ttCount = parseInt(ttCount, 10);

        if (!(0, _lang.numberIsFinite)(ttCount) || ttCount < 0) {
          log.info("Could not validate traffic type existance of ".concat(trafficType, " due to data corruption of some sorts."));
          return false;
        }

        return ttCount > 0;
      }).catch(function (e) {
        log.error("Could not validate traffic type existance of ".concat(trafficType, " due to an error: ").concat(e, ".")); // If there is an error, bypass the validation so the event can get tracked.

        return true;
      });
    } // noop, just keeping the interface. This is used by client-side implementations only.

  }, {
    key: "usesSegments",
    value: function usesSegments() {
      return true;
    }
    /**
     * Delete everything in the current database.
     *
     * @NOTE documentation says it never fails.
     */

  }, {
    key: "flush",
    value: function flush() {
      return this.redis.flushdb().then(function (status) {
        return status === 'OK';
      });
    }
    /**
     * Fetches multiple splits definitions.
     */

  }, {
    key: "fetchMany",
    value: function fetchMany(splitNames) {
      var _this6 = this,
          _this$redis;

      if (this.redisError) {
        log.error(this.redisError);
        throw this.redisError;
      }

      var splits = {};
      var keys = splitNames.map(function (splitName) {
        return _this6.keys.buildSplitKey(splitName);
      });
      return (_this$redis = this.redis).mget.apply(_this$redis, (0, _toConsumableArray2.default)(keys)).then(function (splitDefinitions) {
        splitNames.forEach(function (splitName, idx) {
          splits[splitName] = splitDefinitions[idx];
        });
        return Promise.resolve(splits);
      }).catch(function (e) {
        log.error("Could not grab splits due to an error: ".concat(e, "."));
        return Promise.reject(e);
      });
    }
    /**
     * Check if the splits information is already stored in cache. Redis would actually be the cache.
     */

  }, {
    key: "checkCache",
    value: function checkCache() {
      return false;
    }
  }]);
  return SplitCacheInRedis;
}();

var _default = SplitCacheInRedis;
exports.default = _default;