"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _backoff = _interopRequireDefault(require("../../utils/backoff"));

/**
 * SegmentUpdateWorker class
 */
var SegmentUpdateWorker = /*#__PURE__*/function () {
  /**
   * @param {Object} segmentsStorage
   * @param {Object} segmentsProducer
   */
  function SegmentUpdateWorker(segmentsStorage, segmentsProducer) {
    (0, _classCallCheck2.default)(this, SegmentUpdateWorker);
    this.segmentsStorage = segmentsStorage;
    this.segmentsProducer = segmentsProducer;
    this.maxChangeNumbers = {};
    this.put = this.put.bind(this);
    this.__handleSegmentUpdateCall = this.__handleSegmentUpdateCall.bind(this);
    this.backoff = new _backoff.default(this.__handleSegmentUpdateCall);
  } // Private method
  // Preconditions: this.segmentsProducer.isSynchronizingSegments === false
  // Approach similar to MySegmentUpdateWorker due to differences on Segments notifications and endpoint changeNumbers


  (0, _createClass2.default)(SegmentUpdateWorker, [{
    key: "__handleSegmentUpdateCall",
    value: function __handleSegmentUpdateCall() {
      var _this = this;

      var segmentsToFetch = Object.keys(this.maxChangeNumbers).filter(function (segmentName) {
        return _this.maxChangeNumbers[segmentName] > _this.segmentsStorage.getChangeNumber(segmentName);
      });

      if (segmentsToFetch.length > 0) {
        this.handleNewEvent = false;
        var currentMaxChangeNumbers = segmentsToFetch.map(function (segmentToFetch) {
          return _this.maxChangeNumbers[segmentToFetch];
        }); // fetch segments revalidating data if cached

        this.segmentsProducer.synchronizeSegment(segmentsToFetch, true).then(function (result) {
          // Unlike `SplitUpdateWorker` where changeNumber is consistent between notification and endpoint, if there is no error,
          // we must clean the `maxChangeNumbers` of those segments that didn't receive a new update notification during the fetch.
          if (result !== false) {
            segmentsToFetch.forEach(function (fetchedSegment, index) {
              if (_this.maxChangeNumbers[fetchedSegment] === currentMaxChangeNumbers[index]) _this.maxChangeNumbers[fetchedSegment] = -1;
            });
          } else {
            // recursive invocation with backoff if there was some error
            _this.backoff.scheduleCall();
          } // immediate recursive invocation if a new notification was queued during fetch


          if (_this.handleNewEvent) {
            _this.__handleSegmentUpdateCall();
          }
        });
      }
    }
    /**
     * Invoked by NotificationProcessor on SEGMENT_UPDATE event
     *
     * @param {number} changeNumber change number of the SEGMENT_UPDATE notification
     * @param {string} segmentName segment name of the SEGMENT_UPDATE notification
     */

  }, {
    key: "put",
    value: function put(changeNumber, segmentName) {
      var currentChangeNumber = this.segmentsStorage.getChangeNumber(segmentName);
      if (changeNumber <= currentChangeNumber || changeNumber <= this.maxChangeNumbers[segmentName]) return;
      this.maxChangeNumbers[segmentName] = changeNumber;
      this.handleNewEvent = true;
      this.backoff.reset();
      if (this.segmentsProducer.isSynchronizingSegments()) return;

      this.__handleSegmentUpdateCall();
    }
  }]);
  return SegmentUpdateWorker;
}();

exports.default = SegmentUpdateWorker;