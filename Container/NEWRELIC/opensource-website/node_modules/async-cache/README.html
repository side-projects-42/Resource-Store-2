<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="async-cache">async-cache</h1>
<p>Cache your async lookups and don’t fetch the same thing more than necessary.</p>
<h2 id="example">Example</h2>
<p>Let’s say you have to look up stat info from paths. But you are ok with only looking up the stat info once every 10 minutes (since it doesn’t change that often), and you want to limit your cache size to 1000 objects, and never have two stat calls for the same file happening at the same time (since that’s silly and unnecessary).</p>
<p>You can do this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">var</span> stats <span class="op">=</span> <span class="kw">new</span> <span class="at">AsyncCache</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="co">// options passed directly to the internal lru cache</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="dt">max</span><span class="op">:</span> <span class="dv">1000</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="dt">maxAge</span><span class="op">:</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">60</span> <span class="op">*</span> <span class="dv">10</span><span class="op">,</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="co">// method to load a thing if it&#39;s not in the cache.</span></a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="co">// key must be unique in the context of this cache.</span></a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="dt">load</span><span class="op">:</span> <span class="kw">function</span> (key<span class="op">,</span> cb) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="co">// the key can be something like the path, or fd+path, or whatever.</span></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="co">// something that will be unique.</span></a>
<a class="sourceLine" id="cb1-10" title="10">    <span class="co">// this method will only be called if it&#39;s not already in cache, and will</span></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="co">// cache the result in the lru.</span></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="at">getTheStatFromTheKey</span>(key<span class="op">,</span> cb)</a>
<a class="sourceLine" id="cb1-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="op">}</span>)</a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16"><span class="co">// then later..</span></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="va">stats</span>.<span class="at">get</span>(fd <span class="op">+</span> <span class="st">&#39;:&#39;</span> <span class="op">+</span> path<span class="op">,</span> <span class="kw">function</span> (er<span class="op">,</span> stat) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-18" title="18">  <span class="co">// maybe loaded from cache, maybe just fetched</span></a>
<a class="sourceLine" id="cb1-19" title="19"><span class="op">}</span>)</a></code></pre></div>
<p>Except for the <code>load</code> method, all the options are passed unmolested to the internal <a href="http://npm.im/lru-cache">lru-cache</a>.</p>
<h3 id="differences-from-lru-cache">Differences from <a href="http://npm.im/lru-cache">lru-cache</a></h3>
<p>Since values are fetched asynchronously, the <code>get</code> method takes a callback, rather than returning the value synchronously.</p>
<p>While there is a <code>set(k,v)</code> method to manually seed the cache, typically you’ll just call <code>get</code> and let the load function fetch the key for you.</p>
<p>Keys must uniquely identify a single object, and must contain all the information required to fetch an object, and must be strings.</p>
<h3 id="per-key-maxage">Per key <code>maxAge</code></h3>
<p>If <code>load</code> callback is called with 3 arguments, the 3rd is passed to the internal <a href="http://npm.im/lru-cache">lru-cache</a> as a <code>maxAge</code> for the retrieved key.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1">  <span class="kw">function</span> <span class="at">load</span> (key<span class="op">,</span> cb) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="at">getValueFromTheKey</span>(key<span class="op">,</span> <span class="kw">function</span> (err<span class="op">,</span> item) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">      <span class="at">cb</span>(err<span class="op">,</span> <span class="va">item</span>.<span class="at">value</span><span class="op">,</span> <span class="va">item</span>.<span class="at">maxAge</span>)</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="op">}</span>)</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="op">}</span></a></code></pre></div>
<h2 id="methods">Methods</h2>
<ul>
<li><p><code>get(key, cb)</code> If the key is in the cache, then calls <code>cb(null, cached)</code> on nextTick. Otherwise, calls the <code>load</code> function that was supplied in the options object. If it doesn’t return an error, then cache the result. Multiple <code>get</code> calls with the same key will only ever have a single <code>load</code> call at the same time.</p></li>
<li><p><code>set(key, val, maxAge)</code> Seed the cache. This doesn’t have to be done, but can be convenient if you know that something will be fetched soon. <code>maxAge</code> is optional - it is passed to internal LRU cache</p></li>
<li><p><code>reset()</code> Drop all the items in the cache.</p></li>
</ul>
</body>
</html>
