<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="extension-pipelining">Extension pipelining</h1>
<p><code>websocket-extensions</code> models the extension negotiation and processing pipeline of the WebSocket protocol. Between the driver parsing messages from the TCP stream and handing those messages off to the application, there may exist a stack of extensions that transform the message somehow.</p>
<p>In the parlance of this framework, a <em>session</em> refers to a single instance of an extension, acting on a particular socket on either the server or the client side. A session may transform messages both incoming to the application and outgoing from the application, for example the <code>permessage-deflate</code> extension compresses outgoing messages and decompresses incoming messages. Message streams in either direction are independent; that is, incoming and outgoing messages cannot be assumed to ‘pair up’ as in a request-response protocol.</p>
<p>Asynchronous processing of messages poses a number of problems that this pipeline construction is intended to solve.</p>
<h2 id="overview">Overview</h2>
<p>Logically, we have the following:</p>
<pre><code>+-------------+  out  +---+     +---+     +---+       +--------+
|             |------&gt;|   |----&gt;|   |----&gt;|   |------&gt;|        |
| Application |       | A |     | B |     | C |       | Driver |
|             |&lt;------|   |&lt;----|   |&lt;----|   |&lt;------|        |
+-------------+  in   +---+     +---+     +---+       +--------+

                      \                       /
                       +----------o----------+
                                  |
                               sessions</code></pre>
<p>For outgoing messages, the driver receives the result of</p>
<pre><code>    C.outgoing(B.outgoing(A.outgoing(message)))

or, [A, B, C].reduce(((m, ext) =&gt; ext.outgoing(m)), message)</code></pre>
<p>For incoming messages, the application receives the result of</p>
<pre><code>    A.incoming(B.incoming(C.incoming(message)))

or, [C, B, A].reduce(((m, ext) =&gt; ext.incoming(m)), message)</code></pre>
<p>A session is of the following type, to borrow notation from pseudo-Haskell:</p>
<pre><code>type Session = {
  incoming :: Message -&gt; Message
  outgoing :: Message -&gt; Message
  close    :: () -&gt; ()
}</code></pre>
<p>(That <code>() -&gt; ()</code> syntax is intended to mean that <code>close()</code> is a nullary void method; I apologise to any Haskell readers for not using the right monad.)</p>
<p>The <code>incoming()</code> and <code>outgoing()</code> methods perform message transformation in the respective directions; <code>close()</code> is called when a socket closes so the session can release any resources it’s holding, for example a DEFLATE de/compression context.</p>
<p>However because this is JavaScript, the <code>incoming()</code> and <code>outgoing()</code> methods may be asynchronous (indeed, <code>permessage-deflate</code> is based on <code>zlib</code>, whose API is stream-based). So their interface is strictly:</p>
<pre><code>type Session = {
  incoming :: Message -&gt; Callback -&gt; ()
  outgoing :: Message -&gt; Callback -&gt; ()
  close    :: () -&gt; ()
}

type Callback = Either Error Message -&gt; ()</code></pre>
<p>This means a message <em>m2</em> can be pushed into a session while it’s still processing the preceding message <em>m1</em>. The messages can be processed concurrently but they <em>must</em> be given to the next session in line (or to the application) in the same order they came in. Applications will expect to receive messages in the order they arrived over the wire, and sessions require this too. So ordering of messages must be preserved throughout the pipeline.</p>
<p>Consider the following highly simplified extension that deflates messages on the wire. <code>message</code> is a value conforming the type:</p>
<pre><code>type Message = {
  rsv1   :: Boolean
  rsv2   :: Boolean
  rsv3   :: Boolean
  opcode :: Number
  data   :: Buffer
}</code></pre>
<p>Here’s the extension:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">var</span> zlib <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;zlib&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">var</span> deflate <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="dt">outgoing</span><span class="op">:</span> <span class="kw">function</span>(message<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="va">zlib</span>.<span class="at">deflateRaw</span>(<span class="va">message</span>.<span class="at">data</span><span class="op">,</span> <span class="kw">function</span>(error<span class="op">,</span> result) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-6" title="6">      <span class="va">message</span>.<span class="at">rsv1</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-7" title="7">      <span class="va">message</span>.<span class="at">data</span> <span class="op">=</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb7-8" title="8">      <span class="at">callback</span>(error<span class="op">,</span> message)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="op">},</span></a>
<a class="sourceLine" id="cb7-11" title="11"></a>
<a class="sourceLine" id="cb7-12" title="12">  <span class="dt">incoming</span><span class="op">:</span> <span class="kw">function</span>(message<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-13" title="13">    <span class="co">// decompress inbound messages (elided)</span></a>
<a class="sourceLine" id="cb7-14" title="14">  <span class="op">},</span></a>
<a class="sourceLine" id="cb7-15" title="15"></a>
<a class="sourceLine" id="cb7-16" title="16">  <span class="dt">close</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb7-17" title="17">    <span class="co">// no state to clean up</span></a>
<a class="sourceLine" id="cb7-18" title="18">  <span class="op">}</span></a>
<a class="sourceLine" id="cb7-19" title="19"><span class="op">};</span></a></code></pre></div>
<p>We can call it with a large message followed by a small one, and the small one will be returned first:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">var</span> crypto <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;crypto&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb8-2" title="2">    large  <span class="op">=</span> <span class="va">crypto</span>.<span class="at">randomBytes</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="dv">14</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb8-3" title="3">    small  <span class="op">=</span> <span class="kw">new</span> <span class="at">Buffer</span>(<span class="st">&#39;hi&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4"></a>
<a class="sourceLine" id="cb8-5" title="5"><span class="va">deflate</span>.<span class="at">outgoing</span>(<span class="op">{</span> <span class="dt">data</span><span class="op">:</span> large <span class="op">},</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="va">console</span>.<span class="at">log</span>(<span class="dv">1</span><span class="op">,</span> <span class="st">&#39;large&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-8" title="8"></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="va">deflate</span>.<span class="at">outgoing</span>(<span class="op">{</span> <span class="dt">data</span><span class="op">:</span> small <span class="op">},</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb8-10" title="10">  <span class="va">console</span>.<span class="at">log</span>(<span class="dv">2</span><span class="op">,</span> <span class="st">&#39;small&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-12" title="12"></a>
<a class="sourceLine" id="cb8-13" title="13"><span class="co">/* prints:  2 &#39;small&#39;</span></a>
<a class="sourceLine" id="cb8-14" title="14"><span class="co">            1 &#39;large&#39; */</span></a></code></pre></div>
<p>So a session that processes messages asynchronously may fail to preserve message ordering.</p>
<p>Now, this extension is stateless, so it can process messages in any order and still produce the same output. But some extensions are stateful and require message order to be preserved.</p>
<p>For example, when using <code>permessage-deflate</code> without <code>no_context_takeover</code> set, the session retains a DEFLATE de/compression context between messages, which accumulates state as it consumes data (later messages can refer to sections of previous ones to improve compression). Reordering parts of the DEFLATE stream will result in a failed decompression. Messages must be decompressed in the same order they were compressed by the peer in order for the DEFLATE protocol to work.</p>
<p>Finally, there is the problem of closing a socket. When a WebSocket is closed by the application, or receives a closing request from the other peer, there may be messages outgoing from the application and incoming from the peer in the pipeline. If we close the socket and pipeline immediately, two problems arise:</p>
<ul>
<li>We may send our own closing frame to the peer before all prior messages we sent have been written to the socket, and before we have finished processing all prior messages from the peer</li>
<li>The session may be instructed to close its resources (e.g. its de/compression context) while it’s in the middle of processing a message, or before it has received messages that are upstream of it in the pipeline</li>
</ul>
<p>Essentially, we must defer closing the sessions and sending a closing frame until after all prior messages have exited the pipeline.</p>
<h2 id="design-goals">Design goals</h2>
<ul>
<li>Message order must be preserved between the protocol driver, the extension sessions, and the application</li>
<li>Messages should be handed off to sessions and endpoints as soon as possible, to maximise throughput of stateless sessions</li>
<li>The closing procedure should block any further messages from entering the pipeline, and should allow all existing messages to drain</li>
<li>Sessions should be closed as soon as possible to prevent them holding memory and other resources when they have no more messages to handle</li>
<li>The closing API should allow the caller to detect when the pipeline is empty and it is safe to continue the WebSocket closing procedure</li>
<li>Individual extensions should remain as simple as possible to facilitate modularity and independent authorship</li>
</ul>
<p>The final point about modularity is an important one: this framework is designed to facilitate extensions existing as plugins, by decoupling the protocol driver, extensions, and application. In an ideal world, plugins should only need to contain code for their specific functionality, and not solve these problems that apply to all sessions. Also, solving some of these problems requires consideration of all active sessions collectively, which an individual session is incapable of doing.</p>
<p>For example, it is entirely possible to take the simple <code>deflate</code> extension above and wrap its <code>incoming()</code> and <code>outgoing()</code> methods in two <code>Transform</code> streams, producing this type:</p>
<pre><code>type Session = {
  incoming :: TransformStream
  outtoing :: TransformStream
  close    :: () -&gt; ()
}</code></pre>
<p>The <code>Transform</code> class makes it easy to wrap an async function such that message order is preserved:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">var</span> stream  <span class="op">=</span> <span class="at">require</span>(<span class="st">&#39;stream&#39;</span>)<span class="op">,</span></a>
<a class="sourceLine" id="cb10-2" title="2">    session <span class="op">=</span> <span class="kw">new</span> <span class="va">stream</span>.<span class="at">Transform</span>(<span class="op">{</span> <span class="dt">objectMode</span><span class="op">:</span> <span class="kw">true</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-3" title="3"></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="va">session</span>.<span class="at">_transform</span> <span class="op">=</span> <span class="kw">function</span>(message<span class="op">,</span> _<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="kw">var</span> self <span class="op">=</span> <span class="kw">this</span><span class="op">;</span></a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="va">deflate</span>.<span class="at">outgoing</span>(message<span class="op">,</span> <span class="kw">function</span>(error<span class="op">,</span> result) <span class="op">{</span></a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="va">self</span>.<span class="at">push</span>(result)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="at">callback</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb10-9" title="9">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="op">};</span></a></code></pre></div>
<p>However, this has a negative impact on throughput: it works by deferring <code>callback()</code> until the async function has ‘returned’, which blocks <code>Transform</code> from passing further input into the <code>_transform()</code> method until the current message is dealt with completely. This would prevent sessions from processing messages concurrently, and would unnecessarily reduce the throughput of stateless extensions.</p>
<p>So, input should be handed off to sessions as soon as possible, and all we need is a mechanism to reorder the output so that message order is preserved for the next session in line.</p>
<h2 id="solution">Solution</h2>
<p>We now describe the model implemented here and how it meets the above design goals. The above diagram where a stack of extensions sit between the driver and application describes the data flow, but not the object graph. That looks like this:</p>
<pre><code>        +--------+
        | Driver |
        +---o----+
            |
            V
      +------------+      +----------+
      | Extensions o-----&gt;| Pipeline |
      +------------+      +-----o----+
                                |
                +---------------+---------------+
                |               |               |
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+</code></pre>
<p>A driver using this framework holds an instance of the <code>Extensions</code> class, which it uses to register extension plugins, negotiate headers and transform messages. The <code>Extensions</code> instance itself holds a <code>Pipeline</code>, which contains an array of <code>Cell</code> objects, each of which wraps one of the sessions.</p>
<h3 id="message-processing">Message processing</h3>
<p>Both the <code>Pipeline</code> and <code>Cell</code> classes have <code>incoming()</code> and <code>outgoing()</code> methods; the <code>Pipeline</code> interface pushes messages into the pipe, delegates the message to each <code>Cell</code> in turn, then returns it back to the driver. Outgoing messages pass through <code>A</code> then <code>B</code> then <code>C</code>, and incoming messages in the reverse order.</p>
<p>Internally, a <code>Cell</code> contains two <code>Functor</code> objects. A <code>Functor</code> wraps an async function and makes sure its output messages maintain the order of its input messages. This name is due to <span class="citation" data-cites="fronx">[@fronx]</span>(https://github.com/fronx), on the basis that, by preserving message order, the abstraction preserves the <em>mapping</em> between input and output messages. To use our simple <code>deflate</code> extension from above:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">var</span> functor <span class="op">=</span> <span class="kw">new</span> <span class="at">Functor</span>(deflate<span class="op">,</span> <span class="st">&#39;outgoing&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-2" title="2"></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="va">functor</span>.<span class="at">call</span>(<span class="op">{</span> <span class="dt">data</span><span class="op">:</span> large <span class="op">},</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(<span class="dv">1</span><span class="op">,</span> <span class="st">&#39;large&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="va">functor</span>.<span class="at">call</span>(<span class="op">{</span> <span class="dt">data</span><span class="op">:</span> small <span class="op">},</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb12-8" title="8">  <span class="va">console</span>.<span class="at">log</span>(<span class="dv">2</span><span class="op">,</span> <span class="st">&#39;small&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-10" title="10"></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="co">/*  -&gt;  1 &#39;large&#39;</span></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="co">        2 &#39;small&#39; */</span></a></code></pre></div>
<p>A <code>Cell</code> contains two of these, one for each direction:</p>
<pre><code>                        +-----------------------+
                  +----&gt;| Functor [A, incoming] |
+----------+      |     +-----------------------+
| Cell [A] o------+
+----------+      |     +-----------------------+
                  +----&gt;| Functor [A, outgoing] |
                        +-----------------------+</code></pre>
<p>This satisfies the message transformation requirements: the <code>Pipeline</code> simply loops over the cells in the appropriate direction to transform each message. Because each <code>Cell</code> will preserve message order, we can pass a message to the next <code>Cell</code> in line as soon as the current <code>Cell</code> returns it. This gives each <code>Cell</code> all the messages in order while maximising throughput.</p>
<h3 id="session-closing">Session closing</h3>
<p>We want to close each session as soon as possible, after all existing messages have drained. To do this, each <code>Cell</code> begins with a pending message counter in each direction, labelled <code>in</code> and <code>out</code> below.</p>
<pre><code>                          +----------+
                          | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
                |               |               |
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 0          out: 0          out: 0</code></pre>
<p>When a message <em>m1</em> enters the pipeline, say in the <code>outgoing</code> direction, we increment the <code>pending.out</code> counter on all cells immediately.</p>
<pre><code>                          +----------+
                    m1 =&gt; | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
                |               |               |
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 1          out: 1          out: 1</code></pre>
<p><em>m1</em> is handed off to <code>A</code>, meanwhile a second message <code>m2</code> arrives in the same direction. All <code>pending.out</code> counters are again incremented.</p>
<pre><code>                          +----------+
                    m2 =&gt; | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
            m1  |               |               |
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 2          out: 2          out: 2</code></pre>
<p>When the first cell’s <code>A.outgoing</code> functor finishes processing <em>m1</em>, the first <code>pending.out</code> counter is decremented and <em>m1</em> is handed off to cell <code>B</code>.</p>
<pre><code>                          +----------+
                          | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
            m2  |           m1  |               |
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 1          out: 2          out: 2</code></pre>
<p>As <code>B</code> finishes with <em>m1</em>, and as <code>A</code> finishes with <em>m2</em>, the <code>pending.out</code> counters continue to decrement.</p>
<pre><code>                          +----------+
                          | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
                |           m2  |           m1  |
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 0          out: 1          out: 2</code></pre>
<p>Say <code>C</code> is a little slow, and begins processing <em>m2</em> while still processing <em>m1</em>. That’s fine, the <code>Functor</code> mechanism will keep <em>m1</em> ahead of <em>m2</em> in the output.</p>
<pre><code>                          +----------+
                          | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
                |               |           m2  | m1
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 0          out: 0          out: 2</code></pre>
<p>Once all messages are dealt with, the counters return to <code>0</code>.</p>
<pre><code>                          +----------+
                          | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
                |               |               |
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 0          out: 0          out: 0</code></pre>
<p>The same process applies in the <code>incoming</code> direction, the only difference being that messages are passed to <code>C</code> first.</p>
<p>This makes closing the sessions quite simple. When the driver wants to close the socket, it calls <code>Pipeline.close()</code>. This <em>immediately</em> calls <code>close()</code> on all the cells. If a cell has <code>in == out == 0</code>, then it immediately calls <code>session.close()</code>. Otherwise, it stores the closing call and defers it until <code>in</code> and <code>out</code> have both ticked down to zero. The pipeline will not accept new messages after <code>close()</code> has been called, so we know the pending counts will not increase after this point.</p>
<p>This means each session is closed as soon as possible: <code>A</code> can close while the slow <code>C</code> session is still working, because it knows there are no more messages on the way. Similarly, <code>C</code> will defer closing if <code>close()</code> is called while <em>m1</em> is still in <code>B</code>, and <em>m2</em> in <code>A</code>, because its pending count means it knows it has work yet to do, even if it’s not received those messages yet. This concern cannot be addressed by extensions acting only on their own local state, unless we pollute individual extensions by making them all implement this same mechanism.</p>
<p>The actual closing API at each level is slightly different:</p>
<pre><code>type Session = {
  close :: () -&gt; ()
}

type Cell = {
  close :: () -&gt; Promise ()
}

type Pipeline = {
  close :: Callback -&gt; ()
}</code></pre>
<p>This might appear inconsistent so it’s worth explaining. Remember that a <code>Pipeline</code> holds a list of <code>Cell</code> objects, each wrapping a <code>Session</code>. The driver talks (via the <code>Extensions</code> API) to the <code>Pipeline</code> interface, and it wants <code>Pipeline.close()</code> to do two things: close all the sessions, and tell me when it’s safe to start the closing procedure (i.e. when all messages have drained from the pipe and been handed off to the application or socket). A callback API works well for that.</p>
<p>At the other end of the stack, <code>Session.close()</code> is a nullary void method with no callback or promise API because we don’t care what it does, and whatever it does do will not block the WebSocket protocol; we’re not going to hold off processing messages while a session closes its de/compression context. We just tell it to close itself, and don’t want to wait while it does that.</p>
<p>In the middle, <code>Cell.close()</code> returns a promise rather than using a callback. This is for two reasons. First, <code>Cell.close()</code> might not do anything immediately, it might have to defer its effect while messages drain. So, if given a callback, it would have to store it in a queue for later execution. Callbacks work fine if your method does something and can then invoke the callback itself, but if you need to store callbacks somewhere so another method can execute them, a promise is a better fit. Second, it better serves the purposes of <code>Pipeline.close()</code>: it wants to call <code>close()</code> on each of a list of cells, and wait for all of them to finish. This is simple and idiomatic using promises:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">var</span> closed <span class="op">=</span> <span class="va">cells</span>.<span class="at">map</span>((cell) <span class="kw">=&gt;</span> <span class="va">cell</span>.<span class="at">close</span>())<span class="op">;</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="va">Promise</span>.<span class="at">all</span>(closed).<span class="at">then</span>(callback)<span class="op">;</span></a></code></pre></div>
<p>(We don’t actually use a full <em>Promises/A+</em> compatible promise here, we use a much simplified construction that acts as a callback aggregater and resolves synchronously and does not support chaining, but the principle is the same.)</p>
<h3 id="error-handling">Error handling</h3>
<p>We’ve not mentioned error handling so far but it bears some explanation. The above counter system still applies, but behaves slightly differently in the presence of errors.</p>
<p>Say we push three messages into the pipe in the outgoing direction:</p>
<pre><code>                          +----------+
            m3, m2, m1 =&gt; | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
                |               |               |
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 3          out: 3          out: 3</code></pre>
<p>They pass through the cells successfully up to this point:</p>
<pre><code>                          +----------+
                          | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
            m3  |           m2  |           m1  |
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 1          out: 2          out: 3</code></pre>
<p>At this point, session <code>B</code> produces an error while processing <em>m2</em>, that is <em>m2</em> becomes <em>e2</em>. <em>m1</em> is still in the pipeline, and <em>m3</em> is queued behind <em>m2</em>. What ought to happen is that <em>m1</em> is handed off to the socket, then <em>m2</em> is released to the driver, which will detect the error and begin closing the socket. No further processing should be done on <em>m3</em> and it should not be released to the driver after the error is emitted.</p>
<p>To handle this, we allow errors to pass down the pipeline just like messages do, to maintain ordering. But, once a cell sees its session produce an error, or it receives an error from upstream, it should refuse to accept any further messages. Session <code>B</code> might have begun processing <em>m3</em> by the time it produces the error <em>e2</em>, but <code>C</code> will have been given <em>e2</em> before it receives <em>m3</em>, and can simply drop <em>m3</em>.</p>
<p>Now, say <em>e2</em> reaches the slow session <code>C</code> while <em>m1</em> is still present, meanwhile <em>m3</em> has been dropped. <code>C</code> will never receive <em>m3</em> since it will have been dropped upstream. Under the present model, its <code>out</code> counter will be <code>3</code> but it is only going to emit two more values: <em>m1</em> and <em>e2</em>. In order for closing to work, we need to decrement <code>out</code> to reflect this. The situation should look like this:</p>
<pre><code>                          +----------+
                          | Pipeline |
                          +-----o----+
                                |
                +---------------+---------------+
                |               |           e2  | m1
          +-----o----+    +-----o----+    +-----o----+
          | Cell [A] |    | Cell [B] |    | Cell [C] |
          +----------+    +----------+    +----------+
             in: 0           in: 0           in: 0
            out: 0          out: 0          out: 2</code></pre>
<p>When a cell sees its session emit an error, or when it receives an error from upstream, it sets its pending count in the appropriate direction to equal the number of messages it is <em>currently</em> processing. It will not accept any messages after it sees the error, so this will allow the counter to reach zero.</p>
<p>Note that while <em>e2</em> is in the pipeline, <code>Pipeline</code> should drop any further messages in the outgoing direction, but should continue to accept incoming messages. Until <em>e2</em> makes it out of the pipe to the driver, behind previous successful messages, the driver does not know an error has happened, and a message may arrive over the socket and make it all the way through the incoming pipe in the meantime. We only halt processing in the affected direction to avoid doing unnecessary work since messages arriving after an error should not be processed.</p>
<p>Some unnecessary work may happen, for example any messages already in the pipeline following <em>m2</em> will be processed by <code>A</code>, since it’s upstream of the error. Those messages will be dropped by <code>B</code>.</p>
<h2 id="alternative-ideas">Alternative ideas</h2>
<p>I am considering implementing <code>Functor</code> as an object-mode transform stream rather than what is essentially an async function. Being object-mode, a stream would preserve message boundaries and would also possibly help address back-pressure. I’m not sure whether this would require external API changes so that such streams could be connected to the downstream driver’s streams.</p>
<h2 id="acknowledgements">Acknowledgements</h2>
<p>Credit is due to <span class="citation" data-cites="mnowster">[@mnowster]</span>(https://github.com/mnowster) for helping with the design and to <span class="citation" data-cites="fronx">[@fronx]</span>(https://github.com/fronx) for helping name things.</p>
</body>
</html>
