![Node.js CI](https://github.com/Borewit/strtok3/workflows/Node.js%20CI/badge.svg) [![NPM version](https://badge.fury.io/js/strtok3.svg)](https://npmjs.org/package/strtok3) [![npm downloads](http://img.shields.io/npm/dm/strtok3.svg)](https://npmcharts.com/compare/strtok3,token-types?start=1200&interval=30) [![Dependabot Status](https://api.dependabot.com/badges/status?host=github&repo=Borewit/music-metadata)](https://dependabot.com)[![Coverage status](https://coveralls.io/repos/github/Borewit/strtok3/badge.svg?branch=master)](https://coveralls.io/github/Borewit/strtok3?branch=master) [![DeepScan grade](https://deepscan.io/api/teams/5165/projects/8526/branches/103329/badge/grade.svg)](https://deepscan.io/dashboard#view=project&tid=5165&pid=8526&bid=103329) [![Known Vulnerabilities](https://snyk.io/test/github/Borewit/strtok3/badge.svg?targetFile=package.json)](https://snyk.io/test/github/Borewit/strtok3?targetFile=package.json) [![Total alerts](https://img.shields.io/lgtm/alerts/g/Borewit/strtok3.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/Borewit/strtok3/alerts/) [![Codacy Badge](https://api.codacy.com/project/badge/Grade/59dd6795e61949fb97066ca52e6097ef)](https://www.codacy.com/app/Borewit/strtok3?utm_source=github.com&utm_medium=referral&utm_content=Borewit/strtok3&utm_campaign=Badge_Grade) [![Language grade: JavaScript](https://img.shields.io/lgtm/grade/javascript/g/Borewit/strtok3.svg?logo=lgtm&logoWidth=18)](https://lgtm.com/projects/g/Borewit/strtok3/context:javascript) \# strtok3

A promise based streaming [*tokenizer*](#tokenizer) for [Node.js](http://nodejs.org) and browsers. This node module is a successor of [strtok2](https://github.com/Borewit/strtok2).

The `strtok3` contains a few methods to turn different input into a [*tokenizer*](#tokenizer). Designed to \* Support a streaming environment \* Decoding of binary data, strings and numbers in mind \* Read [predefined](https://github.com/Borewit/token-types) or custom tokens. \* Optimized [*tokenizers*](#tokenizer) for reading from [file](#method-strtok3fromfile), [stream](#method-strtok3fromstream) or [buffer](#method-strtok3frombuffer).

It can read from: \* A file (taking a file path as an input) \* A Node.js [stream](https://nodejs.org/api/stream.html). \* A [Buffer](https://nodejs.org/api/buffer.html) \* HTTP chunked transfer provided by <span class="citation" data-cites="tokenizer/http">\[@tokenizer/http\]</span>(https://github.com/Borewit/tokenizer-http). \* Chunked [Amazon S3](https://aws.amazon.com/s3) access provided by <span class="citation" data-cites="tokenizer/s3">\[@tokenizer/s3\]</span>(https://github.com/Borewit/tokenizer-s3).

Installation
------------

    npm install strtok3

API
---

Use one of the methods to instantiate an [*abstract tokenizer*](#tokenizer): \* [strtok3.fromFile](#method-strtok3fromfile) \* [strtok3.fromStream](#method-strtok3fromstream) \* [strtok3.fromBuffer](#method-strtok3frombuffer)

### strtok3 methods

All of the strtok3 methods return a [*tokenizer*](#tokenizer), either directly or via a promise.

#### Method `strtok3.fromFile()`

<table><thead><tr class="header"><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>path</td><td>Path to file (string)</td><td>Path to file to read from</td></tr></tbody></table>

Note that [file-information](#file-information) is automatically added.

Returns, via a promise, a [*tokenizer*](#tokenizer) which can be used to parse a file.

    const strtok3 = require('strtok3');
    const Token = require('token-types');
        
    (async () => {

      const tokenizer = await strtok3.fromFile("somefile.bin");
             try {
        const myNumber = await tokenizer.readToken(Token.UINT8);
        console.log(`My number: ${myNumber}`);
      } finally {
        tokenizer.close(); // Close the file
      } 
    })();

#### Method `strtok3.fromStream()`

Create [*tokenizer*](#tokenizer) from a node.js [readable stream](https://nodejs.org/api/stream.html#stream_class_stream_readable).

<table><thead><tr class="header"><th>Parameter</th><th>Optional</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>stream</td><td>no</td><td><a href="https://nodejs.org/api/stream.html#stream_class_stream_readable">Readable</a></td><td>Stream to read from</td></tr><tr class="even"><td>fileInfo</td><td>yes</td><td><a href="#IFileInfo">IFileInfo</a></td><td>Provide file information</td></tr></tbody></table>

Returns a [*tokenizer*](#tokenizer), via a Promise, which can be used to parse a buffer.

    const strtok3 = require('strtok3');
    const Token = require('token-types');

    strtok3.fromStream(stream).then(tokenizer => {
      return tokenizer.readToken(Token.UINT8).then(myUint8Number => {
        console.log(`My number: ${myUint8Number}`);
      });
    });

#### Method `strtok3.fromBuffer()`

<table><thead><tr class="header"><th>Parameter</th><th>Optional</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>buffer</td><td>no</td><td><a href="https://nodejs.org/api/buffer.html">Buffer</a></td><td>Buffer to read from</td></tr><tr class="even"><td>fileInfo</td><td>yes</td><td><a href="#IFileInfo">IFileInfo</a></td><td>Provide file information</td></tr></tbody></table>

Returns a [*tokenizer*](#tokenizer) which can be used to parse the provided buffer.

    const strtok3 = require('strtok3');
        
    const tokenizer = strtok3.fromBuffer(buffer);

    tokenizer.readToken(Token.UINT8).then(myUint8Number => {
      console.log(`My number: ${myUint8Number}`);
    });

Tokenizer
---------

The tokenizer allows us to *read* or *peek* from the *tokenizer-stream*. The *tokenizer-stream* is an abstraction of a [stream](https://nodejs.org/api/stream.html), file or [Buffer](https://nodejs.org/api/buffer.html). It can also be translated in chunked reads, as done in <span class="citation" data-cites="tokenizer/http">\[@tokenizer/http\]</span>(https://github.com/Borewit/tokenizer-http);

What is the difference with Nodejs.js stream? \* The *tokenizer-stream* supports jumping / seeking in a the *tokenizer-stream* using [`tokenizer.ignore()`](#method-tokenizerignore) \* In addition to *read* methods, it has *peek* methods, to read a ahead and check what is coming.

The [tokenizer.position](#attribute-tokenizerposition) keeps tracks of the read position.

### strtok3 attributes

#### Attribute `tokenizer.fileInfo`

Optional attribute describing the file information, see [IFileInfo](#IFileInfo)

#### Attribute `tokenizer.position`

Pointer to the current position in the [*tokenizer*](#tokenizer) stream. If a *position* is provided to a *read* or *peek* method, is should be, at least, equal or greater than this value.

### Tokenizer methods

There are to groups of methods

-   *read* methods: used to read a *token* of [Buffer](https://nodejs.org/api/buffer.html) from the [*tokenizer*](#tokenizer). The position of the *tokenizer-stream* will advance with the size of the token.
-   *peek* methods: same as the read, but it will *not* advance the pointer. It allows to read (peek) ahead.

#### Method `tokenizer.readBuffer()`

Read buffer from stream. `readBuffer(buffer, options?)`

<table style="width:98%;"><colgroup><col style="width: 3%" /><col style="width: 20%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>buffer</td><td><a href="https://nodejs.org/api/buffer.html">Buffer</a> | Uint8Array</td><td>Target buffer to write the data read to</td></tr><tr class="even"><td>options</td><td><a href="#ireadchunkoptions">IReadChunkOptions</a></td><td>An integer specifying the number of bytes to read</td></tr></tbody></table>

Return value `Promise<number>` Promise with number of bytes read. The number of bytes read maybe if less, *mayBeLess* flag was set.

#### Method `tokenizer.peekBuffer()`

Peek (read ahead) buffer from [*tokenizer*](#tokenizer) `peekBuffer(buffer,  options?)`

<table style="width:99%;"><colgroup><col style="width: 11%" /><col style="width: 38%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>buffer</td><td>Buffer | Uint8Array</td><td>Target buffer to write the data read (peeked) to.</td></tr><tr class="even"><td>options</td><td><a href="#ireadchunkoptions">IReadChunkOptions</a></td><td>An integer specifying the number of bytes to read.</td></tr></tbody></table>

Return value `Promise<number>` Promise with number of bytes read. The number of bytes read maybe if less, *mayBeLess* flag was set.

#### Method `tokenizer.readToken()`

Read a *token* from the tokenizer-stream. `readToken(token, position?)`

<table style="width:99%;"><colgroup><col style="width: 7%" /><col style="width: 16%" /><col style="width: 76%" /></colgroup><thead><tr class="header"><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>token</td><td><a href="#IGetToken">IGetToken</a></td><td>Token to read from the tokenizer-stream.</td></tr><tr class="even"><td>position?</td><td>number</td><td>Offset where to begin reading within the file. If position is null, data will be read from the current file position.</td></tr></tbody></table>

Return value `Promise<number>`. Promise with number of bytes read. The number of bytes read maybe if less, *mayBeLess* flag was set.

#### Method `tokenizer.peekToken()`

Peek a *token* from the [*tokenizer*](#tokenizer). `peekToken(token, position?)`

<table style="width:99%;"><colgroup><col style="width: 7%" /><col style="width: 17%" /><col style="width: 75%" /></colgroup><thead><tr class="header"><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>token</td><td><a href="#IGetToken">IGetToken</a></td><td>Token to read from the tokenizer-stream.</td></tr><tr class="even"><td>position?</td><td>number</td><td>Offset where to begin reading within the file. If position is null, data will be read from the current file position.</td></tr></tbody></table>

Return value `Promise<T>` Promise with token value peeked from the [*tokenizer*](#tokenizer).

#### Method `tokenizer.readNumber()`

Peek a numeric [*token*](#token) from the [*tokenizer*](#tokenizer). `readNumber(token)`

<table><thead><tr class="header"><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>token</td><td><a href="#IGetToken">IGetToken</a></td><td>Numeric token to read from the tokenizer-stream.</td></tr></tbody></table>

Return value `Promise<number>` Promise with number peeked from the *tokenizer-stream*.

#### Method `tokenizer.ignore()`

Peek a numeric [*token*](#token) from the tokenizer-stream. `ignore(length)`

<table style="width:98%;"><colgroup><col style="width: 13%" /><col style="width: 8%" /><col style="width: 77%" /></colgroup><thead><tr class="header"><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>ignore</td><td>number</td><td>Numeric of bytes to ignore. Will advance the <code>tokenizer.position</code></td></tr></tbody></table>

Return value `Promise<number>` Promise with number peeked from the *tokenizer-stream*.

#### Method `tokenizer.close()`

Clean up resources, such as closing a file pointer if applicable.

### IReadChunkOptions

Each attribute is optional:

<table style="width:98%;"><colgroup><col style="width: 4%" /><col style="width: 3%" /><col style="width: 91%" /></colgroup><thead><tr class="header"><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>offset</td><td>number</td><td>The offset in the buffer to start writing at; if not provided, start at 0</td></tr><tr class="even"><td>length</td><td>number</td><td>Requested number of bytes to read.</td></tr><tr class="odd"><td>position</td><td>number</td><td>Position where to peek from the file. If position is null, data will be read from the <a href="#attribute-tokenizerposition">current file position</a>. Position may not be less then <a href="#attribute-tokenizerposition">tokenizer.position</a></td></tr><tr class="even"><td>mayBeLess</td><td>boolean</td><td>If and only if set, will not throw an EOF error if less then the requested <em>mayBeLess</em> could be read.</td></tr></tbody></table>

Example:

      tokenizer.peekBuffer(buffer, {mayBeLess: true});

IFileInfo
---------

File information interface which describes the underlying file, each attribute is optional.

<table><thead><tr class="header"><th>Attribute</th><th>Type</th><th>Description</th></tr></thead><tbody><tr class="odd"><td>size</td><td>number</td><td>File size in bytes</td></tr><tr class="even"><td>mimeType</td><td>number</td><td><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME-type</a> of file.</td></tr><tr class="odd"><td>path</td><td>number</td><td>File path</td></tr><tr class="even"><td>url</td><td>boolean</td><td>File URL</td></tr></tbody></table>

Token
-----

The *token* is basically a description what to read form the [*tokenizer-stream*](#tokenizer). A basic set of *token types* can be found here: [*token-types*](https://github.com/Borewit/token-types).

A token is something which implements the following interface:

    export interface IGetToken<T> {

      /**
       * Length in bytes of encoded value
       */
      len: number;

      /**
       * Decode value from buffer at offset
       * @param buf Buffer to read the decoded value from
       * @param off Decode offset
       */
      get(buf: Buffer, off: number): T;
    }

The *tokenizer* reads `token.len` bytes from the *tokenizer-stream* into a Buffer. The `token.get` will be called with the Buffer. `token.get` is responsible for conversion from the buffer to the desired output type.

Browser compatibility
---------------------

To exclude fs based dependencies, you can use a submodule-import from ‘strtok3/lib/core’.

<table><thead><tr class="header"><th>function</th><th>‘strtok3’</th><th>‘strtok3/lib/core’</th></tr></thead><tbody><tr class="odd"><td><code>parseBuffer</code></td><td>✓</td><td>✓</td></tr><tr class="even"><td><code>parseStream</code></td><td>✓</td><td>✓</td></tr><tr class="odd"><td><code>fromFile</code></td><td>✓</td><td></td></tr></tbody></table>

### Working with Web-API readable stream

To convert a [Web-API readable stream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStreamDefaultReader) into a [Node.js readable stream]((https://nodejs.org/api/stream.html#stream_readable_streams)), you can use [readable-web-to-node-stream](https://github.com/Borewit/readable-web-to-node-stream) to convert one in another.

Example submodule-import:

    const strtok3core = require('strtok3/lib/core'); // Submodule-import to prevent Node.js specific dependencies
    const {ReadableWebToNodeStream} = require('readable-web-to-node-stream');

    (async () => {

      const response = await fetch(url);
      const readableWebStream = response.body; // Web-API readable stream
      const nodeStream = new ReadableWebToNodeStream(readableWebStream); // convert to Node.js readable stream
      
      const tokenizer = strtok3core.fromStream(nodeStream); // And we now have tokenizer in a web environment
    })();

Licence
-------

(The MIT License)

Copyright (c) 2020 Borewit

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the ‘Software’), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ‘AS IS’, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
