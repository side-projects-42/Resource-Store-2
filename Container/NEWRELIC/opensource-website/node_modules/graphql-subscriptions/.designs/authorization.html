<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>authorization</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h2 id="authorize-on-connect">Authorize on connect</h2>
<p>When client side creates the WebSocket instance and connects to the subscriptions server, it must provide the authorization token, but there are some issues with that:</p>
<ol type="1">
<li>It’s not possible to provide custom headers when creating WebSocket connection in browser.</li>
</ol>
<blockquote>
<p>related to https://github.com/apollostack/subscriptions-transport-ws/issues/50 , https://github.com/apollostack/subscriptions-transport-ws/pull/45</p>
</blockquote>
<p>A possible workaround is to send the auth token in the url as query parameter and parse in on sever side while doing the connection handshake</p>
<blockquote>
<p>(Note: graphql-subscription does not expose onConnection callback, only onSubscribe, which occur after the connection)</p>
</blockquote>
<ol start="2" type="1">
<li>You have to create the actual connection and then reject it in the server side if there is an error with the user’s authorization token. At the moment, graphql-subscription does not expose <code>unsubscribe</code> or <code>disconnect</code> feature for a connection (should be part of <code>onConnection</code>)</li>
</ol>
<blockquote>
<p>related to https://github.com/apollostack/subscriptions-transport-ws/issues/51 , https://github.com/apollostack/subscriptions-transport-ws/pull/17</p>
</blockquote>
<ol start="3" type="1">
<li>At the moment, the client side can provide the “context” object for the subscription (and not for the connection), which can contain his auth token.</li>
</ol>
<p>Another option is to send the auth token from the client side on a separate message (like, <code>ON_INIT</code>) before creating the subscriptions.</p>
<h2 id="authorization-lifecycle">Authorization Lifecycle</h2>
<p>Another issue is the lifecycle of the authorization token, there are some cases that needs a solution:</p>
<ol type="1">
<li><p>How to handle invalidation of the auth token? If the client side logout from the application, it’s the client side’s responsibility to disconnect the WebSocket.</p></li>
<li><p>How to handle expiration of token? At the moment, If the client side’s token no longer valid, it should logout the user and disconnect the token.</p></li>
</ol>
<h2 id="authorization-validation">Authorization Validation</h2>
<p>What is the server side’s responsibility when dealing with authorized WebSocket and subscriptions?</p>
<p>If the client side does not disconnects the WebSocket when needed (for example, on logout or on expiration), and the WebSocket remains open, the client side will receive the publications of it’s existing subscriptions. It’s not an option to validate the auth token on the server before each publication, for each user that subscribed.</p>
<h2 id="existing-websocket-authorization-solutions">Existing WebSocket Authorization Solutions</h2>
<ul>
<li>Socket.io-auth (https://github.com/facundoolano/socketio-auth )
<ul>
<li>Provides a similar flow to onConnection and onAuthorize with a token, the server can validate and authorize the connection only when the connection created.</li>
<li>The auth token send via a custom WebSocket message.</li>
<li>Features callbacks for <code>onAuthorize</code>, <code>onAuthorized</code>, <code>onReject</code>, <code>postAuthenticate</code>.</li>
</ul></li>
<li>Sockjs-node (https://github.com/sockjs/sockjs-node#authorisation )
<ul>
<li>Does not provide a built-in solution and suggest a self-implemented authorization.</li>
</ul></li>
<li>https://gist.github.com/subudeepak/9897212</li>
<li>https://auth0.com/blog/auth-with-socket-io/</li>
<li>https://auth0.com/blog/auth-with-socket-io/
<ul>
<li>Suggests using authorization on connection using url parameter with the auth token.</li>
</ul></li>
<li>Meteor/DDP
<ul>
<li>The DDP protocol itself has no concept of authentication. Authentication is done via normal method calls.</li>
<li>The Meteor DDP server implementation allows method calls to store state on the connection object representing the current user ID, which is accessible from other methods and publications. If the user ID ever changes, all publications are basically re-evaluated from scratch (inside the server). Nothing special is done on the server side to allow methods to notice if the user ID changes while they are running; however, methods run in series unless they explicitly ask to unblock the connection (and the client tries to not send login methods in parallel with other methods).</li>
<li>The Meteor Accounts package tracks DDP connections associated with resume tokens and disconnects them if the resume token associated with that connection is deleted from the database.</li>
<li>Personal opinion from <span class="citation" data-cites="glasser">@glasser</span>: having auth just be “another method” wasn’t the best idea. It works better if it’s an established-at-beginning-of-connection, disconnect-to-change thing. However, the general idea of having a way for changes to authn/authz to “rerun publishers” or “disconnect connections” is nice.</li>
</ul></li>
</ul>
<h2 id="implementation-possibility">Implementation possibility:</h2>
<ul>
<li>Client creates a networkInterface with WebSocket client, and provides the auth token using one of the following:
<ul>
<li>URL parameter with the auth token.</li>
<li>Custom object that will be translated into INIT_MESSAGE and will be sent after initial connection handshake.</li>
</ul></li>
<li>Server side “onConnection” fires and validate the token, if the token is invalid, it rejects the connection / disconnects the socket.</li>
</ul>
<h4 id="pros">Pros:</h4>
<ul>
<li>Simple to implement. * Server side - need to add “onConnection” callback with ability to reject the connection. * Client side - need to add ability to send custom object with the auth token (or take if from the requested URL).</li>
<li>Custom auth for each application.</li>
</ul>
<h4 id="cons">Cons:</h4>
<ul>
<li>Forces the client side to handle logout/expiration of the token</li>
<li>Server publications not validated.</li>
</ul>
</body>
</html>
