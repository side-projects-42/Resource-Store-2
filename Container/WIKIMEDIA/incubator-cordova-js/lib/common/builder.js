var utils = require("cordova/utils");

function each(objects, func, context) {
  for (var prop in objects) {
    if (objects.hasOwnProperty(prop)) {
      func.apply(context, [objects[prop], prop]);
    }
  }
}

function include(parent, objects, clobber, merge) {
  each(objects, function (obj, key) {
    try {
      var result = obj.path ? require(obj.path) : {};

      if (clobber) {
        // Clobber if it doesn't exist.
        if (typeof parent[key] === "undefined") {
          parent[key] = result;
        } else if (typeof obj.path !== "undefined") {
          // If merging, merge properties onto parent, otherwise, clobber.
          if (merge) {
            recursiveMerge(parent[key], result);
          } else {
            parent[key] = result;
          }
        }
        result = parent[key];
      } else {
        // Overwrite if not currently defined.
        if (typeof parent[key] == "undefined") {
          parent[key] = result;
        } else if (merge && typeof obj.path !== "undefined") {
          // If merging, merge parent onto result
          recursiveMerge(result, parent[key]);
          parent[key] = result;
        } else {
          // Set result to what already exists, so we can build children into it if they exist.
          result = parent[key];
        }
      }

      if (obj.children) {
        include(result, obj.children, clobber, merge);
      }
    } catch (e) {
      utils.alert(
        "Exception building cordova JS globals: " + e + ' for key "' + key + '"'
      );
    }
  });
}

/**
 * Merge properties from one object onto another recursively.  Properties from
 * the src object will overwrite existing target property.
 *
 * @param target Object to merge properties into.
 * @param src Object to merge properties from.
 */
function recursiveMerge(target, src) {
  for (var prop in src) {
    if (src.hasOwnProperty(prop)) {
      if (
        typeof target.prototype !== "undefined" &&
        target.prototype.constructor === target
      ) {
        // If the target object is a constructor override off prototype.
        target.prototype[prop] = src[prop];
      } else {
        target[prop] =
          typeof src[prop] === "object"
            ? recursiveMerge(target[prop], src[prop])
            : src[prop];
      }
    }
  }
  return target;
}

module.exports = {
  build: function (objects) {
    return {
      intoButDontClobber: function (target) {
        include(target, objects, false, false);
      },
      intoAndClobber: function (target) {
        include(target, objects, true, false);
      },
      intoAndMerge: function (target) {
        include(target, objects, true, true);
      },
    };
  },
};
