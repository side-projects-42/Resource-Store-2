<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>03-Functions</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="functions">Functions</h1>
<p>Functions are an important part of any programming language, and prior to ECMAScript 6, JavaScript functions hadn’t changed much since the language was created. This left a backlog of problems and nuanced behavior that made making mistakes easy and often required more code just to achieve very basic behaviors.</p>
<p>ECMAScript 6 functions make a big leap forward, taking into account years of complaints and requests from JavaScript developers. The result is a number of incremental improvements on top of ECMAScript 5 functions that make programming in JavaScript less error-prone and more powerful.</p>
<h2 id="functions-with-default-parameter-values">Functions with Default Parameter Values</h2>
<p>Functions in JavaScript are unique in that they allow any number of parameters to be passed, regardless of the number of parameters declared in the function definition. This allows you to define functions that can handle different numbers of parameters, often by just filling in default values when parameters aren’t provided. This section covers how default parameters work both in and prior to ECMAScript 6, along with some important information on the <code>arguments</code> object, using expressions as parameters, and another TDZ.</p>
<h3 id="simulating-default-parameter-values-in-ecmascript-5">Simulating Default Parameter Values in ECMAScript 5</h3>
<p>In ECMAScript 5 and earlier, you would likely use the following pattern to create a function with default parameters values:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">function</span> <span class="at">makeRequest</span>(url<span class="op">,</span> timeout<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3">    timeout <span class="op">=</span> timeout <span class="op">||</span> <span class="dv">2000</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-4" title="4">    callback <span class="op">=</span> callback <span class="op">||</span> <span class="kw">function</span>() <span class="op">{};</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="co">// the rest of the function</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="op">}</span></a></code></pre></div>
<p>In this example, both <code>timeout</code> and <code>callback</code> are actually optional because they are given a default value if a parameter isn’t provided. The logical OR operator (<code>||</code>) always returns the second operand when the first is falsy. Since named function parameters that are not explicitly provided are set to <code>undefined</code>, the logical OR operator is frequently used to provide default values for missing parameters. There is a flaw with this approach, however, in that a valid value for <code>timeout</code> might actually be <code>0</code>, but this would replace it with <code>2000</code> because <code>0</code> is falsy.</p>
<p>In that case, a safer alternative is to check the type of the argument using <code>typeof</code>, as in this example:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">function</span> <span class="at">makeRequest</span>(url<span class="op">,</span> timeout<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">    timeout <span class="op">=</span> (<span class="kw">typeof</span> timeout <span class="op">!==</span> <span class="st">&quot;undefined&quot;</span>) <span class="op">?</span> timeout : <span class="dv">2000</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-4" title="4">    callback <span class="op">=</span> (<span class="kw">typeof</span> callback <span class="op">!==</span> <span class="st">&quot;undefined&quot;</span>) <span class="op">?</span> callback : <span class="kw">function</span>() <span class="op">{};</span></a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="co">// the rest of the function</span></a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="op">}</span></a></code></pre></div>
<p>While this approach is safer, it still requires a lot of extra code for a very basic operation. Popular JavaScript libraries are filled with similar patterns, as this represents a common pattern.</p>
<h3 id="default-parameter-values-in-ecmascript-6">Default Parameter Values in ECMAScript 6</h3>
<p>ECMAScript 6 makes it easier to provide default values for parameters by providing initializations that are used when the parameter isn’t formally passed. For example:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">function</span> <span class="at">makeRequest</span>(url<span class="op">,</span> timeout <span class="op">=</span> <span class="dv">2000</span><span class="op">,</span> callback <span class="op">=</span> <span class="kw">function</span>() <span class="op">{}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="co">// the rest of the function</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>This function only expects the first parameter to always be passed. The other two parameters have default values, which makes the body of the function much smaller because you don’t need to add any code to check for a missing value.</p>
<p>When <code>makeRequest()</code> is called with all three parameters, the defaults are not used. For example:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="co">// uses default timeout and callback</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="at">makeRequest</span>(<span class="st">&quot;/foo&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-3" title="3"></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co">// uses default callback</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="at">makeRequest</span>(<span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="dv">500</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co">// doesn&#39;t use defaults</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="at">makeRequest</span>(<span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="dv">500</span><span class="op">,</span> <span class="kw">function</span>(body) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="at">doSomething</span>(body)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-10" title="10"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>ECMAScript 6 considers <code>url</code> to be required, which is why <code>"/foo"</code> is passed in all three calls to <code>makeRequest()</code>. The two parameters with a default value are considered optional.</p>
<p>It’s possible to specify default values for any arguments, including those that appear before arguments without default values in the function declaration. For example, this is fine:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">function</span> <span class="at">makeRequest</span>(url<span class="op">,</span> timeout <span class="op">=</span> <span class="dv">2000</span><span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="co">// the rest of the function</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>In this case, the default value for <code>timeout</code> will only be used if there is no second argument passed in or if the second argument is explicitly passed in as <code>undefined</code>, as in this example:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="co">// uses default timeout</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="at">makeRequest</span>(<span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="kw">undefined</span><span class="op">,</span> <span class="kw">function</span>(body) <span class="op">{</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="at">doSomething</span>(body)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="co">// uses default timeout</span></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="at">makeRequest</span>(<span class="st">&quot;/foo&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-8" title="8"></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="co">// doesn&#39;t use default timeout</span></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="at">makeRequest</span>(<span class="st">&quot;/foo&quot;</span><span class="op">,</span> <span class="kw">null</span><span class="op">,</span> <span class="kw">function</span>(body) <span class="op">{</span></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="at">doSomething</span>(body)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-12" title="12"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>In the case of default parameter values, a value of <code>null</code> is considered to be valid, meaning that in the third call to <code>makeRequest()</code>, the default value for <code>timeout</code> will not be used.</p>
<h3 id="how-default-parameter-values-affect-the-arguments-object">How Default Parameter Values Affect the arguments Object</h3>
<p>Just keep in mind that the behavior of the <code>arguments</code> object is different when default parameter values are present. In ECMAScript 5 nonstrict mode, the <code>arguments</code> object reflects changes in the named parameters of a function. Here’s some code that illustrates how this works:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">function</span> <span class="at">mixArgs</span>(first<span class="op">,</span> second) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="va">console</span>.<span class="at">log</span>(first <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">0</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(second <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">1</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4">    first <span class="op">=</span> <span class="st">&quot;c&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-5" title="5">    second <span class="op">=</span> <span class="st">&quot;d&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="va">console</span>.<span class="at">log</span>(first <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">0</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="va">console</span>.<span class="at">log</span>(second <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">1</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb7-9" title="9"></a>
<a class="sourceLine" id="cb7-10" title="10"><span class="at">mixArgs</span>(<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span>)<span class="op">;</span></a></code></pre></div>
<p>This outputs:</p>
<pre><code>true
true
true
true</code></pre>
<p>The <code>arguments</code> object is always updated in nonstrict mode to reflect changes in the named parameters. Thus, when <code>first</code> and <code>second</code> are assigned new values, <code>arguments[0]</code> and <code>arguments[1]</code> are updated accordingly, making all of the <code>===</code> comparisons resolve to <code>true</code>.</p>
<p>ECMAScript 5’s strict mode, however, eliminates this confusing aspect of the <code>arguments</code> object. In strict mode, the <code>arguments</code> object does not reflect changes to the named parameters. Here’s the <code>mixArgs()</code> function again, but in strict mode:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">function</span> <span class="at">mixArgs</span>(first<span class="op">,</span> second) <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(first <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">0</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb9-5" title="5">    <span class="va">console</span>.<span class="at">log</span>(second <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">1</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb9-6" title="6">    first <span class="op">=</span> <span class="st">&quot;c&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb9-7" title="7">    second <span class="op">=</span> <span class="st">&quot;d&quot;</span></a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="va">console</span>.<span class="at">log</span>(first <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">0</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb9-9" title="9">    <span class="va">console</span>.<span class="at">log</span>(second <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">1</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb9-10" title="10"><span class="op">}</span></a>
<a class="sourceLine" id="cb9-11" title="11"></a>
<a class="sourceLine" id="cb9-12" title="12"><span class="at">mixArgs</span>(<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span>)<span class="op">;</span></a></code></pre></div>
<p>The call to <code>mixArgs()</code> outputs:</p>
<pre><code>true
true
false
false</code></pre>
<p>This time, changing <code>first</code> and <code>second</code> doesn’t affect <code>arguments</code>, so the output behaves as you’d normally expect it to.</p>
<p>The <code>arguments</code> object in a function using ECMAScript 6 default parameter values, however, will always behave in the same manner as ECMAScript 5 strict mode, regardless of whether the function is explicitly running in strict mode. The presence of default parameter values triggers the <code>arguments</code> object to remain detached from the named parameters. This is a subtle but important detail because of how the <code>arguments</code> object may be used. Consider the following:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="co">// not in strict mode</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">function</span> <span class="at">mixArgs</span>(first<span class="op">,</span> second <span class="op">=</span> <span class="st">&quot;b&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">arguments</span>.<span class="at">length</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(first <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">0</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="va">console</span>.<span class="at">log</span>(second <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">1</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb11-6" title="6">    first <span class="op">=</span> <span class="st">&quot;c&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-7" title="7">    second <span class="op">=</span> <span class="st">&quot;d&quot;</span></a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="va">console</span>.<span class="at">log</span>(first <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">0</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb11-9" title="9">    <span class="va">console</span>.<span class="at">log</span>(second <span class="op">===</span> <span class="kw">arguments</span>[<span class="dv">1</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="op">}</span></a>
<a class="sourceLine" id="cb11-11" title="11"></a>
<a class="sourceLine" id="cb11-12" title="12"><span class="at">mixArgs</span>(<span class="st">&quot;a&quot;</span>)<span class="op">;</span></a></code></pre></div>
<p>This outputs:</p>
<pre><code>1
true
false
false
false</code></pre>
<p>In this example, <code>arguments.length</code> is 1 because only one argument was passed to <code>mixArgs()</code>. That also means <code>arguments[1]</code> is <code>undefined</code>, which is the expected behavior when only one argument is passed to a function. That means <code>first</code> is equal to <code>arguments[0]</code> as well. Changing <code>first</code> and <code>second</code> has no effect on <code>arguments</code>. This behavior occurs in both nonstrict and strict mode, so you can rely on <code>arguments</code> to always reflect the initial call state.</p>
<h3 id="default-parameter-expressions">Default Parameter Expressions</h3>
<p>Perhaps the most interesting feature of default parameter values is that the default value need not be a primitive value. You can, for example, execute a function to retrieve the default parameter value, like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">function</span> <span class="at">getValue</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb13-2" title="2">    <span class="cf">return</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5"><span class="kw">function</span> <span class="at">add</span>(first<span class="op">,</span> second <span class="op">=</span> <span class="at">getValue</span>()) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="cf">return</span> first <span class="op">+</span> second<span class="op">;</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span>     <span class="co">// 2</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span>))<span class="op">;</span>        <span class="co">// 6</span></a></code></pre></div>
<p>Here, if the last argument isn’t provided, the function <code>getValue()</code> is called to retrieve the correct default value. Keep in mind that <code>getValue()</code> is only called when <code>add()</code> is called without a second parameter, not when the function declaration is first parsed. That means if <code>getValue()</code> were written differently, it could potentially return a different value. For instance:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">let</span> value <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-2" title="2"></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="kw">function</span> <span class="at">getValue</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb14-4" title="4">    <span class="cf">return</span> value<span class="op">++;</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="op">}</span></a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="kw">function</span> <span class="at">add</span>(first<span class="op">,</span> second <span class="op">=</span> <span class="at">getValue</span>()) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-8" title="8">    <span class="cf">return</span> first <span class="op">+</span> second<span class="op">;</span></a>
<a class="sourceLine" id="cb14-9" title="9"><span class="op">}</span></a>
<a class="sourceLine" id="cb14-10" title="10"></a>
<a class="sourceLine" id="cb14-11" title="11"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span>     <span class="co">// 2</span></a>
<a class="sourceLine" id="cb14-12" title="12"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span>))<span class="op">;</span>        <span class="co">// 6</span></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span>))<span class="op">;</span>        <span class="co">// 7</span></a></code></pre></div>
<p>In this example, <code>value</code> begins as five and increments each time <code>getValue()</code> is called. The first call to <code>add(1)</code> returns 6, while the second call to <code>add(1)</code> returns 7 because <code>value</code> was incremented. Because the default value for <code>second</code> is only evaluated when the function is called, changes to that value can be made at any time.</p>
<p>W&gt; Be careful when using function calls as default parameter values. If you forget the parentheses, such as <code>second = getValue</code> in the last example, you are passing a reference to the function rather than the result of the function call.</p>
<p>This behavior introduces another interesting capability. You can use a previous parameter as the default for a later parameter. Here’s an example:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">function</span> <span class="at">add</span>(first<span class="op">,</span> second <span class="op">=</span> first) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-2" title="2">    <span class="cf">return</span> first <span class="op">+</span> second<span class="op">;</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb15-4" title="4"></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span>     <span class="co">// 2</span></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span>))<span class="op">;</span>        <span class="co">// 2</span></a></code></pre></div>
<p>In this code, the parameter <code>second</code> is given a default value of <code>first</code>, meaning that passing in just one argument leaves both arguments with the same value. So <code>add(1, 1)</code> returns 2 just as <code>add(1)</code> returns 2. Taking this a step further, you can pass <code>first</code> into a function to get the value for <code>second</code> as follows:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">function</span> <span class="at">getValue</span>(value) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-2" title="2">    <span class="cf">return</span> value <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="kw">function</span> <span class="at">add</span>(first<span class="op">,</span> second <span class="op">=</span> <span class="at">getValue</span>(first)) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="cf">return</span> first <span class="op">+</span> second<span class="op">;</span></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb16-8" title="8"></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span>     <span class="co">// 2</span></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span>))<span class="op">;</span>        <span class="co">// 7</span></a></code></pre></div>
<p>This example sets <code>second</code> equal to the value returned by <code>getValue(first)</code>, so while <code>add(1, 1)</code> still returns 2, <code>add(1)</code> returns 7 (1 + 6).</p>
<p>The ability to reference parameters from default parameter assignments works only for previous arguments, so earlier arguments do not have access to later arguments. For example:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">function</span> <span class="at">add</span>(first <span class="op">=</span> second<span class="op">,</span> second) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-2" title="2">    <span class="cf">return</span> first <span class="op">+</span> second<span class="op">;</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb17-4" title="4"></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span>         <span class="co">// 2</span></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="kw">undefined</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span> <span class="co">// throws error</span></a></code></pre></div>
<p>The call to <code>add(undefined, 1)</code> throws an error because <code>second</code> is defined after <code>first</code> and is therefore unavailable as a default value. To understand why that happens, it’s important to revisit temporal dead zones.</p>
<h3 id="default-parameter-value-temporal-dead-zone">Default Parameter Value Temporal Dead Zone</h3>
<p>Chapter 1 introduced the temporal dead zone (TDZ) as it relates to <code>let</code> and <code>const</code>, and default parameter values also have a TDZ where parameters cannot be accessed. Similar to a <code>let</code> declaration, each parameter creates a new identifier binding that can’t be referenced before initialization without throwing an error. Parameter initialization happens when the function is called, either by passing a value for the parameter or by using the default parameter value.</p>
<p>To explore the default parameter value TDZ, consider this example from “Default Parameter Expressions” again:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">function</span> <span class="at">getValue</span>(value) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-2" title="2">    <span class="cf">return</span> value <span class="op">+</span> <span class="dv">5</span><span class="op">;</span></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb18-4" title="4"></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="kw">function</span> <span class="at">add</span>(first<span class="op">,</span> second <span class="op">=</span> <span class="at">getValue</span>(first)) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-6" title="6">    <span class="cf">return</span> first <span class="op">+</span> second<span class="op">;</span></a>
<a class="sourceLine" id="cb18-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb18-8" title="8"></a>
<a class="sourceLine" id="cb18-9" title="9"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span>     <span class="co">// 2</span></a>
<a class="sourceLine" id="cb18-10" title="10"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span>))<span class="op">;</span>        <span class="co">// 7</span></a></code></pre></div>
<p>The calls to <code>add(1, 1)</code> and <code>add(1)</code> effectively execute the following code to create the <code>first</code> and <code>second</code> parameter values:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb19-1" title="1"><span class="co">// JavaScript representation of call to add(1, 1)</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="kw">let</span> first <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb19-3" title="3"><span class="kw">let</span> second <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb19-4" title="4"></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="co">// JavaScript representation of call to add(1)</span></a>
<a class="sourceLine" id="cb19-6" title="6"><span class="kw">let</span> first <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="kw">let</span> second <span class="op">=</span> <span class="at">getValue</span>(first)<span class="op">;</span></a></code></pre></div>
<p>When the function <code>add()</code> is first executed, the bindings <code>first</code> and <code>second</code> are added to a parameter-specific TDZ (similar to how <code>let</code> behaves). So while <code>second</code> can be initialized with the value of <code>first</code> because <code>first</code> is always initialized at that time, the reverse is not true. Now, consider this rewritten <code>add()</code> function:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">function</span> <span class="at">add</span>(first <span class="op">=</span> second<span class="op">,</span> second) <span class="op">{</span></a>
<a class="sourceLine" id="cb20-2" title="2">    <span class="cf">return</span> first <span class="op">+</span> second<span class="op">;</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb20-4" title="4"></a>
<a class="sourceLine" id="cb20-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span>         <span class="co">// 2</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="kw">undefined</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span> <span class="co">// throws error</span></a></code></pre></div>
<p>The calls to <code>add(1, 1)</code> and <code>add(undefined, 1)</code> in this example now map to this code behind the scenes:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb21-1" title="1"><span class="co">// JavaScript representation of call to add(1, 1)</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="kw">let</span> first <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb21-3" title="3"><span class="kw">let</span> second <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb21-4" title="4"></a>
<a class="sourceLine" id="cb21-5" title="5"><span class="co">// JavaScript representation of call to add(undefined, 1)</span></a>
<a class="sourceLine" id="cb21-6" title="6"><span class="kw">let</span> first <span class="op">=</span> second<span class="op">;</span></a>
<a class="sourceLine" id="cb21-7" title="7"><span class="kw">let</span> second <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></a></code></pre></div>
<p>In this example, the call to <code>add(undefined, 1)</code> throws an error because <code>second</code> hasn’t yet been initialized when <code>first</code> is initialized. At that point, <code>second</code> is in the TDZ and therefore any references to <code>second</code> throw an error. This mirrors the behavior of <code>let</code> bindings discussed in Chapter 1.</p>
<p>I&gt; Function parameters have their own scope and their own TDZ that is separate from the function body scope. That means the default value of a parameter cannot access any variables declared inside the function body.</p>
<h2 id="working-with-unnamed-parameters">Working with Unnamed Parameters</h2>
<p>So far, the examples in this chapter have only covered parameters that have been named in the function definition. However, JavaScript functions don’t limit the number of parameters that can be passed to the number of named parameters defined. You can always pass fewer or more parameters than formally specified. Default parameter values make it clear when a function can accept fewer parameters, and ECMAScript 6 sought to make the problem of passing more parameters than defined better as well.</p>
<h3 id="unnamed-parameters-in-ecmascript-5">Unnamed Parameters in ECMAScript 5</h3>
<p>Early on, JavaScript provided the <code>arguments</code> object as a way to inspect all function parameters that are passed without necessarily defining each parameter individually. While inspecting <code>arguments</code> works fine in most cases, this object can be a little cumbersome to work with. For example, examine this code, which inspects the <code>arguments</code> object:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">function</span> <span class="at">pick</span>(object) <span class="op">{</span></a>
<a class="sourceLine" id="cb22-2" title="2">    <span class="kw">let</span> result <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4">    <span class="co">// start at the second parameter</span></a>
<a class="sourceLine" id="cb22-5" title="5">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> len <span class="op">=</span> <span class="kw">arguments</span>.<span class="at">length</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb22-6" title="6">        result[<span class="kw">arguments</span>[i]] <span class="op">=</span> object[<span class="kw">arguments</span>[i]]<span class="op">;</span></a>
<a class="sourceLine" id="cb22-7" title="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9">    <span class="cf">return</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb22-10" title="10"><span class="op">}</span></a>
<a class="sourceLine" id="cb22-11" title="11"></a>
<a class="sourceLine" id="cb22-12" title="12"><span class="kw">let</span> book <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-13" title="13">    <span class="dt">title</span><span class="op">:</span> <span class="st">&quot;Understanding ECMAScript 6&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb22-14" title="14">    <span class="dt">author</span><span class="op">:</span> <span class="st">&quot;Nicholas C. Zakas&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb22-15" title="15">    <span class="dt">year</span><span class="op">:</span> <span class="dv">2015</span></a>
<a class="sourceLine" id="cb22-16" title="16"><span class="op">};</span></a>
<a class="sourceLine" id="cb22-17" title="17"></a>
<a class="sourceLine" id="cb22-18" title="18"><span class="kw">let</span> bookData <span class="op">=</span> <span class="at">pick</span>(book<span class="op">,</span> <span class="st">&quot;author&quot;</span><span class="op">,</span> <span class="st">&quot;year&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb22-19" title="19"></a>
<a class="sourceLine" id="cb22-20" title="20"><span class="va">console</span>.<span class="at">log</span>(<span class="va">bookData</span>.<span class="at">author</span>)<span class="op">;</span>   <span class="co">// &quot;Nicholas C. Zakas&quot;</span></a>
<a class="sourceLine" id="cb22-21" title="21"><span class="va">console</span>.<span class="at">log</span>(<span class="va">bookData</span>.<span class="at">year</span>)<span class="op">;</span>     <span class="co">// 2015</span></a></code></pre></div>
<p>This function mimics the <code>pick()</code> method from the <em>Underscore.js</em> library, which returns a copy of a given object with some specified subset of the original object’s properties. This example defines only one argument and expects the first argument to be the object from which to copy properties. Every other argument passed is the name of a property that should be copied on the result.</p>
<p>There are a couple of things to notice about this <code>pick()</code> function. First, it’s not at all obvious that the function can handle more than one parameter. You could define several more parameters, but you would always fall short of indicating that this function can take any number of parameters. Second, because the first parameter is named and used directly, when you look for the properties to copy, you have to start in the <code>arguments</code> object at index 1 instead of index 0. Remembering to use the appropriate indices with <code>arguments</code> isn’t necessarily difficult, but it’s one more thing to keep track of.</p>
<p>ECMAScript 6 introduces rest parameters to help with these issues.</p>
<h3 id="rest-parameters">Rest Parameters</h3>
<p>A <em>rest parameter</em> is indicated by three dots (<code>...</code>) preceding a named parameter. That named parameter becomes an <code>Array</code> containing the rest of the parameters passed to the function, which is where the name “rest” parameters originates. For example, <code>pick()</code> can be rewritten using rest parameters, like this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">function</span> <span class="at">pick</span>(object<span class="op">,</span> ...<span class="at">keys</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb23-2" title="2">    <span class="kw">let</span> result <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> len <span class="op">=</span> <span class="va">keys</span>.<span class="at">length</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb23-5" title="5">        result[keys[i]] <span class="op">=</span> object[keys[i]]<span class="op">;</span></a>
<a class="sourceLine" id="cb23-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb23-7" title="7"></a>
<a class="sourceLine" id="cb23-8" title="8">    <span class="cf">return</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>In this version of the function, <code>keys</code> is a rest parameter that contains all parameters passed after <code>object</code> (unlike <code>arguments</code>, which contains all parameters including the first one). That means you can iterate over <code>keys</code> from beginning to end without worry. As a bonus, you can tell by looking at the function that it is capable of handling any number of parameters.</p>
<p>I&gt; Rest parameters do not affect a function’s <code>length</code> property, which indicates the number of named parameters for the function. The value of <code>length</code> for <code>pick()</code> in this example is 1 because only <code>object</code> counts towards this value.</p>
<h4 id="rest-parameter-restrictions">Rest Parameter Restrictions</h4>
<p>There are two restrictions on rest parameters. The first restriction is that there can be only one rest parameter, and the rest parameter must be last. For example, this code won’t work:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb24-1" title="1"><span class="co">// Syntax error: Can&#39;t have a named parameter after rest parameters</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="kw">function</span> <span class="at">pick</span>(object<span class="op">,</span> ...<span class="at">keys</span><span class="op">,</span> last) <span class="op">{</span></a>
<a class="sourceLine" id="cb24-3" title="3">    <span class="kw">let</span> result <span class="op">=</span> <span class="va">Object</span>.<span class="at">create</span>(<span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb24-4" title="4"></a>
<a class="sourceLine" id="cb24-5" title="5">    <span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> len <span class="op">=</span> <span class="va">keys</span>.<span class="at">length</span><span class="op">;</span> i <span class="op">&lt;</span> len<span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb24-6" title="6">        result[keys[i]] <span class="op">=</span> object[keys[i]]<span class="op">;</span></a>
<a class="sourceLine" id="cb24-7" title="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb24-8" title="8"></a>
<a class="sourceLine" id="cb24-9" title="9">    <span class="cf">return</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb24-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>Here, the parameter <code>last</code> follows the rest parameter <code>keys</code>, which would cause a syntax error.</p>
<p>The second restriction is that rest parameters cannot be used in an object literal setter. That means this code would also cause a syntax error:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">let</span> object <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb25-2" title="2"></a>
<a class="sourceLine" id="cb25-3" title="3">    <span class="co">// Syntax error: Can&#39;t use rest param in setter</span></a>
<a class="sourceLine" id="cb25-4" title="4">    set <span class="at">name</span>(...<span class="at">value</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb25-5" title="5">        <span class="co">// do something</span></a>
<a class="sourceLine" id="cb25-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb25-7" title="7"><span class="op">};</span></a></code></pre></div>
<p>This restriction exists because object literal setters are restricted to a single argument. Rest parameters are, by definition, an infinite number of arguments, so they’re not allowed in this context.</p>
<h4 id="how-rest-parameters-affect-the-arguments-object">How Rest Parameters Affect the arguments Object</h4>
<p>Rest parameters were designed to replace <code>arguments</code> in ECMAScript. Originally, ECMAScript 4 did away with <code>arguments</code> and added rest parameters to allow an unlimited number of arguments to be passed to functions. ECMAScript 4 never came into being, but this idea was kept around and reintroduced in ECMAScript 6, despite <code>arguments</code> not being removed from the language.</p>
<p>The <code>arguments</code> object works together with rest parameters by reflecting the arguments that were passed to the function when called, as illustrated in this program:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">function</span> <span class="at">checkArgs</span>(...<span class="at">args</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb26-2" title="2">    <span class="va">console</span>.<span class="at">log</span>(<span class="va">args</span>.<span class="at">length</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">arguments</span>.<span class="at">length</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb26-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(args[<span class="dv">0</span>]<span class="op">,</span> <span class="kw">arguments</span>[<span class="dv">0</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb26-5" title="5">    <span class="va">console</span>.<span class="at">log</span>(args[<span class="dv">1</span>]<span class="op">,</span> <span class="kw">arguments</span>[<span class="dv">1</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb26-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb26-7" title="7"></a>
<a class="sourceLine" id="cb26-8" title="8"><span class="at">checkArgs</span>(<span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="st">&quot;b&quot;</span>)<span class="op">;</span></a></code></pre></div>
<p>The call to <code>checkArgs()</code> outputs:</p>
<pre><code>2
2
a a
b b</code></pre>
<p>The <code>arguments</code> object always correctly reflects the parameters that were passed into a function regardless of rest parameter usage.</p>
<p>That’s all you really need to know about rest parameters to get started using them.</p>
<h2 id="increased-capabilities-of-the-function-constructor">Increased Capabilities of the Function Constructor</h2>
<p>The <code>Function</code> constructor is an infrequently used part of JavaScript that allows you to dynamically create a new function. The arguments to the constructor are the parameters for the function and the function body, all as strings. Here’s an example:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">var</span> add <span class="op">=</span> <span class="kw">new</span> <span class="at">Function</span>(<span class="st">&quot;first&quot;</span><span class="op">,</span> <span class="st">&quot;second&quot;</span><span class="op">,</span> <span class="st">&quot;return first + second&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-2" title="2"></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span>     <span class="co">// 2</span></a></code></pre></div>
<p>ECMAScript 6 augments the capabilities of the <code>Function</code> constructor to allow default parameters and rest parameters. You need only add an equals sign and a value to the parameter names, as follows:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">var</span> add <span class="op">=</span> <span class="kw">new</span> <span class="at">Function</span>(<span class="st">&quot;first&quot;</span><span class="op">,</span> <span class="st">&quot;second = first&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb29-2" title="2">        <span class="st">&quot;return first + second&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb29-3" title="3"></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">1</span>))<span class="op">;</span>     <span class="co">// 2</span></a>
<a class="sourceLine" id="cb29-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="at">add</span>(<span class="dv">1</span>))<span class="op">;</span>        <span class="co">// 2</span></a></code></pre></div>
<p>In this example, the parameter <code>second</code> is assigned the value of <code>first</code> when only one parameter is passed. The syntax is the same as for function declarations that don’t use <code>Function</code>.</p>
<p>For rest parameters, just add the <code>...</code> before the last parameter, like this:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">var</span> pickFirst <span class="op">=</span> <span class="kw">new</span> <span class="at">Function</span>(<span class="st">&quot;...args&quot;</span><span class="op">,</span> <span class="st">&quot;return args[0]&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb30-2" title="2"></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="at">pickFirst</span>(<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span>   <span class="co">// 1</span></a></code></pre></div>
<p>This code creates a function that uses only a single rest parameter and returns the first argument that was passed in.</p>
<p>The addition of default and rest parameters ensures that <code>Function</code> has all of the same capabilities as the declarative form of creating functions.</p>
<h2 id="the-spread-operator">The Spread Operator</h2>
<p>Closely related to rest parameters is the spread operator. While rest parameters allow you to specify that multiple independent arguments should be combined into an array, the spread operator allows you to specify an array that should be split and have its items passed in as separate arguments to a function. Consider the <code>Math.max()</code> method, which accepts any number of arguments and returns the one with the highest value. Here’s a simple use case for this method:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">let</span> value1 <span class="op">=</span> <span class="dv">25</span><span class="op">,</span></a>
<a class="sourceLine" id="cb31-2" title="2">    value2 <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></a>
<a class="sourceLine" id="cb31-3" title="3"></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="va">console</span>.<span class="at">log</span>(<span class="va">Math</span>.<span class="at">max</span>(value1<span class="op">,</span> value2))<span class="op">;</span>      <span class="co">// 50</span></a></code></pre></div>
<p>When you’re dealing with just two values, as in this example, <code>Math.max()</code> is very easy to use. The two values are passed in, and the higher value is returned. But what if you’ve been tracking values in an array, and now you want to find the highest value? The <code>Math.max()</code> method doesn’t allow you to pass in an array, so in ECMAScript 5 and earlier, you’d be stuck either searching the array yourself or using <code>apply()</code> as follows:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">let</span> values <span class="op">=</span> [<span class="dv">25</span><span class="op">,</span> <span class="dv">50</span><span class="op">,</span> <span class="dv">75</span><span class="op">,</span> <span class="dv">100</span>]</a>
<a class="sourceLine" id="cb32-2" title="2"></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="va">Math</span>.<span class="va">max</span>.<span class="at">apply</span>(Math<span class="op">,</span> values))<span class="op">;</span>  <span class="co">// 100</span></a></code></pre></div>
<p>This solution works, but using <code>apply()</code> in this manner is a bit confusing. It actually seems to obfuscate the true meaning of the code with additional syntax.</p>
<p>The ECMAScript 6 spread operator makes this case very simple. Instead of calling <code>apply()</code>, you can pass the array to <code>Math.max()</code> directly and prefix it with the same <code>...</code> pattern used with rest parameters. The JavaScript engine then splits the array into individual arguments and passes them in, like this:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">let</span> values <span class="op">=</span> [<span class="dv">25</span><span class="op">,</span> <span class="dv">50</span><span class="op">,</span> <span class="dv">75</span><span class="op">,</span> <span class="dv">100</span>]</a>
<a class="sourceLine" id="cb33-2" title="2"></a>
<a class="sourceLine" id="cb33-3" title="3"><span class="co">// equivalent to</span></a>
<a class="sourceLine" id="cb33-4" title="4"><span class="co">// console.log(Math.max(25, 50, 75, 100));</span></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="va">Math</span>.<span class="at">max</span>(...<span class="at">values</span>))<span class="op">;</span>           <span class="co">// 100</span></a></code></pre></div>
<p>Now the call to <code>Math.max()</code> looks a bit more conventional and avoids the complexity of specifying a <code>this</code>-binding (the first argument to <code>Math.max.apply()</code> in the previous example) for a simple mathematical operation.</p>
<p>You can mix and match the spread operator with other arguments as well. Suppose you want the smallest number returned from <code>Math.max()</code> to be 0 (just in case negative numbers sneak into the array). You can pass that argument separately and still use the spread operator for the other arguments, as follows:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">let</span> values <span class="op">=</span> [<span class="op">-</span><span class="dv">25</span><span class="op">,</span> <span class="dv">-50</span><span class="op">,</span> <span class="dv">-75</span><span class="op">,</span> <span class="dv">-100</span>]</a>
<a class="sourceLine" id="cb34-2" title="2"></a>
<a class="sourceLine" id="cb34-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="va">Math</span>.<span class="at">max</span>(...<span class="at">values</span><span class="op">,</span> <span class="dv">0</span>))<span class="op">;</span>        <span class="co">// 0</span></a></code></pre></div>
<p>In this example, the last argument passed to <code>Math.max()</code> is <code>0</code>, which comes after the other arguments are passed in using the spread operator.</p>
<p>The spread operator for argument passing makes using arrays for function arguments much easier. You’ll likely find it to be a suitable replacement for the <code>apply()</code> method in most circumstances.</p>
<p>In addition to the uses you’ve seen for default and rest parameters so far, in ECMAScript 6, you can also apply both parameter types to JavaScript’s <code>Function</code> constructor.</p>
<h2 id="ecmascript-6s-name-property">ECMAScript 6’s name Property</h2>
<p>Identifying functions can be challenging in JavaScript given the various ways a function can be defined. Additionally, the prevalence of anonymous function expressions makes debugging a bit more difficult, often resulting in stack traces that are hard to read and decipher. For these reasons, ECMAScript 6 adds the <code>name</code> property to all functions.</p>
<h3 id="choosing-appropriate-names">Choosing Appropriate Names</h3>
<p>All functions in an ECMAScript 6 program will have an appropriate value for their <code>name</code> property. To see this in action, look at the following example, which shows a function and function expression, and prints the <code>name</code> properties for both:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb35-2" title="2">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb35-4" title="4"></a>
<a class="sourceLine" id="cb35-5" title="5"><span class="kw">var</span> doAnotherThing <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb35-6" title="6">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb35-7" title="7"><span class="op">};</span></a>
<a class="sourceLine" id="cb35-8" title="8"></a>
<a class="sourceLine" id="cb35-9" title="9"><span class="va">console</span>.<span class="at">log</span>(<span class="va">doSomething</span>.<span class="at">name</span>)<span class="op">;</span>          <span class="co">// &quot;doSomething&quot;</span></a>
<a class="sourceLine" id="cb35-10" title="10"><span class="va">console</span>.<span class="at">log</span>(<span class="va">doAnotherThing</span>.<span class="at">name</span>)<span class="op">;</span>       <span class="co">// &quot;doAnotherThing&quot;</span></a></code></pre></div>
<p>In this code, <code>doSomething()</code> has a <code>name</code> property equal to <code>"doSomething"</code> because it’s a function declaration. The anonymous function expression <code>doAnotherThing()</code> has a <code>name</code> of <code>"doAnotherThing"</code> because that’s the name of the variable to which it is assigned.</p>
<h3 id="special-cases-of-the-name-property">Special Cases of the name Property</h3>
<p>While appropriate names for function declarations and function expressions are easy to find, ECMAScript 6 goes further to ensure that <em>all</em> functions have appropriate names. To illustrate this, consider the following program:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">var</span> doSomething <span class="op">=</span> <span class="kw">function</span> <span class="at">doSomethingElse</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb36-2" title="2">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="op">};</span></a>
<a class="sourceLine" id="cb36-4" title="4"></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="kw">var</span> person <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb36-6" title="6">    get <span class="at">firstName</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb36-7" title="7">        <span class="cf">return</span> <span class="st">&quot;Nicholas&quot;</span></a>
<a class="sourceLine" id="cb36-8" title="8">    <span class="op">},</span></a>
<a class="sourceLine" id="cb36-9" title="9">    <span class="dt">sayName</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb36-10" title="10">        <span class="va">console</span>.<span class="at">log</span>(<span class="kw">this</span>.<span class="at">name</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-11" title="11">    <span class="op">}</span></a>
<a class="sourceLine" id="cb36-12" title="12"><span class="op">}</span></a>
<a class="sourceLine" id="cb36-13" title="13"></a>
<a class="sourceLine" id="cb36-14" title="14"><span class="va">console</span>.<span class="at">log</span>(<span class="va">doSomething</span>.<span class="at">name</span>)<span class="op">;</span>      <span class="co">// &quot;doSomethingElse&quot;</span></a>
<a class="sourceLine" id="cb36-15" title="15"><span class="va">console</span>.<span class="at">log</span>(<span class="va">person</span>.<span class="va">sayName</span>.<span class="at">name</span>)<span class="op">;</span>   <span class="co">// &quot;sayName&quot;</span></a>
<a class="sourceLine" id="cb36-16" title="16"></a>
<a class="sourceLine" id="cb36-17" title="17"><span class="kw">var</span> descriptor <span class="op">=</span> <span class="va">Object</span>.<span class="at">getOwnPropertyDescriptor</span>(person<span class="op">,</span> <span class="st">&quot;firstName&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-18" title="18"><span class="va">console</span>.<span class="at">log</span>(<span class="va">descriptor</span>.<span class="va">get</span>.<span class="at">name</span>)<span class="op">;</span> <span class="co">// &quot;get firstName&quot;</span></a></code></pre></div>
<p>In this example, <code>doSomething.name</code> is <code>"doSomethingElse"</code> because the function expression itself has a name, and that name takes priority over the variable to which the function was assigned. The <code>name</code> property of <code>person.sayName()</code> is <code>"sayName"</code>, as the value was interpreted from the object literal. Similarly, <code>person.firstName</code> is actually a getter function, so its name is <code>"get firstName"</code> to indicate this difference. Setter functions are prefixed with <code>"set"</code> as well. (Both getter and setter functions must be retrieved using <code>Object.getOwnPropertyDescriptor()</code>.)</p>
<p>There are a couple of other special cases for function names, too. Functions created using <code>bind()</code> will have their names prefixed with <code>"bound"</code> and functions created using the <code>Function</code> constructor have a name of <code>"anonymous"</code>, as in this example:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">var</span> doSomething <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb37-2" title="2">    <span class="co">// ...</span></a>
<a class="sourceLine" id="cb37-3" title="3"><span class="op">};</span></a>
<a class="sourceLine" id="cb37-4" title="4"></a>
<a class="sourceLine" id="cb37-5" title="5"><span class="va">console</span>.<span class="at">log</span>(<span class="va">doSomething</span>.<span class="at">bind</span>().<span class="at">name</span>)<span class="op">;</span>   <span class="co">// &quot;bound doSomething&quot;</span></a>
<a class="sourceLine" id="cb37-6" title="6"></a>
<a class="sourceLine" id="cb37-7" title="7"><span class="va">console</span>.<span class="at">log</span>((<span class="kw">new</span> <span class="at">Function</span>()).<span class="at">name</span>)<span class="op">;</span>     <span class="co">// &quot;anonymous&quot;</span></a></code></pre></div>
<p>The <code>name</code> of a bound function will always be the <code>name</code> of the function being bound prefixed with the string <code>"bound "</code>, so the bound version of <code>doSomething()</code> is <code>"bound doSomething"</code>.</p>
<p>Keep in mind that the value of <code>name</code> for any function does not necessarily refer to a variable of the same name. The <code>name</code> property is meant to be informative, to help with debugging, so there’s no way to use the value of <code>name</code> to get a reference to the function.</p>
<h2 id="clarifying-the-dual-purpose-of-functions">Clarifying the Dual Purpose of Functions</h2>
<p>In ECMAScript 5 and earlier, functions serve the dual purpose of being callable with or without <code>new</code>. When used with <code>new</code>, the <code>this</code> value inside a function is a new object and that new object is returned, as illustrated in this example:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">function</span> <span class="at">Person</span>(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb38-2" title="2">    <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> name<span class="op">;</span></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb38-4" title="4"></a>
<a class="sourceLine" id="cb38-5" title="5"><span class="kw">var</span> person <span class="op">=</span> <span class="kw">new</span> <span class="at">Person</span>(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb38-6" title="6"><span class="kw">var</span> notAPerson <span class="op">=</span> <span class="at">Person</span>(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb38-7" title="7"></a>
<a class="sourceLine" id="cb38-8" title="8"><span class="va">console</span>.<span class="at">log</span>(person)<span class="op">;</span>        <span class="co">// &quot;[Object object]&quot;</span></a>
<a class="sourceLine" id="cb38-9" title="9"><span class="va">console</span>.<span class="at">log</span>(notAPerson)<span class="op">;</span>    <span class="co">// &quot;undefined&quot;</span></a></code></pre></div>
<p>When creating <code>notAPerson</code>, calling <code>Person()</code> without <code>new</code> results in <code>undefined</code> (and sets a <code>name</code> property on the global object in nonstrict mode). The capitalization of <code>Person</code> is the only real indicator that the function is meant to be called using <code>new</code>, as is common in JavaScript programs. This confusion over the dual roles of functions led to some changes in ECMAScript 6.</p>
<p>JavaScript has two different internal-only methods for functions: <code>[[Call]]</code> and <code>[[Construct]]</code>. When a function is called without <code>new</code>, the <code>[[Call]]</code> method is executed, which executes the body of the function as it appears in the code. When a function is called with <code>new</code>, that’s when the <code>[[Construct]]</code> method is called. The <code>[[Construct]]</code> method is responsible for creating a new object, called the <em>new target</em>, and then executing the function body with <code>this</code> set to the new target. Functions that have a <code>[[Construct]]</code> method are called <em>constructors</em>.</p>
<p>I&gt; Keep in mind that not all functions have <code>[[Construct]]</code>, and therefore not all functions can be called with <code>new</code>. Arrow functions, discussed in the “Arrow Functions” section, do not have a <code>[[Construct]]</code> method.</p>
<h3 id="determining-how-a-function-was-called-in-ecmascript-5">Determining How a Function was Called in ECMAScript 5</h3>
<p>The most popular way to determine if a function was called with <code>new</code> (and hence, with constructor) in ECMAScript 5 is to use <code>instanceof</code>, for example:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb39-1" title="1"><span class="kw">function</span> <span class="at">Person</span>(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb39-2" title="2">    <span class="cf">if</span> (<span class="kw">this</span> <span class="kw">instanceof</span> Person) <span class="op">{</span></a>
<a class="sourceLine" id="cb39-3" title="3">        <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> name<span class="op">;</span>   <span class="co">// using new</span></a>
<a class="sourceLine" id="cb39-4" title="4">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb39-5" title="5">        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&quot;You must use new with Person.&quot;</span>)</a>
<a class="sourceLine" id="cb39-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb39-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb39-8" title="8"></a>
<a class="sourceLine" id="cb39-9" title="9"><span class="kw">var</span> person <span class="op">=</span> <span class="kw">new</span> <span class="at">Person</span>(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb39-10" title="10"><span class="kw">var</span> notAPerson <span class="op">=</span> <span class="at">Person</span>(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span>  <span class="co">// throws error</span></a></code></pre></div>
<p>Here, the <code>this</code> value is checked to see if it’s an instance of the constructor, and if so, execution continues as normal. If <code>this</code> isn’t an instance of <code>Person</code>, then an error is thrown. This works because the <code>[[Construct]]</code> method creates a new instance of <code>Person</code> and assigns it to <code>this</code>. Unfortunately, this approach is not completely reliable because <code>this</code> can be an instance of <code>Person</code> without using <code>new</code>, as in this example:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">function</span> <span class="at">Person</span>(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb40-2" title="2">    <span class="cf">if</span> (<span class="kw">this</span> <span class="kw">instanceof</span> Person) <span class="op">{</span></a>
<a class="sourceLine" id="cb40-3" title="3">        <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> name<span class="op">;</span>   <span class="co">// using new</span></a>
<a class="sourceLine" id="cb40-4" title="4">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb40-5" title="5">        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&quot;You must use new with Person.&quot;</span>)</a>
<a class="sourceLine" id="cb40-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb40-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb40-8" title="8"></a>
<a class="sourceLine" id="cb40-9" title="9"><span class="kw">var</span> person <span class="op">=</span> <span class="kw">new</span> <span class="at">Person</span>(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb40-10" title="10"><span class="kw">var</span> notAPerson <span class="op">=</span> <span class="va">Person</span>.<span class="at">call</span>(person<span class="op">,</span> <span class="st">&quot;Michael&quot;</span>)<span class="op">;</span>    <span class="co">// works!</span></a></code></pre></div>
<p>The call to <code>Person.call()</code> passes the <code>person</code> variable as the first argument, which means <code>this</code> is set to <code>person</code> inside of the <code>Person</code> function. To the function, there’s no way to distinguish this from being called with <code>new</code>.</p>
<h3 id="the-new.target-metaproperty">The new.target MetaProperty</h3>
<p>To solve this problem, ECMAScript 6 introduces the <code>new.target</code> <em>metaproperty</em>. A metaproperty is a property of a non-object that provides additional information related to its target (such as <code>new</code>). When a function’s <code>[[Construct]]</code> method is called, <code>new.target</code> is filled with the target of the <code>new</code> operator. That target is typically the constructor of the newly created object instance that will become <code>this</code> inside the function body. If <code>[[Call]]</code> is executed, then <code>new.target</code> is <code>undefined</code>.</p>
<p>This new metaproperty allows you to safely detect if a function is called with <code>new</code> by checking whether <code>new.target</code> is defined as follows:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb41-1" title="1"><span class="kw">function</span> <span class="at">Person</span>(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb41-2" title="2">    <span class="cf">if</span> (<span class="kw">typeof</span> <span class="kw">new</span>.<span class="at">target</span> <span class="op">!==</span> <span class="st">&quot;undefined&quot;</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb41-3" title="3">        <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> name<span class="op">;</span>   <span class="co">// using new</span></a>
<a class="sourceLine" id="cb41-4" title="4">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb41-5" title="5">        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&quot;You must use new with Person.&quot;</span>)</a>
<a class="sourceLine" id="cb41-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb41-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb41-8" title="8"></a>
<a class="sourceLine" id="cb41-9" title="9"><span class="kw">var</span> person <span class="op">=</span> <span class="kw">new</span> <span class="at">Person</span>(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb41-10" title="10"><span class="kw">var</span> notAPerson <span class="op">=</span> <span class="va">Person</span>.<span class="at">call</span>(person<span class="op">,</span> <span class="st">&quot;Michael&quot;</span>)<span class="op">;</span>    <span class="co">// error!</span></a></code></pre></div>
<p>By using <code>new.target</code> instead of <code>this instanceof Person</code>, the <code>Person</code> constructor is now correctly throwing an error when used without <code>new</code>.</p>
<p>You can also check that <code>new.target</code> was called with a specific constructor. For instance, look at this example:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb42-1" title="1"><span class="kw">function</span> <span class="at">Person</span>(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb42-2" title="2">    <span class="cf">if</span> (<span class="kw">new</span>.<span class="at">target</span> <span class="op">===</span> Person) <span class="op">{</span></a>
<a class="sourceLine" id="cb42-3" title="3">        <span class="kw">this</span>.<span class="at">name</span> <span class="op">=</span> name<span class="op">;</span>   <span class="co">// using new</span></a>
<a class="sourceLine" id="cb42-4" title="4">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb42-5" title="5">        <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>(<span class="st">&quot;You must use new with Person.&quot;</span>)</a>
<a class="sourceLine" id="cb42-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb42-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb42-8" title="8"></a>
<a class="sourceLine" id="cb42-9" title="9"><span class="kw">function</span> <span class="at">AnotherPerson</span>(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb42-10" title="10">    <span class="va">Person</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span> name)<span class="op">;</span></a>
<a class="sourceLine" id="cb42-11" title="11"><span class="op">}</span></a>
<a class="sourceLine" id="cb42-12" title="12"></a>
<a class="sourceLine" id="cb42-13" title="13"><span class="kw">var</span> person <span class="op">=</span> <span class="kw">new</span> <span class="at">Person</span>(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb42-14" title="14"><span class="kw">var</span> anotherPerson <span class="op">=</span> <span class="kw">new</span> <span class="at">AnotherPerson</span>(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span>  <span class="co">// error!</span></a></code></pre></div>
<p>In this code, <code>new.target</code> must be <code>Person</code> in order to work correctly. When <code>new AnotherPerson("Nicholas")</code> is called, the subsequent call to <code>Person.call(this, name)</code> will throw an error because <code>new.target</code> is <code>undefined</code> inside of the <code>Person</code> constructor (it was called without <code>new</code>).</p>
<p>W&gt; Warning: Using <code>new.target</code> outside of a function is a syntax error.</p>
<p>By adding <code>new.target</code>, ECMAScript 6 helped to clarify some ambiguity around functions calls. Following on this theme, ECMAScript 6 also addresses another previously ambiguous part of the language: declaring functions inside of blocks.</p>
<h2 id="block-level-functions">Block-Level Functions</h2>
<p>In ECMAScript 3 and earlier, a function declaration occurring inside of a block (a <em>block-level function</em>) was technically a syntax error, but all browsers still supported it. Unfortunately, each browser that allowed the syntax behaved in a slightly different way, so it is considered a best practice to avoid function declarations inside of blocks (the best alternative is to use a function expression).</p>
<p>In an attempt to rein in this incompatible behavior, ECMAScript 5 strict mode introduced an error whenever a function declaration was used inside of a block in this way:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb43-1" title="1"><span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb43-2" title="2"></a>
<a class="sourceLine" id="cb43-3" title="3"><span class="cf">if</span> (<span class="kw">true</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb43-4" title="4"></a>
<a class="sourceLine" id="cb43-5" title="5">    <span class="co">// Throws a syntax error in ES5, not so in ES6</span></a>
<a class="sourceLine" id="cb43-6" title="6">    <span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb43-7" title="7">        <span class="co">// ...</span></a>
<a class="sourceLine" id="cb43-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb43-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>In ECMAScript 5, this code throws a syntax error. In ECMAScript 6, the <code>doSomething()</code> function is considered a block-level declaration and can be accessed and called within the same block in which it was defined. For example:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb44-1" title="1"><span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb44-2" title="2"></a>
<a class="sourceLine" id="cb44-3" title="3"><span class="cf">if</span> (<span class="kw">true</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb44-4" title="4"></a>
<a class="sourceLine" id="cb44-5" title="5">    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> doSomething)<span class="op">;</span>        <span class="co">// &quot;function&quot;</span></a>
<a class="sourceLine" id="cb44-6" title="6"></a>
<a class="sourceLine" id="cb44-7" title="7">    <span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb44-8" title="8">        <span class="co">// ...</span></a>
<a class="sourceLine" id="cb44-9" title="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb44-10" title="10"></a>
<a class="sourceLine" id="cb44-11" title="11">    <span class="at">doSomething</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb44-12" title="12"><span class="op">}</span></a>
<a class="sourceLine" id="cb44-13" title="13"></a>
<a class="sourceLine" id="cb44-14" title="14"><span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> doSomething)<span class="op">;</span>            <span class="co">// &quot;undefined&quot;</span></a></code></pre></div>
<p>Block level functions are hoisted to the top of the block in which they are defined, so <code>typeof doSomething</code> returns <code>"function"</code> even though it appears before the function declaration in the code. Once the <code>if</code> block is finished executing, <code>doSomething()</code> no longer exists.</p>
<h3 id="deciding-when-to-use-block-level-functions">Deciding When to Use Block-Level Functions</h3>
<p>Block level functions are similar to <code>let</code> function expressions in that the function definition is removed once execution flows out of the block in which it’s defined. The key difference is that block level functions are hoisted to the top of the containing block. Function expressions that use <code>let</code> are not hoisted, as this example illustrates:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb45-1" title="1"><span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3"><span class="cf">if</span> (<span class="kw">true</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb45-4" title="4"></a>
<a class="sourceLine" id="cb45-5" title="5">    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> doSomething)<span class="op">;</span>        <span class="co">// throws error</span></a>
<a class="sourceLine" id="cb45-6" title="6"></a>
<a class="sourceLine" id="cb45-7" title="7">    <span class="kw">let</span> doSomething <span class="op">=</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb45-8" title="8">        <span class="co">// ...</span></a>
<a class="sourceLine" id="cb45-9" title="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb45-10" title="10"></a>
<a class="sourceLine" id="cb45-11" title="11">    <span class="at">doSomething</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb45-12" title="12"><span class="op">}</span></a>
<a class="sourceLine" id="cb45-13" title="13"></a>
<a class="sourceLine" id="cb45-14" title="14"><span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> doSomething)<span class="op">;</span></a></code></pre></div>
<p>Here, code execution stops when <code>typeof doSomething</code> is executed, because the <code>let</code> statement hasn’t been executed yet, leaving <code>doSomething()</code> in the TDZ. Knowing this difference, you can choose whether to use block level functions or <code>let</code> expressions based on whether or not you want the hoisting behavior.</p>
<h3 id="block-level-functions-in-nonstrict-mode">Block-Level Functions in Nonstrict Mode</h3>
<p>ECMAScript 6 also allows block-level functions in nonstrict mode, but the behavior is slightly different. Instead of hoisting these declarations to the top of the block, they are hoisted all the way to the containing function or global environment. For example:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb46-1" title="1"><span class="co">// ECMAScript 6 behavior</span></a>
<a class="sourceLine" id="cb46-2" title="2"><span class="cf">if</span> (<span class="kw">true</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb46-3" title="3"></a>
<a class="sourceLine" id="cb46-4" title="4">    <span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> doSomething)<span class="op">;</span>        <span class="co">// &quot;function&quot;</span></a>
<a class="sourceLine" id="cb46-5" title="5"></a>
<a class="sourceLine" id="cb46-6" title="6">    <span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb46-7" title="7">        <span class="co">// ...</span></a>
<a class="sourceLine" id="cb46-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb46-9" title="9"></a>
<a class="sourceLine" id="cb46-10" title="10">    <span class="at">doSomething</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb46-11" title="11"><span class="op">}</span></a>
<a class="sourceLine" id="cb46-12" title="12"></a>
<a class="sourceLine" id="cb46-13" title="13"><span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> doSomething)<span class="op">;</span>            <span class="co">// &quot;function&quot;</span></a></code></pre></div>
<p>In this example, <code>doSomething()</code> is hoisted into the global scope so that it still exists outside of the <code>if</code> block. ECMAScript 6 standardized this behavior to remove the incompatible browser behaviors that previously existed, so all ECMAScript 6 runtimes should behave in the same way.</p>
<p>Allowing block-level functions improves your ability to declare functions in JavaScript, but ECMAScript 6 also introduced a completely new way to declare functions.</p>
<h2 id="arrow-functions">Arrow Functions</h2>
<p>One of the most interesting new parts of ECMAScript 6 is the <em>arrow function</em>. Arrow functions are, as the name suggests, functions defined with a new syntax that uses an “arrow” (<code>=&gt;</code>). But arrow functions behave differently than traditional JavaScript functions in a number of important ways:</p>
<ul>
<li><strong>No <code>this</code>, <code>super</code>, <code>arguments</code>, and <code>new.target</code> bindings</strong> - The value of <code>this</code>, <code>super</code>, <code>arguments</code>, and <code>new.target</code> inside of the function is by the closest containing nonarrow function. (<code>super</code> is covered in Chapter 4.)</li>
<li><strong>Cannot be called with <code>new</code></strong> - Arrow functions do not have a <code>[[Construct]]</code> method and therefore cannot be used as constructors. Arrow functions throw an error when used with <code>new</code>.</li>
<li><strong>No prototype</strong> - since you can’t use <code>new</code> on an arrow function, there’s no need for a prototype. The <code>prototype</code> property of an arrow function doesn’t exist.</li>
<li><strong>Can’t change <code>this</code></strong> - The value of <code>this</code> inside of the function can’t be changed. It remains the same throughout the entire lifecycle of the function.</li>
<li><strong>No <code>arguments</code> object</strong> - Since arrow functions have no <code>arguments</code> binding, you must rely on named and rest parameters to access function arguments.</li>
<li><strong>No duplicate named parameters</strong> - arrow functions cannot have duplicate named parameters in strict or nonstrict mode, as opposed to nonarrow functions that cannot have duplicate named parameters only in strict mode.</li>
</ul>
<p>There are a few reasons for these differences. First and foremost, <code>this</code> binding is a common source of error in JavaScript. It’s very easy to lose track of the <code>this</code> value inside a function, which can result in unintended program behavior, and arrow functions eliminate this confusion. Second, by limiting arrow functions to simply executing code with a single <code>this</code> value, JavaScript engines can more easily optimize these operations, unlike regular functions, which might be used as a constructor or otherwise modified.</p>
<p>The rest of the differences are also focused on reducing errors and ambiguities inside of arrow functions. By doing so, JavaScript engines are better able to optimize arrow function execution.</p>
<p>I&gt; Note: Arrow functions also have a <code>name</code> property that follows the same rule as other functions.</p>
<h3 id="arrow-function-syntax">Arrow Function Syntax</h3>
<p>The syntax for arrow functions comes in many flavors depending upon what you’re trying to accomplish. All variations begin with function arguments, followed by the arrow, followed by the body of the function. Both the arguments and the body can take different forms depending on usage. For example, the following arrow function takes a single argument and simply returns it:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb47-1" title="1"><span class="kw">var</span> reflect <span class="op">=</span> value <span class="kw">=&gt;</span> value<span class="op">;</span></a>
<a class="sourceLine" id="cb47-2" title="2"></a>
<a class="sourceLine" id="cb47-3" title="3"><span class="co">// effectively equivalent to:</span></a>
<a class="sourceLine" id="cb47-4" title="4"></a>
<a class="sourceLine" id="cb47-5" title="5"><span class="kw">var</span> reflect <span class="op">=</span> <span class="kw">function</span>(value) <span class="op">{</span></a>
<a class="sourceLine" id="cb47-6" title="6">    <span class="cf">return</span> value<span class="op">;</span></a>
<a class="sourceLine" id="cb47-7" title="7"><span class="op">};</span></a></code></pre></div>
<p>When there is only one argument for an arrow function, that one argument can be used directly without any further syntax. The arrow comes next and the expression to the right of the arrow is evaluated and returned. Even though there is no explicit <code>return</code> statement, this arrow function will return the first argument that is passed in.</p>
<p>If you are passing in more than one argument, then you must include parentheses around those arguments, like this:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">var</span> sum <span class="op">=</span> (num1<span class="op">,</span> num2) <span class="kw">=&gt;</span> num1 <span class="op">+</span> num2<span class="op">;</span></a>
<a class="sourceLine" id="cb48-2" title="2"></a>
<a class="sourceLine" id="cb48-3" title="3"><span class="co">// effectively equivalent to:</span></a>
<a class="sourceLine" id="cb48-4" title="4"></a>
<a class="sourceLine" id="cb48-5" title="5"><span class="kw">var</span> sum <span class="op">=</span> <span class="kw">function</span>(num1<span class="op">,</span> num2) <span class="op">{</span></a>
<a class="sourceLine" id="cb48-6" title="6">    <span class="cf">return</span> num1 <span class="op">+</span> num2<span class="op">;</span></a>
<a class="sourceLine" id="cb48-7" title="7"><span class="op">};</span></a></code></pre></div>
<p>The <code>sum()</code> function simply adds two arguments together and returns the result. The only difference between this arrow function and the <code>reflect()</code> function is that the arguments are enclosed in parentheses with a comma separating them (like traditional functions).</p>
<p>If there are no arguments to the function, then you must include an empty set of parentheses in the declaration, as follows:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb49-1" title="1"><span class="kw">var</span> getName <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="st">&quot;Nicholas&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb49-2" title="2"></a>
<a class="sourceLine" id="cb49-3" title="3"><span class="co">// effectively equivalent to:</span></a>
<a class="sourceLine" id="cb49-4" title="4"></a>
<a class="sourceLine" id="cb49-5" title="5"><span class="kw">var</span> getName <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb49-6" title="6">    <span class="cf">return</span> <span class="st">&quot;Nicholas&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb49-7" title="7"><span class="op">};</span></a></code></pre></div>
<p>When you want to provide a more traditional function body, perhaps consisting of more than one expression, then you need to wrap the function body in braces and explicitly define a return value, as in this version of <code>sum()</code>:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb50-1" title="1"><span class="kw">var</span> sum <span class="op">=</span> (num1<span class="op">,</span> num2) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb50-2" title="2">    <span class="cf">return</span> num1 <span class="op">+</span> num2<span class="op">;</span></a>
<a class="sourceLine" id="cb50-3" title="3"><span class="op">};</span></a>
<a class="sourceLine" id="cb50-4" title="4"></a>
<a class="sourceLine" id="cb50-5" title="5"><span class="co">// effectively equivalent to:</span></a>
<a class="sourceLine" id="cb50-6" title="6"></a>
<a class="sourceLine" id="cb50-7" title="7"><span class="kw">var</span> sum <span class="op">=</span> <span class="kw">function</span>(num1<span class="op">,</span> num2) <span class="op">{</span></a>
<a class="sourceLine" id="cb50-8" title="8">    <span class="cf">return</span> num1 <span class="op">+</span> num2<span class="op">;</span></a>
<a class="sourceLine" id="cb50-9" title="9"><span class="op">};</span></a></code></pre></div>
<p>You can more or less treat the inside of the curly braces the same as you would in a traditional function, with the exception that <code>arguments</code> is not available.</p>
<p>If you want to create a function that does nothing, then you need to include curly braces, like this:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb51-1" title="1"><span class="kw">var</span> doNothing <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{};</span></a>
<a class="sourceLine" id="cb51-2" title="2"></a>
<a class="sourceLine" id="cb51-3" title="3"><span class="co">// effectively equivalent to:</span></a>
<a class="sourceLine" id="cb51-4" title="4"></a>
<a class="sourceLine" id="cb51-5" title="5"><span class="kw">var</span> doNothing <span class="op">=</span> <span class="kw">function</span>() <span class="op">{};</span></a></code></pre></div>
<p>Curly braces are used to denote the function’s body, which works just fine in the cases you’ve seen so far. But an arrow function that wants to return an object literal outside of a function body must wrap the literal in parentheses. For example:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb52-1" title="1"><span class="kw">var</span> getTempItem <span class="op">=</span> id <span class="kw">=&gt;</span> (<span class="op">{</span> <span class="dt">id</span><span class="op">:</span> id<span class="op">,</span> <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Temp&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb52-2" title="2"></a>
<a class="sourceLine" id="cb52-3" title="3"><span class="co">// effectively equivalent to:</span></a>
<a class="sourceLine" id="cb52-4" title="4"></a>
<a class="sourceLine" id="cb52-5" title="5"><span class="kw">var</span> getTempItem <span class="op">=</span> <span class="kw">function</span>(id) <span class="op">{</span></a>
<a class="sourceLine" id="cb52-6" title="6"></a>
<a class="sourceLine" id="cb52-7" title="7">    <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-8" title="8">        <span class="dt">id</span><span class="op">:</span> id<span class="op">,</span></a>
<a class="sourceLine" id="cb52-9" title="9">        <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Temp&quot;</span></a>
<a class="sourceLine" id="cb52-10" title="10">    <span class="op">};</span></a>
<a class="sourceLine" id="cb52-11" title="11"><span class="op">};</span></a></code></pre></div>
<p>Wrapping the object literal in parentheses signals that the braces are an object literal instead of the function body.</p>
<h3 id="creating-immediately-invoked-function-expressions">Creating Immediately-Invoked Function Expressions</h3>
<p>One popular use of functions in JavaScript is creating immediately-invoked function expressions (IIFEs). IIFEs allow you to define an anonymous function and call it immediately without saving a reference. This pattern comes in handy when you want to create a scope that is shielded from the rest of a program. For example:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb53-1" title="1"><span class="kw">let</span> person <span class="op">=</span> <span class="kw">function</span>(name) <span class="op">{</span></a>
<a class="sourceLine" id="cb53-2" title="2"></a>
<a class="sourceLine" id="cb53-3" title="3">    <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb53-4" title="4">        <span class="dt">getName</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb53-5" title="5">            <span class="cf">return</span> name<span class="op">;</span></a>
<a class="sourceLine" id="cb53-6" title="6">        <span class="op">}</span></a>
<a class="sourceLine" id="cb53-7" title="7">    <span class="op">};</span></a>
<a class="sourceLine" id="cb53-8" title="8"></a>
<a class="sourceLine" id="cb53-9" title="9"><span class="op">}</span>(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb53-10" title="10"></a>
<a class="sourceLine" id="cb53-11" title="11"><span class="va">console</span>.<span class="at">log</span>(<span class="va">person</span>.<span class="at">getName</span>())<span class="op">;</span>      <span class="co">// &quot;Nicholas&quot;</span></a></code></pre></div>
<p>In this code, the IIFE is used to create an object with a <code>getName()</code> method. The method uses the <code>name</code> argument as the return value, effectively making <code>name</code> a private member of the returned object.</p>
<p>You can accomplish the same thing using arrow functions, so long as you wrap the arrow function in parentheses:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb54-1" title="1"><span class="kw">let</span> person <span class="op">=</span> ((name) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-2" title="2"></a>
<a class="sourceLine" id="cb54-3" title="3">    <span class="cf">return</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-4" title="4">        <span class="dt">getName</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb54-5" title="5">            <span class="cf">return</span> name<span class="op">;</span></a>
<a class="sourceLine" id="cb54-6" title="6">        <span class="op">}</span></a>
<a class="sourceLine" id="cb54-7" title="7">    <span class="op">};</span></a>
<a class="sourceLine" id="cb54-8" title="8"></a>
<a class="sourceLine" id="cb54-9" title="9"><span class="op">}</span>)(<span class="st">&quot;Nicholas&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb54-10" title="10"></a>
<a class="sourceLine" id="cb54-11" title="11"><span class="va">console</span>.<span class="at">log</span>(<span class="va">person</span>.<span class="at">getName</span>())<span class="op">;</span>      <span class="co">// &quot;Nicholas&quot;</span></a></code></pre></div>
<p>Note that the parentheses are only around the arrow function definition, and not around <code>("Nicholas")</code>. This is different from a formal function, where the parentheses can be placed outside of the passed-in parameters as well as just around the function definition.</p>
<h3 id="no-this-binding">No this Binding</h3>
<p>One of the most common areas of error in JavaScript is the binding of <code>this</code> inside of functions. Since the value of <code>this</code> can change inside a single function depending on the context in which the function is called, it’s possible to mistakenly affect one object when you meant to affect another. Consider the following example:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb55-1" title="1"><span class="kw">var</span> PageHandler <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb55-2" title="2"></a>
<a class="sourceLine" id="cb55-3" title="3">    <span class="dt">id</span><span class="op">:</span> <span class="st">&quot;123456&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb55-4" title="4"></a>
<a class="sourceLine" id="cb55-5" title="5">    <span class="dt">init</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb55-6" title="6">        <span class="va">document</span>.<span class="at">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">function</span>(event) <span class="op">{</span></a>
<a class="sourceLine" id="cb55-7" title="7">            <span class="kw">this</span>.<span class="at">doSomething</span>(<span class="va">event</span>.<span class="at">type</span>)<span class="op">;</span>     <span class="co">// error</span></a>
<a class="sourceLine" id="cb55-8" title="8">        <span class="op">},</span> <span class="kw">false</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb55-9" title="9">    <span class="op">},</span></a>
<a class="sourceLine" id="cb55-10" title="10"></a>
<a class="sourceLine" id="cb55-11" title="11">    <span class="dt">doSomething</span><span class="op">:</span> <span class="kw">function</span>(type) <span class="op">{</span></a>
<a class="sourceLine" id="cb55-12" title="12">        <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Handling &quot;</span> <span class="op">+</span> type  <span class="op">+</span> <span class="st">&quot; for &quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">id</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb55-13" title="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb55-14" title="14"><span class="op">};</span></a></code></pre></div>
<p>In this code, the object <code>PageHandler</code> is designed to handle interactions on the page. The <code>init()</code> method is called to set up the interactions, and that method in turn assigns an event handler to call <code>this.doSomething()</code>. However, this code doesn’t work exactly as intended.</p>
<p>The call to <code>this.doSomething()</code> is broken because <code>this</code> is a reference to the object that was the target of the event (in this case <code>document</code>), instead of being bound to <code>PageHandler</code>. If you tried to run this code, you’d get an error when the event handler fires because <code>this.doSomething()</code> doesn’t exist on the target <code>document</code> object.</p>
<p>You could fix this by binding the value of <code>this</code> to <code>PageHandler</code> explicitly using the <code>bind()</code> method on the function instead, like this:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb56-1" title="1"><span class="kw">var</span> PageHandler <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb56-2" title="2"></a>
<a class="sourceLine" id="cb56-3" title="3">    <span class="dt">id</span><span class="op">:</span> <span class="st">&quot;123456&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb56-4" title="4"></a>
<a class="sourceLine" id="cb56-5" title="5">    <span class="dt">init</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb56-6" title="6">        <span class="va">document</span>.<span class="at">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> (<span class="kw">function</span>(event) <span class="op">{</span></a>
<a class="sourceLine" id="cb56-7" title="7">            <span class="kw">this</span>.<span class="at">doSomething</span>(<span class="va">event</span>.<span class="at">type</span>)<span class="op">;</span>     <span class="co">// no error</span></a>
<a class="sourceLine" id="cb56-8" title="8">        <span class="op">}</span>).<span class="at">bind</span>(<span class="kw">this</span>)<span class="op">,</span> <span class="kw">false</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb56-9" title="9">    <span class="op">},</span></a>
<a class="sourceLine" id="cb56-10" title="10"></a>
<a class="sourceLine" id="cb56-11" title="11">    <span class="dt">doSomething</span><span class="op">:</span> <span class="kw">function</span>(type) <span class="op">{</span></a>
<a class="sourceLine" id="cb56-12" title="12">        <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Handling &quot;</span> <span class="op">+</span> type  <span class="op">+</span> <span class="st">&quot; for &quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">id</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb56-13" title="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb56-14" title="14"><span class="op">};</span></a></code></pre></div>
<p>Now the code works as expected, but it may look a little bit strange. By calling <code>bind(this)</code>, you’re actually creating a new function whose <code>this</code> is bound to the current <code>this</code>, which is <code>PageHandler</code>. To avoid creating an extra function, a better way to fix this code is to use an arrow function.</p>
<p>Arrow functions have no <code>this</code> binding, which means the value of <code>this</code> inside an arrow function can only be determined by looking up the scope chain. If the arrow function is contained within a nonarrow function, <code>this</code> will be the same as the containing function; otherwise, <code>this</code> is equivalent to the value of <code>this</code> in the global scope. Here’s one way you could write this code using an arrow function:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb57-1" title="1"><span class="kw">var</span> PageHandler <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb57-2" title="2"></a>
<a class="sourceLine" id="cb57-3" title="3">    <span class="dt">id</span><span class="op">:</span> <span class="st">&quot;123456&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb57-4" title="4"></a>
<a class="sourceLine" id="cb57-5" title="5">    <span class="dt">init</span><span class="op">:</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb57-6" title="6">        <span class="va">document</span>.<span class="at">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb57-7" title="7">                event <span class="kw">=&gt;</span> <span class="kw">this</span>.<span class="at">doSomething</span>(<span class="va">event</span>.<span class="at">type</span>)<span class="op">,</span> <span class="kw">false</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-8" title="8">    <span class="op">},</span></a>
<a class="sourceLine" id="cb57-9" title="9"></a>
<a class="sourceLine" id="cb57-10" title="10">    <span class="dt">doSomething</span><span class="op">:</span> <span class="kw">function</span>(type) <span class="op">{</span></a>
<a class="sourceLine" id="cb57-11" title="11">        <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Handling &quot;</span> <span class="op">+</span> type  <span class="op">+</span> <span class="st">&quot; for &quot;</span> <span class="op">+</span> <span class="kw">this</span>.<span class="at">id</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb57-12" title="12">    <span class="op">}</span></a>
<a class="sourceLine" id="cb57-13" title="13"><span class="op">};</span></a></code></pre></div>
<p>The event handler in this example is an arrow function that calls <code>this.doSomething()</code>. The value of <code>this</code> is the same as it is within <code>init()</code>, so this version of the code works similarly to the one using <code>bind(this)</code>. Even though the <code>doSomething()</code> method doesn’t return a value, it’s still the only statement executed in the function body, and so there is no need to include braces.</p>
<p>Arrow functions are designed to be “throwaway” functions, and so cannot be used to define new types; this is evident from the missing <code>prototype</code> property, which regular functions have. If you try to use the <code>new</code> operator with an arrow function, you’ll get an error, as in this example:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb58-1" title="1"><span class="kw">var</span> MyType <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{},</span></a>
<a class="sourceLine" id="cb58-2" title="2">    object <span class="op">=</span> <span class="kw">new</span> <span class="at">MyType</span>()<span class="op">;</span>  <span class="co">// error - you can&#39;t use arrow functions with &#39;new&#39;</span></a></code></pre></div>
<p>In this code, the call to <code>new MyType()</code> fails because <code>MyType</code> is an arrow function and therefore has no <code>[[Construct]]</code> behavior. Knowing that arrow functions cannot be used with <code>new</code> allows JavaScript engines to further optimize their behavior.</p>
<p>Also, since the <code>this</code> value is determined by the containing function in which the arrow function is defined, you cannot change the value of <code>this</code> using <code>call()</code>, <code>apply()</code>, or <code>bind()</code>.</p>
<h3 id="arrow-functions-and-arrays">Arrow Functions and Arrays</h3>
<p>The concise syntax for arrow functions makes them ideal for use with array processing, too. For example, if you want to sort an array using a custom comparator, you’d typically write something like this:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb59-1" title="1"><span class="kw">var</span> result <span class="op">=</span> <span class="va">values</span>.<span class="at">sort</span>(<span class="kw">function</span>(a<span class="op">,</span> b) <span class="op">{</span></a>
<a class="sourceLine" id="cb59-2" title="2">    <span class="cf">return</span> a <span class="op">-</span> b<span class="op">;</span></a>
<a class="sourceLine" id="cb59-3" title="3"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>That’s a lot of syntax for a very simple procedure. Compare that to the more terse arrow function version:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb60-1" title="1"><span class="kw">var</span> result <span class="op">=</span> <span class="va">values</span>.<span class="at">sort</span>((a<span class="op">,</span> b) <span class="kw">=&gt;</span> a <span class="op">-</span> b)<span class="op">;</span></a></code></pre></div>
<p>The array methods that accept callback functions such as <code>sort()</code>, <code>map()</code>, and <code>reduce()</code> can all benefit from simpler arrow function syntax, which changes seemingly complex processes into simpler code.</p>
<h3 id="no-arguments-binding">No arguments Binding</h3>
<p>Even though arrow functions don’t have their own <code>arguments</code> object, it’s possible for them to access the <code>arguments</code> object from a containing function. That <code>arguments</code> object is then available no matter where the arrow function is executed later on. For example:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb61-1" title="1"><span class="kw">function</span> <span class="at">createArrowFunctionReturningFirstArg</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb61-2" title="2">    <span class="cf">return</span> () <span class="kw">=&gt;</span> <span class="kw">arguments</span>[<span class="dv">0</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb61-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb61-4" title="4"></a>
<a class="sourceLine" id="cb61-5" title="5"><span class="kw">var</span> arrowFunction <span class="op">=</span> <span class="at">createArrowFunctionReturningFirstArg</span>(<span class="dv">5</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb61-6" title="6"></a>
<a class="sourceLine" id="cb61-7" title="7"><span class="va">console</span>.<span class="at">log</span>(<span class="at">arrowFunction</span>())<span class="op">;</span>       <span class="co">// 5</span></a></code></pre></div>
<p>Inside <code>createArrowFunctionReturningFirstArg()</code>, the <code>arguments[0]</code> element is referenced by the created arrow function. That reference contains the first argument passed to the <code>createArrowFunctionReturningFirstArg()</code> function. When the arrow function is later executed, it returns <code>5</code>, which was the first argument passed to <code>createArrowFunctionReturningFirstArg()</code>. Even though the arrow function is no longer in the scope of the function that created it, <code>arguments</code> remains accessible due to scope chain resolution of the <code>arguments</code> identifier.</p>
<h3 id="identifying-arrow-functions">Identifying Arrow Functions</h3>
<p>Despite the different syntax, arrow functions are still functions, and are identified as such. Consider the following code:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb62-1" title="1"><span class="kw">var</span> comparator <span class="op">=</span> (a<span class="op">,</span> b) <span class="kw">=&gt;</span> a <span class="op">-</span> b<span class="op">;</span></a>
<a class="sourceLine" id="cb62-2" title="2"></a>
<a class="sourceLine" id="cb62-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> comparator)<span class="op">;</span>                 <span class="co">// &quot;function&quot;</span></a>
<a class="sourceLine" id="cb62-4" title="4"><span class="va">console</span>.<span class="at">log</span>(comparator <span class="kw">instanceof</span> Function)<span class="op">;</span>    <span class="co">// true</span></a></code></pre></div>
<p>The <code>console.log()</code> output reveals that both <code>typeof</code> and <code>instanceof</code> behave the same with arrow functions as they do with other functions.</p>
<p>Also like other functions, you can still use <code>call()</code>, <code>apply()</code>, and <code>bind()</code> on arrow functions, although the <code>this</code>-binding of the function will not be affected. Here are some examples:</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb63-1" title="1"><span class="kw">var</span> sum <span class="op">=</span> (num1<span class="op">,</span> num2) <span class="kw">=&gt;</span> num1 <span class="op">+</span> num2<span class="op">;</span></a>
<a class="sourceLine" id="cb63-2" title="2"></a>
<a class="sourceLine" id="cb63-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="va">sum</span>.<span class="at">call</span>(<span class="kw">null</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>))<span class="op">;</span>      <span class="co">// 3</span></a>
<a class="sourceLine" id="cb63-4" title="4"><span class="va">console</span>.<span class="at">log</span>(<span class="va">sum</span>.<span class="at">apply</span>(<span class="kw">null</span><span class="op">,</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>]))<span class="op">;</span>   <span class="co">// 3</span></a>
<a class="sourceLine" id="cb63-5" title="5"></a>
<a class="sourceLine" id="cb63-6" title="6"><span class="kw">var</span> boundSum <span class="op">=</span> <span class="va">sum</span>.<span class="at">bind</span>(<span class="kw">null</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb63-7" title="7"></a>
<a class="sourceLine" id="cb63-8" title="8"><span class="va">console</span>.<span class="at">log</span>(<span class="at">boundSum</span>())<span class="op">;</span>                <span class="co">// 3</span></a></code></pre></div>
<p>The <code>sum()</code> function is called using <code>call()</code> and <code>apply()</code> to pass arguments, as you’d do with any function. The <code>bind()</code> method is used to create <code>boundSum()</code>, which has its two arguments bound to <code>1</code> and <code>2</code> so that they don’t need to be passed directly.</p>
<p>Arrow functions are appropriate to use anywhere you’re currently using an anonymous function expression, such as with callbacks. The next section covers another major ECMAScript 6 development, but this one is all internal, and has no new syntax.</p>
<h2 id="tail-call-optimization">Tail Call Optimization</h2>
<p>Perhaps the most interesting change to functions in ECMAScript 6 is an engine optimization, which changes the tail call system. A <em>tail call</em> is when a function is called as the last statement in another function, like this:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb64-1" title="1"><span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb64-2" title="2">    <span class="cf">return</span> <span class="at">doSomethingElse</span>()<span class="op">;</span>   <span class="co">// tail call</span></a>
<a class="sourceLine" id="cb64-3" title="3"><span class="op">}</span></a></code></pre></div>
<p>Tail calls as implemented in ECMAScript 5 engines are handled just like any other function call: a new stack frame is created and pushed onto the call stack to represent the function call. That means every previous stack frame is kept in memory, which is problematic when the call stack gets too large.</p>
<h3 id="whats-different">What’s Different?</h3>
<p>ECMAScript 6 seeks to reduce the size of the call stack for certain tail calls in strict mode (nonstrict mode tail calls are left untouched). With this optimization, instead of creating a new stack frame for a tail call, the current stack frame is cleared and reused so long as the following conditions are met:</p>
<ol type="1">
<li>The tail call does not require access to variables in the current stack frame (meaning the function is not a closure)</li>
<li>The function making the tail call has no further work to do after the tail call returns</li>
<li>The result of the tail call is returned as the function value</li>
</ol>
<p>As an example, this code can easily be optimized because it fits all three criteria:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb65-1" title="1"><span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb65-2" title="2"></a>
<a class="sourceLine" id="cb65-3" title="3"><span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb65-4" title="4">    <span class="co">// optimized</span></a>
<a class="sourceLine" id="cb65-5" title="5">    <span class="cf">return</span> <span class="at">doSomethingElse</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb65-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>This function makes a tail call to <code>doSomethingElse()</code>, returns the result immediately, and doesn’t access any variables in the local scope. One small change, not returning the result, results in an unoptimized function:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb66-1" title="1"><span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb66-2" title="2"></a>
<a class="sourceLine" id="cb66-3" title="3"><span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb66-4" title="4">    <span class="co">// not optimized - no return</span></a>
<a class="sourceLine" id="cb66-5" title="5">    <span class="at">doSomethingElse</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb66-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>Similarly, if you have a function that performs an operation after returning from the tail call, then the function can’t be optimized:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb67-1" title="1"><span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb67-2" title="2"></a>
<a class="sourceLine" id="cb67-3" title="3"><span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb67-4" title="4">    <span class="co">// not optimized - must add after returning</span></a>
<a class="sourceLine" id="cb67-5" title="5">    <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="at">doSomethingElse</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb67-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>This example adds the result of <code>doSomethingElse()</code> with 1 before returning the value, and that’s enough to turn off optimization.</p>
<p>Another common way to inadvertently turn off optimization is to store the result of a function call in a variable and then return the result, such as:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb68-1" title="1"><span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb68-2" title="2"></a>
<a class="sourceLine" id="cb68-3" title="3"><span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb68-4" title="4">    <span class="co">// not optimized - call isn&#39;t in tail position</span></a>
<a class="sourceLine" id="cb68-5" title="5">    <span class="kw">var</span> result <span class="op">=</span> <span class="at">doSomethingElse</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb68-6" title="6">    <span class="cf">return</span> result<span class="op">;</span></a>
<a class="sourceLine" id="cb68-7" title="7"><span class="op">}</span></a></code></pre></div>
<p>This example cannot be optimized because the value of <code>doSomethingElse()</code> isn’t immediately returned.</p>
<p>Perhaps the hardest situation to avoid is in using closures. Because a closure has access to variables in the containing scope, tail call optimization may be turned off. For example:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb69-1" title="1"><span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb69-2" title="2"></a>
<a class="sourceLine" id="cb69-3" title="3"><span class="kw">function</span> <span class="at">doSomething</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb69-4" title="4">    <span class="kw">var</span> num <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></a>
<a class="sourceLine" id="cb69-5" title="5">        func <span class="op">=</span> () <span class="kw">=&gt;</span> num<span class="op">;</span></a>
<a class="sourceLine" id="cb69-6" title="6"></a>
<a class="sourceLine" id="cb69-7" title="7">    <span class="co">// not optimized - function is a closure</span></a>
<a class="sourceLine" id="cb69-8" title="8">    <span class="cf">return</span> <span class="at">func</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb69-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>The closure <code>func()</code> has access to the local variable <code>num</code> in this example. Even though the call to <code>func()</code> immediately returns the result, optimization can’t occur due to referencing the variable <code>num</code>.</p>
<h3 id="how-to-harness-tail-call-optimization">How to Harness Tail Call Optimization</h3>
<p>In practice, tail call optimization happens behind-the-scenes, so you don’t need to think about it unless you’re trying to optimize a function. The primary use case for tail call optimization is in recursive functions, as that is where the optimization has the greatest effect. Consider this function, which computes factorials:</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb70-1" title="1"><span class="kw">function</span> <span class="at">factorial</span>(n) <span class="op">{</span></a>
<a class="sourceLine" id="cb70-2" title="2"></a>
<a class="sourceLine" id="cb70-3" title="3">    <span class="cf">if</span> (n <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb70-4" title="4">        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></a>
<a class="sourceLine" id="cb70-5" title="5">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb70-6" title="6"></a>
<a class="sourceLine" id="cb70-7" title="7">        <span class="co">// not optimized - must multiply after returning</span></a>
<a class="sourceLine" id="cb70-8" title="8">        <span class="cf">return</span> n <span class="op">*</span> <span class="at">factorial</span>(n <span class="op">-</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb70-9" title="9">    <span class="op">}</span></a>
<a class="sourceLine" id="cb70-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>This version of the function cannot be optimized, because multiplication must happen after the recursive call to <code>factorial()</code>. If <code>n</code> is a very large number, the call stack size will grow and could potentially cause a stack overflow.</p>
<p>In order to optimize the function, you need to ensure that the multiplication doesn’t happen after the last function call. To do this, you can use a default parameter to move the multiplication operation outside of the <code>return</code> statement. The resulting function carries along the temporary result into the next iteration, creating a function that behaves the same but <em>can</em> be optimized by an ECMAScript 6 engine. Here’s the new code:</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb71-1" title="1"><span class="kw">function</span> <span class="at">factorial</span>(n<span class="op">,</span> p <span class="op">=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb71-2" title="2"></a>
<a class="sourceLine" id="cb71-3" title="3">    <span class="cf">if</span> (n <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb71-4" title="4">        <span class="cf">return</span> <span class="dv">1</span> <span class="op">*</span> p<span class="op">;</span></a>
<a class="sourceLine" id="cb71-5" title="5">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb71-6" title="6">        <span class="kw">let</span> result <span class="op">=</span> n <span class="op">*</span> p<span class="op">;</span></a>
<a class="sourceLine" id="cb71-7" title="7"></a>
<a class="sourceLine" id="cb71-8" title="8">        <span class="co">// optimized</span></a>
<a class="sourceLine" id="cb71-9" title="9">        <span class="cf">return</span> <span class="at">factorial</span>(n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> result)<span class="op">;</span></a>
<a class="sourceLine" id="cb71-10" title="10">    <span class="op">}</span></a>
<a class="sourceLine" id="cb71-11" title="11"><span class="op">}</span></a></code></pre></div>
<p>In this rewritten version of <code>factorial()</code>, a second argument <code>p</code> is added as a parameter with a default value of 1. The <code>p</code> parameter holds the previous multiplication result so that the next result can be computed without another function call. When <code>n</code> is greater than 1, the multiplication is done first and then passed in as the second argument to <code>factorial()</code>. This allows the ECMAScript 6 engine to optimize the recursive call.</p>
<p>Tail call optimization is something you should think about whenever you’re writing a recursive function, as it can provide a significant performance improvement, especially when applied in a computationally-expensive function.</p>
<h2 id="summary">Summary</h2>
<p>Functions haven’t undergone a huge change in ECMAScript 6, but rather, a series of incremental changes that make them easier to work with.</p>
<p>Default function parameters allow you to easily specify what value to use when a particular argument isn’t passed. Prior to ECMAScript 6, this would require some extra code inside the function, to both check for the presence of arguments and assign a different value.</p>
<p>Rest parameters allow you to specify an array into which all remaining parameters should be placed. Using a real array and letting you indicate which parameters to include makes rest parameters a much more flexible solution than <code>arguments</code>.</p>
<p>The spread operator is a companion to rest parameters, allowing you to deconstruct an array into separate parameters when calling a function. Prior to ECMAScript 6, there were only two ways to pass individual parameters contained in an array: by manually specifying each parameter or using <code>apply()</code>. With the spread operator, you can easily pass an array to any function without worrying about the <code>this</code> binding of the function.</p>
<p>The addition of the <code>name</code> property should help you more easily identify functions for debugging and evaluation purposes. Additionally, ECMAScript 6 formally defines the behavior of block-level functions so they are no longer a syntax error in strict mode.</p>
<p>In ECMAScript 6, the behavior of a function is defined by <code>[[Call]]</code>, normal function execution, and <code>[[Construct]]</code>, when a function is called with <code>new</code>. The <code>new.target</code> metaproperty also allows you to determine if a function was called using <code>new</code> or not.</p>
<p>The biggest change to functions in ECMAScript 6 was the addition of arrow functions. Arrow functions are designed to be used in place of anonymous function expressions. Arrow functions have a more concise syntax, lexical <code>this</code> binding, and no <code>arguments</code> object. Additionally, arrow functions can’t change their <code>this</code> binding, and so can’t be used as constructors.</p>
<p>Tail call optimization allows some function calls to be optimized in order to keep a smaller call stack, use less memory, and prevent stack overflow errors. This optimization is applied by the engine automatically when it is safe to do so, however, you may decide to rewrite recursive functions in order to take advantage of this optimization.</p>
</body>
</html>
