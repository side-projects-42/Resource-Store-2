<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>HISTORY</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="base-change-history">Base Change History</h1>
<h2 id="section">3.5.0</h2>
<ul>
<li><p>Only invoke Base constructor logic once to support multi-inheritance scenario in which an extension passed to Base.create inherits from Base itself.</p>
<p>NOTE: To support multiple inhertiance more deeply, we’d need to remove the hasOwnProperty restriction around object key iteration.</p></li>
</ul>
<h2 id="section-1">3.4.1</h2>
<ul>
<li>No changes.</li>
</ul>
<h2 id="section-2">3.4.0</h2>
<ul>
<li><p>Base now destroys plugins before destroying itself</p></li>
<li><p>Base.create/mix extensions can now define initializer and destructor prototype functions, which will get invoked after the initializer for the host class into which they are mixed and before it’s destructor.</p></li>
<li><p>Use a hash version of whitelist mix for improved performance. Also removed non-required hasOwnProperty check and delete.</p></li>
</ul>
<h2 id="section-3">3.3.0</h2>
<ul>
<li><p>Fixed Base.mix when used on a class created using Base.create</p></li>
<li><p>toString no longer inadvertently stamps the object, however, we now stamp Base objects in the constructor, to support use cases where the “toString” stamping was implicitly being relied upon (e.g. in DD, as hashkeys).</p></li>
</ul>
<h2 id="section-4">3.2.0</h2>
<ul>
<li>Fixed Base.create to properly isolate ATTRS on extensions</li>
</ul>
<h2 id="section-5">3.1.1</h2>
<ul>
<li>No changes</li>
</ul>
<h2 id="section-6">3.1.0</h2>
<ul>
<li><p>As the final step in the destroy phase, Base now does a detachAll() to avoid invoking listeners which may be waiting to be in an async. step which occurs after destruction.</p></li>
<li><p>“init” and “destroy” events are now published with the defaultTargetOnly property set to true</p></li>
<li><p>Added support for MyClass.EVENT_PREFIX to allow developers to define their own event prefix</p></li>
<li><p>Made “init” and “destroy” events fireOnce:true (along with “render” in Widget), so that subscriptions made after the events are fired, are notified immediately.</p></li>
<li><p>Dynamic and non-dynamically built classes now have their extensions instantiated the same way - during _initHierarchy.</p></li>
<li><p>Updated ATTRS handling for Base.build, so that ATTRS are also aggregated at the attribute configuration object level, allowing extensions to add to, or overwrite, attribute configuration properties on the host.</p></li>
<li><p>Added sugar Base.create and Base.mix methods on top of Base.build, to simplify the 2 main use cases:</p>
<ol type="1">
<li>Creating a completely new class which uses extensions.</li>
<li>Mixing in extensions to an existing class.</li>
</ol></li>
<li><p>Documented non-attribute on, after, bubbleTargets and plugins property support in the Base constructor config argument</p></li>
</ul>
<h2 id="section-7">3.0.0</h2>
<ul>
<li><p>Fixed hasImpl method on built classes, to look up the class hierarchy for applied extensions.</p></li>
<li><p>Plugin.Host removed from base-base module and delivered as it’s own module - “pluginhost”</p></li>
<li><p>base broken up into..</p>
<p>base-base: Provides class hierarchy support for ATTRS and initialization</p>
<p>base-build: Provides Extension support in the form of Base.build</p>
<p>base-pluginhost: Augments Plugin.Host to Base, adding plugin support</p></li>
</ul>
<h2 id="beta-1">3.0.0 beta 1</h2>
<ul>
<li><p>Config argument for init event now merged into the event facade, instead of being passed separately (available as e.cfg).</p></li>
<li><p>Removed Base.create. On review, considered to be overkill. Users can easily create new instances, using Base.build</p></li>
<li><p>Moved PluginHost down from Widget to Base, since utils and Node will also support Plugins.</p></li>
<li><p>PluginHost.plug and unplug now accept the plugin class as arguments [plug(pluginClass, cfg) and unplug(pluginClass)].</p></li>
<li><p>Split base module up into base-base and base-build.</p></li>
<li><p>Added lazy attribute initialization support, to improve performance.</p>
<p>This also removes order dependency when processing ATTRS for a particular class.</p>
<p>If a get/set call is made for an uninitialized attribute A, in the getter/setter/validator or valueFns of another attribute B, A will be intiailized on the fly.</p></li>
<li><p>Added ability to subscribe to on/after events through the constructor config object, e.g.:</p>
<p>new MyBaseObject({ on: { init: handlerFn, myAttrChange: handlerFn }, after: { init: handlerFn, myAttrChange: handlerFn }, … });</p></li>
<li><p>Developers can now override the default clone behavior we use to isolate default ATTRS config values, using cloneDefaultValue, e.g.:</p>
<p>ATTRS = { myAttr : { value: AnObjectOrArrayReference cloneDefaultValue: true|false|“deep”|“shallow” } }</p>
<p>If the cloneDefaultValue property is not defined, Base will clone any Arrays or Object literals which are used as default values when configuring attributes for an instance, so that updates to instance values do not modify the default value.</p>
<p>This behavior can be over-ridden using the cloneDefaultValue property:</p>
<p>true, deep:</p>
<p>Use Y.clone to protect the default value.</p>
<p>shallow:</p>
<p>Use Y.merge, to protect the default value.</p>
<p>false:</p>
<p>Don’t clone Arrays or Object literals. The value is intended to be used by reference, for example, when it points to a utility object.</p></li>
<li><p>Base.plug and Base.unplug used to add static Plugins (default plugins for a class). Replaces static PLUGINS array, allowing subclasses to easily unplug static plugins added higher up in the hierarchy.</p></li>
<li><p>Base adds all attributes lazily. This means attributes don’t get initialized until the first call to get/set, speeding up construction of Base based objects.</p>
<p>Attributes which have setters which set some other state in the object, can configure the attribute to disable lazy initialization, by setting lazyAdd:false as part of their attribute configuration, so that the setter gets invoked during construction.</p></li>
</ul>
<h2 id="pr1---initial-release">3.0.0PR1 - Initial release</h2>
</body>
</html>
