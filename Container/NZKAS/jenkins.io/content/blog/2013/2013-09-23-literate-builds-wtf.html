<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>2013-09-23-literate-builds-wtf</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <p>(This is a guest post by Stephen Connolly)</p>
    <p>
      Every developer, at some stage, will be handed a project to maintain that
      somebody else was responsible for. If you are lucky, the developer will
      not have left the organization yet and you get a brief Knowledge Transfer
      as the developer packs up their desk before heading on to their new job.
      If you are unlucky, you don’t even get given the details of where the
      source code is hiding.
    </p>
    <p>
      Now begins the detective work, as you try to figure out how to build and
      release the project, set up Jenkins jobs to build the project and run the
      tests…
    </p>
    <p>It doesn’t have to be this way, you know!</p>
    <p>
      What if I told you there was a file sitting at the top level that told you
      exactly how to build the project and do the important things? You’d be
      interested, wouldn’t you?
    </p>
    <p>
      When I tell you it’s the README file? “But that’s all lies. Nobody keeps
      that up to date. Argh!!!”
    </p>
    <p>
      But what if Jenkins reads the README file and uses it for the build
      definition? Now you not only have a CI system ensuring that the build
      definition is correct, but you have less work to do setting up the job.
    </p>
    <p>
      What if, because the build definition is now in Source Control, you can
      have Jenkins create jobs for each branch with ease? The joy of cheap
      branches that modern source control systems such as GIT and Mercurial give
      us, no longer comes with the pain of having to create Jenkins jobs for
      each branch (and more pain having to remember to tidy up when the branch
      is gone.)
    </p>
    <p>
      That is the promise delivered by the
      <a href="https://wiki.jenkins-ci.org/display/JENKINS/Literate+Plugin"
        >Literate plugin</a
      >.
    </p>
    <h2 id="how-does-it-work">How does it work?</h2>
    <p>
      First of all, because Jenkins will be looking at all your branches, you
      need a way to tell Jenkins which branches it makes sense to try and build.
      For example, if your project lives on GitHub, you are unlikely to want the
      <code>gh-pages</code> branch to be treated like a branch of your actual
      code, and there are going to be branches that have a README file, but not
      one that Jenkins understands, so we will want to ignore them too.
    </p>
    <p>
      You tell Jenkins that a branch is one to build by putting a marker file in
      the root of the branch. By default the marker file is called
      <code>.cloudbees.md</code>. If the marker file is present and empty, then
      the literate job type will assume the build instructions are in
      <code>README.md</code>. If the marker file is present and has build
      instructions, then the literate job type will just use those instructions.
    </p>
    <p>
      In order to make it easy to provide the instructions, there is rather
      minimal formatting requirements for a literate description of a project’s
      build commands.
    </p>
    <p>
      The minimal description is just a section with the word
      <code>build</code> and a verbatim code block in that section. Here is the
      obligatory minimal “hello world” project description:
    </p>
    <pre><code># Build

    echo hello world</code></pre>
    <p>
      or if you don’t like indenting you could use the GitHub style
      triple-back-tick
    </p>
    <pre><code># Build

```
echo hello world
```</code></pre>
    <p>
      Part of what makes this a
      <a href="http://en.wikipedia.org/wiki/Literate_programming"
        >literate style</a
      >
      of build description is that you can freely intersperse the description of
      what and why the commands do with the actual commands, e.g.
    </p>
    <pre><code># Build

We will greet the world with our great literate project description

    echo -n &quot;Hello&quot;

Now that we have announced our intention to greet some people, we need to qualify exactly who we are greeting

    echo &quot; world&quot;

That was just perfect. Time for a cup of tea</code></pre>
    <p>
      The first section heading containing the word
      <code>build</code> identifies the section that is assumed to be the build
      instructions. (The keyword that is searched for is configurable, but not
      yet exposed in the literate plugin’s UI). The following is also a valid
      <code>README.md</code> for printing hello world:
    </p>
    <pre><code>Our super hello world project
=============================

This is a project to say hello to the world

How to build
------------

You can build this project by running the following command:

    echo hello world

Credits
-------

This project would not have been possible without the existence of Assam loose leaf tea.</code></pre>
    <p>
      Now this is all very well, but what about if you need different
      instructions for building on Windows versus on Linux, and for that matter
      how does Jenkins know where we should build this project. Plus Mr Joe
      Random needs to know what he needs to install on his machine to build it
      for himself.
    </p>
    <p>
      The first section containing the word <code>environment</code> identifies
      the section that contains the details of the environments to run the build
      on.
    </p>
    <pre><code>Hello world project
===================

This is a simple hello world literate project

Environment requirements
------------------------

The project is built and tested by Jenkins on the following build environments, so it is known that the build instructions work on the following environments:

* `windows`
* `linux`

How to build
------------

The build instructions are platform dependent:

* On `windows`:

        echo &quot;hello world&quot;

* On `linux`:

        echo hello\ world</code></pre>
    <p>
      When Jenkins sees bullet points in the <code>environment</code> section it
      assumes each bullet point corresponds to an environment to run the build
      on. Each environment is specified by at least one code snippet which helps
      define the requirements of the environment. By default Jenkins will look
      for tool installers with the same name as the labels. If it cannot find
      any matching tool installers it assumes that the labels are Jenkins slave
      node labels. (The strategy is plugable, but not yet exposed in the UI of
      literate builds)
    </p>
    <p>
      When you have multiple environments on which to build and test, you have
      two choices on your build instructions. You can either:
    </p>
    <ul>
      <li>
        Have one and only one set of commands that work on all environments; or
      </li>
      <li>Have bullet points that cover all the specified environments.</li>
    </ul>
    <p>So for example, if you are building on the following environments:</p>
    <ul>
      <li><code>windows</code>, <code>java-1.6</code>, <code>ant-1.7</code></li>
      <li><code>windows</code>, <code>java-1.6</code>, <code>ant-1.8</code></li>
      <li><code>windows</code>, <code>java-1.7</code>, <code>ant-1.8</code></li>
      <li><code>linux</code>, <code>java-1.7</code>, <code>ant-1.7</code></li>
      <li><code>linux</code>, <code>java-1.7</code>, <code>ant-1.8</code></li>
    </ul>
    <p>
      You need to have bullet points in your <code>build</code> section that can
      match each of those options, but as long as there is a match for every
      option you are ok. So for example:
    </p>
    <pre><code>ANT version finder
==================

Finding out the version of ANT on various platforms

Environments
------------

Nesting bullet points multiplies out the options

* `windows`
    * `java-1.6`
        * `ant-1.6`
        * `ant-1.7`
    * `java-1.7`, `ant-1.8`
* `linux`, `java-1.7`
    * `ant-1.7`
    * `ant-1.8`

Build
-----

The first match with the highest number of matches wins, so we want windows to get special treatment:

* `windows`

        call ant.bat -version

* `java-1.7`

        ant -version

We could have picked `linux` for the above if we wanted, but this matching will have the same effect and better illustrates how matching works.</code></pre>
    <p>
      That is a mostly complete detail of how the <code>build</code> and
      <code>environment</code> sections work. In general everything except
      verbatim code blocks and bullet points with code snippets get ignored.
    </p>
    <p>
      There are other sections that the literate project type allows for, these
      are called “task” sections. We haven’t written the code to support them
      yet, but the idea is that these will work a bit like basic build
      promotions with the promoted builds plugin. There will be a UI in Jenkins
      that lets you kick off any of the task sections that you define as being
      valid for the job type, in pretty much exactly the same was as the
      promoted builds plugin works.
    </p>
    <p>After that, everything else in the <code>README.md</code> is ignored.</p>
    <h2 id="how-do-i-get-the-test-results-into-jenkins">
      How do I get the test results into Jenkins?
    </h2>
    <p>
      Jenkins is not just about build and test. A lot of the utility in Jenkins
      comes from the additional reporting plugins that are available for
      Jenkins. (The build step ones are less relevant with literate style
      projects because you want to give people consuming the content
      instructions they can also follow)
    </p>
    <p>
      So there is additional metadata about your project that you want to give
      to Jenkins. We put that metadata into a folder called
      <code>.jenkins</code> in the root of your source control.
    </p>
    <p>
      There are two levels of integration that a Publisher/Notifier can have
      with the literate project type. The first level is a basic XML description
      of the plugin configuration. If you have ever looked at the
      <code>config.xml</code> of a Jenkins job, you will be familiar with this
      format.
    </p>
    <p>
      If we have a Maven project and we want to collect the Unit test results in
      Jenkins we might have a <code>README.md</code> like this:
    </p>
    <pre><code>Maven project with tests
========================

Environments
------------

* `java-1.7`, `maven-3.0.5`

Build
-----

```
mvn clean verify
```</code></pre>
    <p>
      And then we create a
      <code>.jenkins/hudson.tasks.junit.JUnitResultArchiver.xml</code> file with
      the following:
    </p>
    <pre><code>&lt;hudson.tasks.junit.JUnitResultArchiver&gt;
  &lt;testResults&gt;**/target/surefire-reports/*.xml, **/target/failsafe-reports/*.xml&lt;/testResults&gt;
  &lt;keepLongStdio&gt;true&lt;/keepLongStdio&gt;
  &lt;testDataPublishers/&gt;
&lt;/hudson.tasks.junit.JUnitResultArchiver&gt;</code></pre>
    <p>
      The literate plugin adds an Action to all Free-style projects that allows
      exporting these XML configuration snippets in a <code>.zip</code> file for
      unpacking into your project’s source control. Each publisher/notifier has
      its own file, so it should be easy to mix and match configuration across
      different projects and enable/disable specific publishers just by
      adding/removing each publisher’s file.
    </p>
    <p>
      The XML itself can be a bit ugly, so there is a second level integration,
      where a Publisher/Notifier plugin can implement its own DSL. The literate
      plugin ships with two such DSLs. One for archiving artifacts and the other
      for JUnit test results. So the above XML file could be replaced by a
      <code>.jenkins/junit.lst</code> file with the following contents
    </p>
    <pre><code>**/target/surefire-reports/*.xml
**/target/failsafe-reports/*.xml</code></pre>
    <h2 id="not-everything-makes-sense-in-source-control-though">
      Not everything makes sense in source control though…
    </h2>
    <p>
      There are always going to be things that you need to configure in Jenkins.
      So for example there may be some sources of branches that you don’t trust.
      A good example would be pull requests on GitHub. We have a concept of
      branch properties in the literate project type that will allow defining
      what exactly a trusted branch source should be allowed do and what an
      untrusted branch source should be allowed do. It does not make sense for
      that information to be embedded within the untrusted branch itself.
    </p>
    <p>
      Similarly coordination between different Jenkins projects is something
      that does not make sense in source control. The names of those Jenkins
      projects (and even their existence) is not knowable from source control.
      It does not make sense to keep that information in source control.
    </p>
    <p>
      Information about how to map the description of the build environment in
      the <code>README.md</code> file to the build environments available to
      Jenkins does not make sense in source control because your Jenkins node
      configuration details may change over time.
    </p>
    <p>
      In other words, literate projects do not remove the need to configure
      things in Jenkins. They do however remove a lot of the need, and
      especially the need to tweak the exact build commands and the location of
      where build results should be picked up from.
    </p>
    <h2 id="whats-not-done-yet">What’s not done yet?</h2>
    <p>Here is a list of some things I want to see for literate builds:</p>
    <ul>
      <li>
        A literate build step so that people can use some of the literate magic
        in their free-style projects while they migrate them to literate-style
      </li>
      <li>
        Support for literate task promotion flows (I think Kohsuke has signed up
        to help deliver this)
      </li>
      <li>
        Exposing the configuration points such as the marker file name (a global
        config option as well as per-project override) and the keywords to
        search for in the <code>README.md</code> (this is mostly UI work)
      </li>
      <li>
        Adding in some support for other markup languages (I’d really like to
        see AsciiDoc formatted README parsing, e.g. <code>README.asc</code>)
      </li>
      <li>
        Branch properties for untrusted builds (to do things like restrict the
        build execution to one explicit environment, put an elastic build
        timeout in place, wrap the shell commands in a chroot jail, etc)
      </li>
      <li>
        Branch properties for build secrets (So that the
        <code>production</code> and <code>staging</code> branches can get the
        keys to deploy into their respective environments.
      </li>
      <li>
        Collapsing the intermediate level in the UI when there is only one build
        environment.
      </li>
      <li>
        Eliminating the double SCM checkout when the backing SCM supports the
        <code>SCMFileSystem</code> API so that builds work even faster
      </li>
      <li>Reusing the GIT repository cache when using GIT branch sources.</li>
      <li>
        Some nicer integration with GitHub (I have most of this done, but I
        think it would be irresponsible to release this without having the
        Untrusted branch properties implemented as otherwise Pull Requests could
        become a vector for abuse)
      </li>
      <li>
        Finishing the support for Subversion credentials migration from the
        legacy credentials storage mechanism to the new Credentials plugin
        storage mechanism (not strictly literate project related, but Subversion
        is still a popular SCM and until this gets done we cannot release a
        version of the Subversion plugin with literate project support)
      </li>
      <li>Adding nice DSLs for all the Publishers and Notifiers</li>
      <li>Adding SCM support to all the SCM plugins</li>
      <li>
        Adding branch property support for the Build Wrapper / Build Environment
        / Job Property plugins where that makes sense.
      </li>
    </ul>
    <p>
      Having said all that, the core functionality works right now for
      GIT/Subversion/Mercurial on Jenkins 1.509+, and it is only by playing with
      this functionality that you can see how this could change the way you use
      Jenkins.
    </p>
    <h2 id="how-do-i-try-this-out-myself">How do I try this out myself</h2>
    <p>
      Last week Kohsuke set up a new “Experimental” update center in Jenkins
      OSS. The reason for this new update center is that we have a lot of
      (potentially disruptive) changes to many plugins and if we started cutting
      releases, users may get annoyed if they end up upgrading to these plugins
      until they have all been better tested.
    </p>
    <p>
      The “Experimental” update center includes plugins that have
      <code>alpha</code> or <code>beta</code> in their version number, while the
      other update centers now exclude those plugin versions.
    </p>
    <p>
      So if you want to play with these plugins you need to change your Jenkins
      instance’s update center URI to:
    </p>
    <pre><code>http://updates.jenkins-ci.org/experimental/update-center.json</code></pre>
    <p>
      I would recommend that you use a test Jenkins instance for playing with.
    </p>
    <p>
      (WARNING: shameless plug) You could also just fire up a Jenkins in the
      cloud using CloudBee’s DEV@cloud service and follow
      <a
        href="http://developer-blog.cloudbees.com/2013/09/how-to-try-literate-builds-on-devcloud.html"
        >these handy instructions</a
      >
      to enable access to the experimental plugins:
    </p>
    <p>
      The 10 best bug reports on literate builds before the Jenkins User
      Conference next month will receive a prise from CloudBees, Inc. I was able
      to get a commitment that the prise would be at least a T-shirt. I am
      hoping to get some more swag added to the prize pool. CloudBees employees
      or relatives of CloudBees employees are not eligible for the bug report
      prise!
    </p>
  </body>
</html>
