<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>2011-08-08-jruby-branch-merged</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <p>
      <img
        src="http://agentdero.cachefly.net/continuousblog/jruby.png"
        align="right"
        width="150"
      />
      Yesterday, <a href="http://twitter.com/kohsukekawa">Kohsuke</a>
      <a href="http://groups.google.com/group/jenkinsrb/msg/32815b1ea917355d"
        >announced</a
      >
      that the ‘jruby’ branch of jenkins-core had been
      <a
        href="https://github.com/jenkinsci/jenkins/commit/f6373f7ada14a7914f4ae08b6af4c1b27d343c21"
        >merged to master</a
      >.
    </p>
    <p>
      This doesn’t mean that we’re done and that you can go forth and write pure
      ruby plugins… not by any stretch of the imagination. Instead, what it
      <em>does</em> mean, is that the Jenkins mainline is much more friendly to
      runtime analysis of classes with which it is not familiar.
    </p>
    <h2 id="the-problem">The problem</h2>
    <p>
      When analyzing plugin classes, Jenkins uses just about every kind of
      metadata you can think of to get information about them: Class name, Field
      names, method names, member modifiers, annotations, you name it. It even
      uses the containing class relationship for inner classes to match
      Descriptors with what they describe.
    </p>
    <p>
      It’s all a great example of convention over configuration (CoC). In fact,
      I’ve never really seen CoC implemented in a Java project before as
      successfully as it has been in Jenkins. Plugin authors don’t have to
      duplicate any metadata that Jenkins can figure out for you – and it’s
      alot! The drawback though, is that extensions depend very heavily on
      conforming to the structure of a conventional Java class.
    </p>
    <p>
      The changes in this merge, and in several of the modules on which Jenkins
      depends, allow more than ever to get this information by asking an object
      directly rather than querying its private class structure.
    </p>
    <h2 id="the-kicker">The Kicker</h2>
    <p>
      Many of theses changes aren’t even JRuby specific! While they do enable
      JRuby integration, They’re really just making things more friendly for
      dynamic languages in general. So, in theory, it should pave the way for
      others like JavaScript and Python.
    </p>
    <h2 id="where-now">Where now?</h2>
    <p>
      We’re still working on the ruby runtime and tools which will provide as
      crisp a Ruby development experience as we can. I don’t want to proffer an
      estimate of when those will begin to be useable, but it is important to
      mark this very important milestone and explain what it does and does not
      mean.
    </p>
    <h3 id="we-need-you">We need you!</h3>
    <p>
      There is still much work to be done to enable a writing Jenkins plugins in
      Ruby, we are looking for people who know Ruby and feel like pitching in:
      writing Rake tasks, improving the glue layer, documentation, etc.
    </p>
    <p>
      If you’re interested, most of the action is happening on the
      <a href="http://groups.google.com/group/jenkinsrb"
        >jenkinsrb@googlegroups.com</a
      >
      mailing list, so join us!
    </p>
    <hr />
    <!--break-->
  </body>
</html>
