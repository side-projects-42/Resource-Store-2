<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>README</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="acorn">Acorn</h1>
    <p>
      <a href="https://travis-ci.org/ternjs/acorn"
        ><img
          src="https://travis-ci.org/ternjs/acorn.svg?branch=master"
          alt="Build Status"
      /></a>
      <a href="https://www.npmjs.com/package/acorn"
        ><img
          src="https://img.shields.io/npm/v/acorn.svg"
          alt="NPM version" /></a
      ><br />
      <a href="https://marijnhaverbeke.nl/fund/"
        >Author funding status:
        <img
          src="https://marijnhaverbeke.nl/fund/status_s.png?force"
          alt="maintainer happiness"
      /></a>
    </p>
    <p>A tiny, fast JavaScript parser, written completely in JavaScript.</p>
    <h2 id="community">Community</h2>
    <p>
      Acorn is open source software released under an
      <a href="https://github.com/ternjs/acorn/blob/master/LICENSE"
        >MIT license</a
      >.
    </p>
    <p>
      You are welcome to
      <a href="https://github.com/ternjs/acorn/issues">report bugs</a> or create
      pull requests on <a href="https://github.com/ternjs/acorn">github</a>. For
      questions and discussion, please use the
      <a href="https://discuss.ternjs.net">Tern discussion forum</a>.
    </p>
    <h2 id="installation">Installation</h2>
    <p>
      The easiest way to install acorn is with
      <a href="https://www.npmjs.com/"><code>npm</code></a
      >.
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode sh"
      ><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="ex">npm</span> install acorn</a></code></pre>
    </div>
    <p>Alternately, download the source.</p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode sh"
      ><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">git</span> clone https://github.com/ternjs/acorn.git</a></code></pre>
    </div>
    <h2 id="components">Components</h2>
    <p>
      When run in a CommonJS (node.js) or AMD environment, exported values
      appear in the interfaces exposed by the individual files, as usual. When
      loaded in the browser (Acorn works in any JS-enabled browser more recent
      than IE5) without any kind of module management, a single global object
      <code>acorn</code> will be defined, and all the exported properties will
      be added to that.
    </p>
    <h3 id="main-parser">Main parser</h3>
    <p>
      This is implemented in <code>dist/acorn.js</code>, and is what you get
      when you <code>require("acorn")</code> in node.js.
    </p>
    <p>
      <strong>parse</strong><code>(input, options)</code> is used to parse a
      JavaScript program. The <code>input</code> parameter is a string,
      <code>options</code> can be undefined or an object setting some of the
      options listed below. The return value will be an abstract syntax tree
      object as specified by the
      <a href="https://github.com/estree/estree">ESTree spec</a>.
    </p>
    <p>
      When encountering a syntax error, the parser will raise a
      <code>SyntaxError</code> object with a meaningful message. The error
      object will have a <code>pos</code> property that indicates the character
      offset at which the error occurred, and a <code>loc</code> object that
      contains a <code>{line, column}</code> object referring to that same
      position.
    </p>
    <ul>
      <li>
        <p>
          <strong>ecmaVersion</strong>: Indicates the ECMAScript version to
          parse. Must be either 3, 5, 6, or 7. This influences support for
          strict mode, the set of reserved words, and support for new syntax
          features. Default is 6.
        </p>
        <p>
          <strong>NOTE</strong>: Only ‘stage 4’ (finalized) ECMAScript 7
          features are being implemented by Acorn. That means that most of the
          draft standard is not yet being parsed.
        </p>
      </li>
      <li>
        <p>
          <strong>sourceType</strong>: Indicate the mode the code should be
          parsed in. Can be either <code>"script"</code> or
          <code>"module"</code>.
        </p>
      </li>
      <li>
        <p>
          <strong>onInsertedSemicolon</strong>: If given a callback, that
          callback will be called whenever a missing semicolon is inserted by
          the parser. The callback will be given the character offset of the
          point where the semicolon is inserted as argument, and if
          <code>locations</code> is on, also a
          <code>{line, column}</code> object representing this position.
        </p>
      </li>
      <li>
        <p>
          <strong>onTrailingComma</strong>: Like
          <code>onInsertedSemicolon</code>, but for trailing commas.
        </p>
      </li>
      <li>
        <p>
          <strong>allowReserved</strong>: If <code>false</code>, using a
          reserved word will generate an error. Defaults to
          <code>true</code> for <code>ecmaVersion</code> 3,
          <code>false</code> for higher versions. When given the value
          <code>"never"</code>, reserved words and keywords can also not be used
          as property names (as in Internet Explorer’s old parser).
        </p>
      </li>
      <li>
        <p>
          <strong>allowReturnOutsideFunction</strong>: By default, a return
          statement at the top level raises an error. Set this to
          <code>true</code> to accept such code.
        </p>
      </li>
      <li>
        <p>
          <strong>allowImportExportEverywhere</strong>: By default,
          <code>import</code> and <code>export</code> declarations can only
          appear at a program’s top level. Setting this option to
          <code>true</code> allows them anywhere where a statement is allowed.
        </p>
      </li>
      <li>
        <p>
          <strong>allowHashBang</strong>: When this is enabled (off by default),
          if the code starts with the characters <code>#!</code> (as in a
          shellscript), the first line will be treated as a comment.
        </p>
      </li>
      <li>
        <p>
          <strong>locations</strong>: When <code>true</code>, each node has a
          <code>loc</code> object attached with <code>start</code> and
          <code>end</code> subobjects, each of which contains the one-based line
          and zero-based column numbers in <code>{line, column}</code> form.
          Default is <code>false</code>.
        </p>
      </li>
      <li>
        <p>
          <strong>onToken</strong>: If a function is passed for this option,
          each found token will be passed in same format as tokens returned from
          <code>tokenizer().getToken()</code>.
        </p>
        <p>If array is passed, each found token is pushed to it.</p>
        <p>
          Note that you are not allowed to call the parser from the
          callback—that will corrupt its internal state.
        </p>
      </li>
      <li>
        <p>
          <strong>onComment</strong>: If a function is passed for this option,
          whenever a comment is encountered the function will be called with the
          following parameters:
        </p>
        <ul>
          <li>
            <code>block</code>: <code>true</code> if the comment is a block
            comment, false if it is a line comment.
          </li>
          <li><code>text</code>: The content of the comment.</li>
          <li>
            <code>start</code>: Character offset of the start of the comment.
          </li>
          <li><code>end</code>: Character offset of the end of the comment.</li>
        </ul>
        <p>
          When the <code>locations</code> options is on, the
          <code>{line, column}</code> locations of the comment’s start and end
          are passed as two additional parameters.
        </p>
        <p>
          If array is passed for this option, each found comment is pushed to it
          as object in Esprima format:
        </p>
        <div class="sourceCode" id="cb3">
          <pre
            class="sourceCode javascript"
          ><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="st">&quot;type&quot;</span><span class="op">:</span> <span class="st">&quot;Line&quot;</span> <span class="op">|</span> <span class="st">&quot;Block&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="st">&quot;value&quot;</span><span class="op">:</span> <span class="st">&quot;comment text&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="st">&quot;start&quot;</span><span class="op">:</span> Number<span class="op">,</span></a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="st">&quot;end&quot;</span><span class="op">:</span> Number<span class="op">,</span></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="co">// If `locations` option is on:</span></a>
<a class="sourceLine" id="cb3-7" title="7">  <span class="st">&quot;loc&quot;</span><span class="op">:</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="st">&quot;start&quot;</span><span class="op">:</span> <span class="op">{</span><span class="dt">line</span><span class="op">:</span> Number<span class="op">,</span> <span class="dt">column</span><span class="op">:</span> Number<span class="op">}</span></a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="st">&quot;end&quot;</span><span class="op">:</span> <span class="op">{</span><span class="dt">line</span><span class="op">:</span> Number<span class="op">,</span> <span class="dt">column</span><span class="op">:</span> Number<span class="op">}</span></a>
<a class="sourceLine" id="cb3-10" title="10">  <span class="op">},</span></a>
<a class="sourceLine" id="cb3-11" title="11">  <span class="co">// If `ranges` option is on:</span></a>
<a class="sourceLine" id="cb3-12" title="12">  <span class="st">&quot;range&quot;</span><span class="op">:</span> [Number<span class="op">,</span> Number]</a>
<a class="sourceLine" id="cb3-13" title="13"><span class="op">}</span></a></code></pre>
        </div>
        <p>
          Note that you are not allowed to call the parser from the
          callback—that will corrupt its internal state.
        </p>
      </li>
      <li>
        <p>
          <strong>ranges</strong>: Nodes have their start and end characters
          offsets recorded in <code>start</code> and <code>end</code> properties
          (directly on the node, rather than the <code>loc</code> object, which
          holds line/column data. To also add a
          <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=745678"
            >semi-standardized</a
          >
          <code>range</code> property holding a <code>[start, end]</code> array
          with the same numbers, set the <code>ranges</code> option to
          <code>true</code>.
        </p>
      </li>
      <li>
        <p>
          <strong>program</strong>: It is possible to parse multiple files into
          a single AST by passing the tree produced by parsing the first file as
          the <code>program</code> option in subsequent parses. This will add
          the toplevel forms of the parsed file to the “Program” (top) node of
          an existing parse tree.
        </p>
      </li>
      <li>
        <p>
          <strong>sourceFile</strong>: When the <code>locations</code> option is
          <code>true</code>, you can pass this option to add a
          <code>source</code> attribute in every node’s <code>loc</code> object.
          Note that the contents of this option are not examined or processed in
          any way; you are free to use whatever format you choose.
        </p>
      </li>
      <li>
        <p>
          <strong>directSourceFile</strong>: Like <code>sourceFile</code>, but a
          <code>sourceFile</code> property will be added (regardless of the
          <code>location</code> option) directly to the nodes, rather than the
          <code>loc</code> object.
        </p>
      </li>
      <li>
        <p>
          <strong>preserveParens</strong>: If this option is <code>true</code>,
          parenthesized expressions are represented by (non-standard)
          <code>ParenthesizedExpression</code> nodes that have a single
          <code>expression</code> property containing the expression inside
          parentheses.
        </p>
      </li>
    </ul>
    <p>
      <strong>parseExpressionAt</strong
      ><code>(input, offset, options)</code> will parse a single expression in a
      string, and return its AST. It will not complain if there is more of the
      string left after the expression.
    </p>
    <p>
      <strong>getLineInfo</strong><code>(input, offset)</code> can be used to
      get a <code>{line, column}</code> object for a given program string and
      character offset.
    </p>
    <p>
      <strong>tokenizer</strong><code>(input, options)</code> returns an object
      with a <code>getToken</code> method that can be called repeatedly to get
      the next token, a <code>{start, end, type, value}</code> object (with
      added <code>loc</code> property when the <code>locations</code> option is
      enabled and <code>range</code> property when the
      <code>ranges</code> option is enabled). When the token’s type is
      <code>tokTypes.eof</code>, you should stop calling the method, since it
      will keep returning that same token forever.
    </p>
    <p>
      In ES6 environment, returned result can be used as any other
      protocol-compliant iterable:
    </p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode javascript"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="cf">for</span> (<span class="kw">let</span> token <span class="kw">of</span> <span class="va">acorn</span>.<span class="at">tokenizer</span>(str)) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="co">// iterate over the tokens</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb4-4" title="4"></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co">// transform code to array of tokens:</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="kw">var</span> tokens <span class="op">=</span> [...<span class="va">acorn</span>.<span class="at">tokenizer</span>(str)]<span class="op">;</span></a></code></pre>
    </div>
    <p>
      <strong>tokTypes</strong> holds an object mapping names to the token type
      objects that end up in the <code>type</code> properties of tokens.
    </p>
    <h4 id="note-on-using-with-escodegenescodegen">
      Note on using with
      <a href="https://github.com/estools/escodegen">Escodegen</a>
    </h4>
    <p>
      Escodegen supports generating comments from AST, attached in
      Esprima-specific format. In order to simulate same format in Acorn,
      consider following example:
    </p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode javascript"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">var</span> comments <span class="op">=</span> []<span class="op">,</span></a>
<a class="sourceLine" id="cb5-2" title="2">  tokens <span class="op">=</span> []<span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">var</span> ast <span class="op">=</span> <span class="va">acorn</span>.<span class="at">parse</span>(<span class="st">&quot;var x = 42; // answer&quot;</span><span class="op">,</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="co">// collect ranges for each node</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="dt">ranges</span><span class="op">:</span> <span class="kw">true</span><span class="op">,</span></a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="co">// collect comments in Esprima&#39;s format</span></a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="dt">onComment</span><span class="op">:</span> comments<span class="op">,</span></a>
<a class="sourceLine" id="cb5-9" title="9">  <span class="co">// collect token ranges</span></a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="dt">onToken</span><span class="op">:</span> tokens<span class="op">,</span></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="co">// attach comments using collected information</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="va">escodegen</span>.<span class="at">attachComments</span>(ast<span class="op">,</span> comments<span class="op">,</span> tokens)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-15" title="15"></a>
<a class="sourceLine" id="cb5-16" title="16"><span class="co">// generate code</span></a>
<a class="sourceLine" id="cb5-17" title="17"><span class="va">console</span>.<span class="at">log</span>(<span class="va">escodegen</span>.<span class="at">generate</span>(ast<span class="op">,</span> <span class="op">{</span> <span class="dt">comment</span><span class="op">:</span> <span class="kw">true</span> <span class="op">}</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb5-18" title="18"><span class="co">// &gt; &#39;var x = 42;    // answer&#39;</span></a></code></pre>
    </div>
    <h3 id="distacorn_loose.js">dist/acorn_loose.js</h3>
    <p>
      This file implements an error-tolerant parser. It exposes a single
      function. The loose parser is accessible in node.js via
      <code>require("acorn/dist/acorn_loose")</code>.
    </p>
    <p>
      <strong>parse_dammit</strong><code>(input, options)</code> takes the same
      arguments and returns the same syntax tree as the
      <code>parse</code> function in <code>acorn.js</code>, but never raises an
      error, and will do its best to parse syntactically invalid code in as
      meaningful a way as it can. It’ll insert identifier nodes with name
      <code>"✖"</code> as placeholders in places where it can’t make sense of
      the input. Depends on <code>acorn.js</code>, because it uses the same
      tokenizer.
    </p>
    <h3 id="distwalk.js">dist/walk.js</h3>
    <p>
      Implements an abstract syntax tree walker. Will store its interface in
      <code>acorn.walk</code> when loaded without a module system.
    </p>
    <p>
      <strong>simple</strong><code>(node, visitors, base, state)</code> does a
      ‘simple’ walk over a tree. <code>node</code> should be the AST node to
      walk, and <code>visitors</code> an object with properties whose names
      correspond to node types in the
      <a href="https://github.com/estree/estree">ESTree spec</a>. The properties
      should contain functions that will be called with the node object and, if
      applicable the state at that point. The last two arguments are optional.
      <code>base</code> is a walker algorithm, and <code>state</code> is a start
      state. The default walker will simply visit all statements and expressions
      and not produce a meaningful state. (An example of a use of state is to
      track scope at each point in the tree.)
    </p>
    <p>
      <strong>ancestor</strong><code>(node, visitors, base, state)</code> does a
      ‘simple’ walk over a tree, building up an array of ancestor nodes
      (including the current node) and passing the array to the callbacks as a
      third parameter.
    </p>
    <p>
      <strong>recursive</strong><code>(node, state, functions, base)</code> does
      a ‘recursive’ walk, where the walker functions are responsible for
      continuing the walk on the child nodes of their target node.
      <code>state</code> is the start state, and <code>functions</code> should
      contain an object that maps node types to walker functions. Such functions
      are called with <code>(node, state, c)</code> arguments, and can cause the
      walk to continue on a sub-node by calling the <code>c</code> argument on
      it with <code>(node, state)</code> arguments. The optional
      <code>base</code> argument provides the fallback walker functions for node
      types that aren’t handled in the <code>functions</code> object. If not
      given, the default walkers will be used.
    </p>
    <p>
      <strong>make</strong><code>(functions, base)</code> builds a new walker
      object by using the walker functions in <code>functions</code> and filling
      in the missing ones by taking defaults from <code>base</code>.
    </p>
    <p>
      <strong>findNodeAt</strong
      ><code>(node, start, end, test, base, state)</code> tries to locate a node
      in a tree at the given start and/or end offsets, which satisfies the
      predicate <code>test</code>. <code>start</code> and <code>end</code> can
      be either <code>null</code> (as wildcard) or a number.
      <code>test</code> may be a string (indicating a node type) or a function
      that takes <code>(nodeType, node)</code> arguments and returns a boolean
      indicating whether this node is interesting. <code>base</code> and
      <code>state</code> are optional, and can be used to specify a custom
      walker. Nodes are tested from inner to outer, so if two nodes match the
      boundaries, the inner one will be preferred.
    </p>
    <p>
      <strong>findNodeAround</strong
      ><code>(node, pos, test, base, state)</code> is a lot like
      <code>findNodeAt</code>, but will match any node that exists ‘around’
      (spanning) the given position.
    </p>
    <p>
      <strong>findNodeAfter</strong
      ><code>(node, pos, test, base, state)</code> is similar to
      <code>findNodeAround</code>, but will match all nodes <em>after</em> the
      given position (testing outer nodes before inner nodes).
    </p>
    <h2 id="command-line-interface">Command line interface</h2>
    <p>
      The <code>bin/acorn</code> utility can be used to parse a file from the
      command line. It accepts as arguments its input file and the following
      options:
    </p>
    <ul>
      <li>
        <p>
          <code>--ecma3|--ecma5|--ecma6|--ecma7</code>: Sets the ECMAScript
          version to parse. Default is version 5.
        </p>
      </li>
      <li>
        <p>
          <code>--module</code>: Sets the parsing mode to <code>"module"</code>.
          Is set to <code>"script"</code> otherwise.
        </p>
      </li>
      <li>
        <p>
          <code>--locations</code>: Attaches a “loc” object to each node with
          “start” and “end” subobjects, each of which contains the one-based
          line and zero-based column numbers in
          <code>{line, column}</code> form.
        </p>
      </li>
      <li>
        <p>
          <code>--allow-hash-bang</code>: If the code starts with the characters
          #! (as in a shellscript), the first line will be treated as a comment.
        </p>
      </li>
      <li>
        <p><code>--compact</code>: No whitespace is used in the AST output.</p>
      </li>
      <li>
        <p>
          <code>--silent</code>: Do not output the AST, just return the exit
          status.
        </p>
      </li>
      <li>
        <p><code>--help</code>: Print the usage information and quit.</p>
      </li>
    </ul>
    <p>The utility spits out the syntax tree as JSON data.</p>
    <h2 id="build-system">Build system</h2>
    <p>
      Acorn is written in ECMAScript 6, as a set of small modules, in the
      project’s <code>src</code> directory, and compiled down to bigger
      ECMAScript 3 files in <code>dist</code> using
      <a href="http://browserify.org">Browserify</a> and
      <a href="http://babeljs.io/">Babel</a>. If you are already using Babel,
      you can consider including the modules directly.
    </p>
    <p>
      The command-line test runner (<code>npm test</code>) uses the ES6 modules.
      The browser-based test page (<code>test/index.html</code>) uses the
      compiled modules. The <code>bin/build-acorn.js</code> script builds the
      latter from the former.
    </p>
    <p>
      If you are working on Acorn, you’ll probably want to try the code out
      directly, without an intermediate build step. In your scripts, you can
      register the Babel require shim like this:
    </p>
    <pre><code>require(&quot;babel-core/register&quot;)</code></pre>
    <p>That will allow you to directly <code>require</code> the ES6 modules.</p>
    <h2 id="plugins">Plugins</h2>
    <p>
      Acorn is designed support allow plugins which, within reasonable bounds,
      redefine the way the parser works. Plugins can add new token types and new
      tokenizer contexts (if necessary), and extend methods in the parser
      object. This is not a clean, elegant API—using it requires an
      understanding of Acorn’s internals, and plugins are likely to break
      whenever those internals are significantly changed. But still, it is
      <em>possible</em>, in this way, to create parsers for JavaScript dialects
      without forking all of Acorn. And in principle it is even possible to
      combine such plugins, so that if you have, for example, a plugin for
      parsing types and a plugin for parsing JSX-style XML literals, you could
      load them both and parse code with both JSX tags and types.
    </p>
    <p>
      A plugin should register itself by adding a property to
      <code>acorn.plugins</code>, which holds a function. Calling
      <code>acorn.parse</code>, a <code>plugins</code> option can be passed,
      holding an object mapping plugin names to configuration values (or just
      <code>true</code> for plugins that don’t take options). After the parser
      object has been created, the initialization functions for the chosen
      plugins are called with <code>(parser, configValue)</code> arguments. They
      are expected to use the <code>parser.extend</code> method to extend parser
      methods. For example, the <code>readToken</code> method could be extended
      like this:
    </p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode javascript"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="va">parser</span>.<span class="at">extend</span>(<span class="st">&quot;readToken&quot;</span><span class="op">,</span> <span class="kw">function</span> (nextMethod) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="cf">return</span> <span class="kw">function</span> (code) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading a token!&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="cf">return</span> <span class="va">nextMethod</span>.<span class="at">call</span>(<span class="kw">this</span><span class="op">,</span> code)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      The <code>nextMethod</code> argument passed to <code>extend</code>’s
      second argument is the previous value of this method, and should usually
      be called through to whenever the extended method does not handle the call
      itself.
    </p>
    <p>
      Similarly, the loose parser allows plugins to register themselves via
      <code>acorn.pluginsLoose</code>. The extension mechanism is the same as
      for the normal parser:
    </p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode javascript"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="va">looseParser</span>.<span class="at">extend</span>(<span class="st">&quot;readToken&quot;</span><span class="op">,</span> <span class="kw">function</span> (nextMethod) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="cf">return</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Reading a token in the loose parser!&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="cf">return</span> <span class="va">nextMethod</span>.<span class="at">call</span>(<span class="kw">this</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="op">};</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h3 id="existing-plugins">Existing plugins</h3>
    <ul>
      <li>
        <a href="https://github.com/RReverser/acorn-jsx"
          ><code>acorn-jsx</code></a
        >: Parse
        <a href="https://github.com/facebook/jsx"
          >Facebook JSX syntax extensions</a
        >
      </li>
      <li>
        <a href="https://github.com/MatAtBread/acorn-es7-plugin/"
          ><code>acorn-es7-plugin</code></a
        >: Parse
        <a href="https://github.com/tc39/ecmascript-asyncawait"
          >async/await syntax proposal</a
        >
      </li>
      <li>
        <a href="https://github.com/UXtemple/acorn-object-spread"
          ><code>acorn-object-spread</code></a
        >: Parse
        <a href="https://github.com/sebmarkbage/ecmascript-rest-spread"
          >object spread syntax proposal</a
        >
      </li>
      <li>
        <a href="https://www.npmjs.com/package/acorn-es7"
          ><code>acorn-es7</code></a
        >: Parse
        <a href="https://github.com/wycats/javascript-decorators"
          >decorator syntax proposal</a
        >
      </li>
      <li>
        <a href="https://www.npmjs.com/package/acorn-objj"
          ><code>acorn-objj</code></a
        >:
        <a href="http://www.cappuccino-project.org/learn/objective-j.html"
          >Objective-J</a
        >
        language parser built as Acorn plugin
      </li>
    </ul>
  </body>
</html>
