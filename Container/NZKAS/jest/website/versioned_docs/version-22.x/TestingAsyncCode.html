<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Testing Asynchronous Code</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Testing Asynchronous Code</h1>
    </header>
    <p>
      It’s common in JavaScript for code to run asynchronously. When you have
      code that runs asynchronously, Jest needs to know when the code it is
      testing has completed, before it can move on to another test. Jest has
      several ways to handle this.
    </p>
    <h2 id="callbacks">Callbacks</h2>
    <p>The most common asynchronous pattern is callbacks.</p>
    <p>
      For example, let’s say that you have a
      <code>fetchData(callback)</code> function that fetches some data and calls
      <code>callback(data)</code> when it is complete. You want to test that
      this returned data is just the string <code>'peanut butter'</code>.
    </p>
    <p>
      By default, Jest tests complete once they reach the end of their
      execution. That means this test will <em>not</em> work as intended:
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="co">// Don&#39;t do this!</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="at">test</span>(<span class="st">&#39;the data is peanut butter&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="kw">function</span> <span class="at">callback</span>(data) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="at">expect</span>(data).<span class="at">toBe</span>(<span class="st">&#39;peanut butter&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7">  <span class="at">fetchData</span>(callback)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      The problem is that the test will complete as soon as
      <code>fetchData</code> completes, before ever calling the callback.
    </p>
    <p>
      There is an alternate form of <code>test</code> that fixes this. Instead
      of putting the test in a function with an empty argument, use a single
      argument called <code>done</code>. Jest will wait until the
      <code>done</code> callback is called before finishing the test.
    </p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="at">test</span>(<span class="st">&#39;the data is peanut butter&#39;</span><span class="op">,</span> (done) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">function</span> <span class="at">callback</span>(data) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="at">expect</span>(data).<span class="at">toBe</span>(<span class="st">&#39;peanut butter&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="at">done</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="at">fetchData</span>(callback)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      If <code>done()</code> is never called, the test will fail, which is what
      you want to happen.
    </p>
    <h2 id="promises">Promises</h2>
    <p>
      If your code uses promises, there is a simpler way to handle asynchronous
      tests. Just return a promise from your test, and Jest will wait for that
      promise to resolve. If the promise is rejected, the test will
      automatically fail.
    </p>
    <p>
      For example, let’s say that <code>fetchData</code>, instead of using a
      callback, returns a promise that is supposed to resolve to the string
      <code>'peanut butter'</code>. We could test it with:
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="at">test</span>(<span class="st">&#39;the data is peanut butter&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="va">expect</span>.<span class="at">assertions</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="cf">return</span> <span class="at">fetchData</span>().<span class="at">then</span>((data) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="at">expect</span>(data).<span class="at">toBe</span>(<span class="st">&#39;peanut butter&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      Be sure to return the promise - if you omit this
      <code>return</code> statement, your test will complete before
      <code>fetchData</code> completes.
    </p>
    <p>
      If you expect a promise to be rejected use the <code>.catch</code> method.
      Make sure to add <code>expect.assertions</code> to verify that a certain
      number of assertions are called. Otherwise a fulfilled promise would not
      fail the test.
    </p>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="at">test</span>(<span class="st">&#39;the fetch fails with an error&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="va">expect</span>.<span class="at">assertions</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="cf">return</span> <span class="at">fetchData</span>().<span class="at">catch</span>((e) <span class="kw">=&gt;</span> <span class="at">expect</span>(e).<span class="at">toMatch</span>(<span class="st">&#39;error&#39;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h2 id="resolves-.rejects">
      <code>.resolves</code> / <code>.rejects</code>
    </h2>
    <h5 id="available-in-jest-20.0.0">
      available in Jest <strong>20.0.0+</strong>
    </h5>
    <p>
      You can also use the <code>.resolves</code> matcher in your expect
      statement, and Jest will wait for that promise to resolve. If the promise
      is rejected, the test will automatically fail.
    </p>
    <div class="sourceCode" id="cb5">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="at">test</span>(<span class="st">&#39;the data is peanut butter&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="va">expect</span>.<span class="at">assertions</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="cf">return</span> <span class="at">expect</span>(<span class="at">fetchData</span>()).<span class="va">resolves</span>.<span class="at">toBe</span>(<span class="st">&#39;peanut butter&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      Be sure to return the assertion—if you omit this
      <code>return</code> statement, your test will complete before
      <code>fetchData</code> completes.
    </p>
    <p>
      If you expect a promise to be rejected use the
      <code>.rejects</code> matcher. It works analogically to the
      <code>.resolves</code> matcher. If the promise is fulfilled, the test will
      automatically fail.
    </p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="at">test</span>(<span class="st">&#39;the fetch fails with an error&#39;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="va">expect</span>.<span class="at">assertions</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="cf">return</span> <span class="at">expect</span>(<span class="at">fetchData</span>()).<span class="va">rejects</span>.<span class="at">toMatch</span>(<span class="st">&#39;error&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <h2 id="asyncawait">Async/Await</h2>
    <p>
      Alternatively, you can use <code>async</code> and <code>await</code> in
      your tests. To write an async test, just use the
      <code>async</code> keyword in front of the function passed to
      <code>test</code>. For example, the same <code>fetchData</code> scenario
      can be tested with:
    </p>
    <div class="sourceCode" id="cb7">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="at">test</span>(<span class="st">&#39;the data is peanut butter&#39;</span><span class="op">,</span> <span class="kw">async</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="va">expect</span>.<span class="at">assertions</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="kw">const</span> data <span class="op">=</span> <span class="cf">await</span> <span class="at">fetchData</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="at">expect</span>(data).<span class="at">toBe</span>(<span class="st">&#39;peanut butter&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6"></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="at">test</span>(<span class="st">&#39;the fetch fails with an error&#39;</span><span class="op">,</span> <span class="kw">async</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-8" title="8">  <span class="va">expect</span>.<span class="at">assertions</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="cf">await</span> <span class="at">fetchData</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb7-11" title="11">  <span class="op">}</span> <span class="cf">catch</span> (e) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-12" title="12">    <span class="at">expect</span>(e).<span class="at">toMatch</span>(<span class="st">&#39;error&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb7-14" title="14"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      Of course, you can combine <code>async</code> and <code>await</code> with
      <code>.resolves</code> or <code>.rejects</code> (available in Jest
      <strong>20.0.0+</strong>).
    </p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="at">test</span>(<span class="st">&#39;the data is peanut butter&#39;</span><span class="op">,</span> <span class="kw">async</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="va">expect</span>.<span class="at">assertions</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="cf">await</span> <span class="at">expect</span>(<span class="at">fetchData</span>()).<span class="va">resolves</span>.<span class="at">toBe</span>(<span class="st">&#39;peanut butter&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="at">test</span>(<span class="st">&#39;the fetch fails with an error&#39;</span><span class="op">,</span> <span class="kw">async</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="va">expect</span>.<span class="at">assertions</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="cf">await</span> <span class="at">expect</span>(<span class="at">fetchData</span>()).<span class="va">rejects</span>.<span class="at">toMatch</span>(<span class="st">&#39;error&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="op">}</span>)<span class="op">;</span></a></code></pre>
    </div>
    <p>
      In these cases, <code>async</code> and <code>await</code> are effectively
      just syntactic sugar for the same logic as the promises example uses.
    </p>
    <p>
      None of these forms is particularly superior to the others, and you can
      mix and match them across a codebase or even in a single file. It just
      depends on which style makes your tests simpler.
    </p>
  </body>
</html>
