<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>contenthandler</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="contenthandler">ContentHandler</h1>
<p>The <em>ContentHandler</em> facility adds support for arbitrary content types on wiki pages, instead of relying on wikitext for everything. It was introduced in MediaWiki 1.21.</p>
<p>Each kind of content (“content model”) supported by MediaWiki is identified by unique name. The content model determines how a page’s content is rendered, compared, stored, edited, and so on.</p>
<p>Built-in content types are:</p>
<ul>
<li>wikitext - wikitext, as usual</li>
<li>javascript - user provided javascript code</li>
<li>json - simple implementation for use by extensions, etc.</li>
<li>css - user provided css code</li>
<li>text - plain text</li>
</ul>
<p>In PHP, use the corresponding <code>CONTENT_MODEL_XXX</code> constant.</p>
<p>A page’s content model is available using the <code>Title::getContentModel()</code> method. A page’s default model is determined by <code>ContentHandler::getDefaultModelFor($title)</code> as follows:</p>
<ul>
<li>The global setting <code>$wgNamespaceContentModels</code> specifies a content model for the given namespace.</li>
<li>The hook <code>ContentHandlerDefaultModelFor</code> may be used to override the page’s default model.</li>
<li>Pages in <code>NS_MEDIAWIKI</code> and <code>NS_USER</code> default to the CSS or JavaScript model if they end in .css or .js, respectively. Pages in <code>NS_MEDIAWIKI</code> default to the wikitext model otherwise.</li>
<li>Otherwise, the wikitext model is used.</li>
</ul>
<p>Note that is currently no mechanism to convert a page from one content model to another, and there is no guarantee that revisions of a page will all have the same content model. Use <code>Revision::getContentModel()</code>to find it.</p>
<h2 id="architecture">Architecture</h2>
<p>Two class hierarchies are used to provide the functionality associated with the different content models:</p>
<ul>
<li>Content interface (and <code>AbstractContent</code> base class) define functionality that acts on the concrete content of a page, and</li>
<li><code>ContentHandler</code> base class provides functionality specific to a content model, but not acting on concrete content.</li>
</ul>
<p>The most important function of ContentHandler is to act as a factory for the appropriate implementation of Content. These <code>Content</code> objects are to be used by MediaWiki everywhere, instead of passing page content around as text. All manipulation and analysis of page content must be done via the appropriate methods of the Content object.</p>
<p>For each content model, a subclass of ContentHandler has to be registered with <code>$wgContentHandlers</code>. The ContentHandler object for a given content model can be obtained using <code>ContentHandler::getForModelID( $id )</code>. Also <code>Title</code>, <code>WikiPage</code> and <code>Revision</code> now have <code>getContentHandler()</code> methods for convenience.</p>
<p><code>ContentHandler</code> objects are singletons that provide functionality specific to the content type, but not directly acting on the content of some page. <code>ContentHandler::makeEmptyContent()</code> and <code>ContentHandler::unserializeContent()</code> can be used to create a Content object of the appropriate type. However, it is recommended to instead use <code>WikiPage::getContent()</code> resp. <code>Revision::getContent()</code> to get a page’s content as a Content object. These two methods should be the ONLY way in which page content is accessed.</p>
<p>Another important function of ContentHandler objects is to define custom action handlers for a content model, see <code>ContentHandler::getActionOverrides()</code>. This is similar to what <code>WikiPage::getActionOverrides()</code> was already doing.</p>
<h2 id="serialization">Serialization</h2>
<p>With the ContentHandler facility, page content no longer has to be text based. Objects implementing the Content interface are used to represent and handle the content internally. For storage and data exchange, each content model supports at least one serialization format via <code>ContentHandler::serializeContent( $content )</code>. The list of supported formats for a given content model can be accessed using <code>ContentHandler::getSupportedFormats()</code>.</p>
<p>Content serialization formats are identified using MIME type like strings. The following formats are built in:</p>
<ul>
<li>text/x-wiki - wikitext</li>
<li>text/javascript - for js pages</li>
<li>text/css - for css pages</li>
<li>text/plain - for future use, e.g. with plain text messages.</li>
<li>text/html - for future use, e.g. with plain html messages.</li>
<li>application/vnd.php.serialized - for future use with the api and for extensions</li>
<li>application/json - for future use with the api, and for use by extensions</li>
<li>application/xml - for future use with the api, and for use by extensions</li>
</ul>
<p>In PHP, use the corresponding <code>CONTENT_FORMAT_XXX</code> constant.</p>
<p>Note that when using the API to access page content, especially <code>action=edit</code>, <code>action=parse</code> and <code>action=query&amp;prop=revisions</code>, the model and format of the content should always be handled explicitly. Without that information, interpretation of the provided content is not reliable. The same applies to XML dumps generated via <code>maintenance/dumpBackup.php</code> or <code>Special:Export</code>.</p>
<p>Also note that the API will provide encapsulated, serialized content - so if the API was called with <code>format=json</code>, and contentformat is also json (or rather, application/json), the page content is represented as a string containing an escaped json structure. Extensions that use JSON to serialize some types of page content may provide specialized API modules that allow access to that content in a more natural form.</p>
<h2 id="compatibility">Compatibility</h2>
<p>The ContentHandler facility is introduced in a way that should allow all existing code to keep functioning at least for pages that contain wikitext or other text based content. However, a number of functions and hooks have been deprecated in favor of new versions that are aware of the page’s content model, and will now generate warnings when used.</p>
<p>Most importantly, the following functions have been deprecated:</p>
<ul>
<li><code>Revisions::getText()</code> is deprecated in favor of <code>Revisions::getContent()</code></li>
<li><code>WikiPage::getText()</code> is deprecated in favor of <code>WikiPage::getContent()</code></li>
</ul>
<p>Also, the old <code>Article::getContent()</code> (which returns text) is superceded by <code>Article::getContentObject()</code>. However, both methods should be avoided since they do not provide clean access to the page’s actual content. For instance, they may return a system message for non-existing pages. Use <code>WikiPage::getContent()</code> instead.</p>
<p>Code that relies on a textual representation of the page content should eventually be rewritten. However, <code>ContentHandler::getContentText()</code> provides a stop-gap that can be used to get text for a page. Its behavior is controlled by <code>$wgContentHandlerTextFallback</code>; per default it will return the text for text based content, and null for any other content.</p>
<p>For rendering page content, <code>Content::getParserOutput()</code> should be used instead of accessing the parser directly. <code>WikiPage::makeParserOptions()</code> can be used to construct appropriate options.</p>
<p>Besides some functions, some hooks have also been replaced by new versions (see hooks.txt for details). These hooks will now trigger a warning when used:</p>
<ul>
<li><code>ArticleAfterFetchContent</code> was replaced by <code>ArticleAfterFetchContentObject</code>, later replaced by <code>ArticleRevisionViewCustom</code></li>
<li><code>ArticleInsertComplete</code> was replaced by <code>PageContentInsertComplete</code>, later replaced by <code>PageSaveComplete</code></li>
<li><code>ArticleSave</code> was replaced by <code>PageContentSave</code></li>
<li><code>ArticleSaveComplete</code> was replaced by <code>PageContentSaveComplete</code>, later replaced by <code>PageSaveComplete</code></li>
<li><code>ArticleViewCustom</code> was replaced by <code>ArticleContentViewCustom</code>, which was later removed entirely</li>
<li><code>EditFilterMerged</code> was replaced by <code>EditFilterMergedContent</code></li>
<li><code>EditPageGetDiffText</code> was replaced by <code>EditPageGetDiffContent</code></li>
<li><code>EditPageGetPreviewText</code> was replaced by <code>EditPageGetPreviewContent</code></li>
<li><code>ShowRawCssJs</code> was deprecated in favor of custom rendering implemented in the respective ContentHandler object.</li>
</ul>
<h2 id="database-storage">Database Storage</h2>
<p>Page content is stored in the database using the same mechanism as before. Non-text content is serialized first. The appropriate serialization and deserialization is handled by the Revision class.</p>
<p>Each revision’s content model and serialization format is stored in the revision table (resp. in the archive table, if the revision was deleted). The page’s (current) content model (that is, the content model of the latest revision) is also stored in the page table.</p>
<p>Note however that the content model and format is only stored if it differs from the page’s default, as determined by <code>ContentHandler::getDefaultModelFor( $title )</code>. The default values are represented as <code>NULL</code> in the database, to preserve space.</p>
<h2 id="globals">Globals</h2>
<p>There are some new globals that can be used to control the behavior of the ContentHandler facility:</p>
<ul>
<li><p><code>$wgContentHandlers</code> associates content model IDs with the names of the appropriate ContentHandler subclasses or callbacks that create an instance of the appropriate ContentHandler subclass.</p></li>
<li><p><code>$wgNamespaceContentModels</code> maps namespace IDs to a content model that should be the default for that namespace.</p></li>
<li><code>$wgContentHandlerTextFallback</code> determines how the compatibility method <code>ContentHandler::getContentText()</code> will behave for non-text content:
<ul>
<li><code>'ignore'</code> causes null to be returned for non-text content (default).</li>
<li><code>'serialize'</code> causes the serialized form of any non-text content to be returned (scary).</li>
<li><code>'fail'</code> causes an exception to be thrown for non-text content (strict).</li>
</ul></li>
</ul>
<h2 id="caveats">Caveats</h2>
<p>There are some changes in behavior that might be surprising to users:</p>
<ul>
<li><p>Javascript and CSS pages are no longer parsed as wikitext (though pre-save transform is still applied). Most importantly, this means that links, including categorization links, contained in the code will not work.</p></li>
<li><p><code>action=edit</code> will fail for pages with non-text content, unless the respective ContentHandler implementation has provided a specialized handler for the edit action. This is true for the API as well.</p></li>
<li><p><code>action=raw</code> will fail for all non-text content. This seems better than serving content in other formats to an unsuspecting recipient. This will also cause client-side diffs to fail.</p></li>
<li><p>File pages provide their own action overrides that do not combine gracefully with any custom handlers defined by a ContentHandler. If for example a File page used a content model with a custom revert action, this would be overridden by WikiFilePage’s handler for the revert action.</p></li>
</ul>
</body>
</html>
