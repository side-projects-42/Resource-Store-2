<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>v3_design</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<table>
<tbody>
<tr class="odd">
<td>
<a href="../../../index.htm"><img src="../../../boost.png" alt="boost.png (6897 bytes)" width="300" height="86" /></a>
</td>
<td>
Filesystem Version 3<br /> Design
</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td>
<a href="index.htm">Filesystem Home</a>    <a href="release_history.html">Releases</a>    <a href="reference.html">Reference</a>    <a href="tutorial.html">Tutorial</a>    <a href="faq.htm">FAQ</a>    <a href="portability_guide.htm">Portability</a>    <a href="v3.html">V3 Intro</a>    <a href="v3_design.html">V3 Design</a>    <a href="deprecated.html">Deprecated</a>   
</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">
<em><strong>Contents</strong></em>
</td>
</tr>
<tr class="even">
<td style="text-align: center;">
<a href="#Introduction">Introduction</a><br /> <a href="#Problem">Problem</a><br /> <a href="#Solution">Solution</a><br /> <a href="#Details">Details</a><br /> <a href="#Other-changes">Other changes</a><br /> <a href="#Acknowledgements">Acknowledgements</a>
</td>
</tr>
</tbody>
</table>
<p><strong>Caution:</strong> This page documents thinking early in the V3 development process, and is intended to serve historical purposes. It is not updated to reflect the current state of the library.</p>
<h2 id="introduction"><span id="Introduction">Introduction</span></h2>
<p>During the review of Boost.Filesystem.V2 (Internationalization), Peter Dimov suggested that the<code>basic_path</code> class template was unwieldy, and that a single path type that accommodated multiple character types and encodings would be more flexible. Although I wasn’t willing to stop development at that time to explore how this idea might be implemented, or to break from the pattern for Internationalization used the C++ standard library, I’ve often thought about Peter’s suggestion. With the advent of C++0x <code>char16_t</code> and <code>char32_t</code> character types, the <code>basic_path</code> class template approach becomes even more unwieldy, so it is time to revisit the problem in light of Peter’s suggestion.</p>
<h2 id="problem"><strong><span id="Problem">Problem</span></strong></h2>
<p>With Filesystem.V2, a path argument to a user defined function that is to accommodate multiple character types and encodings must be written as a template. Do-the-right-thing overloads or template metaprogramming must be employed to allow arguments to be written as string literals. Here’s what it looks like:</p>
<blockquote>
<pre><code>template&lt;class Path&gt;
void foo( const Path &amp; p );

inline void foo( const path &amp; p )
{
  return foo&lt;path&gt;( p );
}
inline void foo( const wpath &amp; p )
{
  return foo&lt;wpath&gt;( p );
}</code></pre>
</blockquote>
<p>That’s really ugly for such a simple need, and there would be a combinatorial explosion if the function took multiple Path arguments and each could be either narrow or wide. It gets even worse if the C++0x <code>char16_t</code> and <code>char32_t</code> types are to be supported.</p>
<h2 id="solution"><span id="Solution">Solution</span></h2>
<p>Overview:</p>
<ul>
<li>A single, non-template, <code>class path</code>.</li>
<li>Each member function is a template accommodating the various applicable character types, including user-defined character types.</li>
<li>Hold the path internally in a string of the type used by the operating system API; <code>std::string</code> for POSIX, <code>std::wstring</code> for Windows.</li>
</ul>
<p>The signatures presented in <a href="#Problem">Problem</a> collapse to simply:</p>
<blockquote>
<pre><code>void foo( const path &amp; p );</code></pre>
</blockquote>
<p>That’s a signification reduction in code complexity. Specification becomes simpler, too. I believe it will be far easier to teach, and result in much more flexible user code.</p>
<p>Other benefits:</p>
<ul>
<li>All the polymorphism still occurs at compile time.</li>
<li>Efficiency is increased, in that conversions of the encoding, if required, only occur once at the time of creation, not each time the path is used.</li>
<li>The size of the implementation code drops approximately in half and becomes much more readable.</li>
</ul>
<p>Possible problems:</p>
<ul>
<li>The combination of member function templates and implicit constructors can result in unclear error messages when the user makes simple commonplace coding errors. This should be much less of a problem with C++ concepts, but in the meantime work continues to restrict over aggressive templates via enable_if/disable_if.</li>
</ul>
<h2 id="details"><span id="Details">Details</span></h2>
<p><strong><em>Encoding</em></strong> <strong><em>Conversions</em></strong></p>
<p><strong><em>Host system</em></strong></p>
<p><strong><em>char string path arguments</em></strong></p>
<p><strong><em>wide string path arguments</em></strong></p>
<p>Systems with <code>char</code> as the native API path character type (i.e. POSIX-like systems)</p>
<p>No conversion.</p>
<p>Conversion occurs, performed by the current path locale’s <code>codecvt</code> facet.</p>
<p>Systems with <code>wchar_t</code> as the native API path character type (i.e. Windows-like systems).</p>
<p>Conversion occurs, performed by the current path locale’s <code>codecvt</code> facet.</p>
<p>No conversion.</p>
<p>When a class path function argument type matches the the operating system’s API argument type for paths, no conversion is performed rather than conversion to a specified encoding such as one of the Unicode encodings. This avoids unintended consequences, etc.</p>
<h2 id="other-changes"><span id="Other-changes">Other changes</span></h2>
<p><strong>Uniform hybrid error handling:</strong> The hybrid error handling idiom has been consistently applied to all applicable functions.</p>
<h2 id="acknowledgements"><span id="Acknowledgements">Acknowledgements</span></h2>
<p>Peter Dimov suggested the idea of a single path class that could cope with multiple character types and encodings. Walter Landry contributed both the design and implementation of the copy_any, copy_directory, copy_symlink, and read_symlink functions.</p>
<hr />
<p>Revised 20 March, 2012</p>
<p>© Copyright Beman Dawes, 2008</p>
<p>Use, modification, and distribution are subject to the Boost Software License, Version 1.0. See <a href="http://www.boost.org/LICENSE_1_0.txt">www.boost.org/LICENSE_1_0.txt</a></p>
</body>
</html>
