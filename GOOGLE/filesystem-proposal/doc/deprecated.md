<table><tbody><tr class="odd"><td><a href="../../../index.htm"><img src="../../../boost.png" alt="boost.png (6897 bytes)" width="300" height="86" /></a></td><td>Filesystem Deprecated Features</td></tr></tbody></table>

<table><tbody><tr class="odd"><td><a href="index.htm">Filesystem Home</a>    <a href="release_history.html">Releases</a>    <a href="reference.html">Reference</a>    <a href="tutorial.html">Tutorial</a>    <a href="faq.htm">FAQ</a>    <a href="portability_guide.htm">Portability</a>    <a href="v3.html">V3 Intro</a>    <a href="v3_design.html">V3 Design</a>    <a href="deprecated.html">Deprecated</a>   </td></tr></tbody></table>

<span id="Deprecated-names">Deprecated names</span> and features
----------------------------------------------------------------

As the library evolves over time, names sometimes change or old features are removed to make way for new features. To ease transition, Boost.Filesystem deprecates the old names and features, but by default continues to provide many of them. The deprecated names and other workarounds can be suppressed by defining macro `BOOST_FILESYSTEM_NO_DEPRECATED`, and this is recommended for all new code.

In the table, ✔ indicates a synonym or other workaround is provided unless `BOOST_FILESYSTEM_NO_DEPRECATED` is defined.

<table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><tbody><tr class="odd"><td><strong><em>Component or location</em></strong></td><td><p><strong><em>Old name, now deprecated</em></strong></p></td><td>✔</td><td><p><strong><em>New name</em></strong></p></td></tr><tr class="even"><td><code>class path</code></td><td><code>branch_path()</code></td><td>✔</td><td><code>parent_path()</code></td></tr><tr class="odd"><td><code>class path</code></td><td><code>canonize()</code></td><td> </td><td><em>Function removed</em></td></tr><tr class="even"><td><code>class path</code></td><td><code>default_name_check()</code></td><td>✔</td><td><em>Function removed</em></td></tr><tr class="odd"><td><code>class path</code></td><td><code>default_name_check(name_check)</code></td><td>✔</td><td><em>Function removed</em></td></tr><tr class="even"><td><code>class path</code></td><td><code>default_name_check_writable()</code></td><td>✔</td><td><em>Function removed</em></td></tr><tr class="odd"><td><code>class path</code></td><td><code>directory_string()</code></td><td>✔</td><td><code>string</code></td></tr><tr class="even"><td><code>class path</code></td><td><code>external_directory_string()</code></td><td>✔</td><td><code>native()</code></td></tr><tr class="odd"><td><code>class path</code></td><td><code>external_file_string()</code></td><td>✔</td><td><code>native()</code></td></tr><tr class="even"><td><code>class path</code></td><td><code>file_string()</code></td><td>✔</td><td><code>string()</code></td></tr><tr class="odd"><td><code>class path</code></td><td><code>has_branch_path()</code></td><td>✔</td><td><code>has_parent_path()</code></td></tr><tr class="even"><td><code>class path</code></td><td><code>has_leaf()</code></td><td>✔</td><td><code>has_filename()</code></td></tr><tr class="odd"><td><code>class path</code></td><td><code>is_complere()</code></td><td>✔</td><td><code>is_absolute()</code></td></tr><tr class="even"><td><code>class path</code></td><td><code>leaf()</code></td><td>✔</td><td><code>filename()</code></td></tr><tr class="odd"><td><code>class path</code></td><td><code>native_directory_string()</code></td><td>✔</td><td><code>string()</code></td></tr><tr class="even"><td><code>class path</code></td><td><code>native_file_string()</code></td><td>✔</td><td><code>string()</code></td></tr><tr class="odd"><td><code>class path</code></td><td><code>normalize()</code></td><td>✔</td><td><em>Function removed</em></td></tr><tr class="even"><td><code>class path</code></td><td><code>path(const string_type&amp; str, name_check)</code></td><td>✔</td><td><em>Function removed. Workaround ignores</em> <code>name_check</code> <em>argument.</em></td></tr><tr class="odd"><td><code>class path</code></td><td><code>path(const string_type::value_type* s,  name_check)</code></td><td>✔</td><td><em>Function removed. Workaround ignores</em> <code>name_check</code> <em>argument.</em></td></tr><tr class="even"><td><code>class path</code></td><td><p><code>remove_leaf()</code></p></td><td>✔</td><td><p><code>remove_filename()</code></p></td></tr><tr class="odd"><td><code>path.hpp</code></td><td><code>template&lt;class String, class Traits&gt;   class basic_path;</code></td><td> </td><td>Class template <code>basic_path</code> is replaced by <code>class path</code>. No workaround for an explicitly coded <code>basic_path</code> is provided, but see the next row - <code>path</code>.</td></tr><tr class="even"><td><code>path.hpp</code></td><td><code>typedef basic_path&lt;std::string, path_traits&gt; path</code></td><td>✔</td><td><code>class path</code></td></tr><tr class="odd"><td><code>path.hpp</code></td><td><code>typedef basic_path&lt;std::wstring, wpath_traits&gt; wpath</code></td><td>✔</td><td><em>Removed; use</em> <code>class path</code> <em>instead. Workaround provides</em> <code>typedef path wpath</code></td></tr><tr class="even"><td><code>operations.hpp</code></td><td><code>initial_path()</code></td><td>✔</td><td><em>Function removed</em></td></tr><tr class="odd"><td><code>operations.hpp</code></td><td><p><code>template &lt;class Path&gt; Path complete(const Path&amp; p,  const Path&amp; base=    initial_path&lt;Path&gt;())</code></p></td><td>✔</td><td><p><code>path absolute(const path&amp; p, const path&amp; base=   current_path())</code></p></td></tr><tr class="even"><td><code>operations.hpp</code></td><td><code>is_regular(file_status f)</code></td><td>✔</td><td><p><code>is_regular_file(file_status f)</code></p></td></tr><tr class="odd"><td><code>operations.hpp</code></td><td><code>symbolic_link_exists(const path&amp; ph)</code></td><td> </td><td><em>Function removed</em></td></tr><tr class="even"><td><code>class directory_entry</code></td><td><code>filename()</code></td><td>✔</td><td><em>Function removed, use</em> <code>path().filename()</code> <em>instead.</em></td></tr><tr class="odd"><td><code>class directory_entry</code></td><td><code>leaf()</code></td><td>✔</td><td><em>Function removed, use</em> <code>path().filename()</code> <em>instead.</em></td></tr><tr class="even"><td><code>class directory_entry</code></td><td><code>string()</code></td><td>✔</td><td><em>Function removed, use</em> <code>path().string()</code> <em>instead.</em></td></tr><tr class="odd"><td>Macro definitions</td><td><code>BOOST_WINDOW_API</code></td><td> </td><td><em>No longer supported; API selection is always automatic.</em></td></tr><tr class="even"><td>Macro definitions</td><td><code>BOOST_POSIX_API</code></td><td> </td><td><em>No longer supported; API selection is always automatic.</em></td></tr><tr class="odd"><td>Macro definitions</td><td><code>BOOST_WINDOW_PATH</code></td><td> </td><td><em>No longer supported; native path format selection is always automatic.</em></td></tr><tr class="even"><td>Macro definitions</td><td><code>BOOST_POSIX_PATH</code></td><td> </td><td><em>No longer supported; native path format selection is always automatic.</em></td></tr></tbody></table>

Deprecation rationale
---------------------

### `initial_path` function

Full implementation of `initial_path()` would require support from the C++ runtime startup code, and that doesn’t seem likely to happen. Depending on the user to call `initial_path()` at the beginning of `main()` is too error prone.  An equivalent function can trivially be provided by a user.

------------------------------------------------------------------------

Revised 20 March, 2012

© Copyright Beman Dawes, 2002-2005, 2010

Use, modification, and distribution are subject to the Boost Software License, Version 1.0. See [www.boost.org/LICENSE\_1\_0.txt](http://www.boost.org/LICENSE_1_0.txt)
