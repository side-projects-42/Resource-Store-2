<table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th><h1 id="readme.js">readme.js</h1></th><th></th></tr></thead><tbody><tr class="odd"><td><div class="pilwrap"><a href="#section-1" class="pilcrow">¶</a></div></td><td><div class="highlight"><pre><code>/* vim:set ts=2 sw=2 sts=2 expandtab */
/*jshint asi: true undef: true es5: true node: true devel: true
         forin: true latedef: false globalstrict: true */
/*global define: true setInterval: true */

/* html version: http://jeditoolkit.com/streamer/docs/readme.html */

&#39;use strict&#39;;</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-2" class="pilcrow">¶</a></div><p>In computing, the term stream is used in a number of ways, in all cases referring to a sequence of elements made available over time.</p></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-3" class="pilcrow">¶</a></div><p>Let’s create a very basic stream representing a sequence of elements from 1 to 3.</p></td><td><div class="highlight"><pre><code>function stream(next) {
  [ 1, 2, 3 ].forEach(function(element) {
    next(element)
  })
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-4" class="pilcrow">¶</a></div><p>From this example we can define a stream as: a function representing a sequence of elements. It can be read by calling with one function argument, which will be called back with each element of the sequence.</p></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-5" class="pilcrow">¶</a></div><p>So we can print our stream like this:</p></td><td><div class="highlight"><pre><code>stream(function onEach(element) {
  console.log(element)
})</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-6" class="pilcrow">¶</a></div><pre><code> 1
 2
 3</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-7" class="pilcrow">¶</a></div><p>Or, we can create a convenience <a href="http://en.wikipedia.org/wiki/Higher-order_function">high-order function</a> for printing streams.</p></td><td><div class="highlight"><pre><code>function print(stream) {
  stream(function onEach(element) {
    console.log(element)            // Print each element of the sequence.
  })
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-8" class="pilcrow">¶</a></div><p>And, print stream with it:</p></td><td><div class="highlight"><pre><code>print(stream)</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-9" class="pilcrow">¶</a></div><pre><code> 1
 2
 3</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-10" class="pilcrow">¶</a></div><p>Good, but! Stream is a sequence of elements <strong>made available over time</strong>. In other words a sequence may be lazy, and our stream definition needs refinement:</p><p>Stream is a function representing a sequence of elements. It MAY be read by calling it with one function argument, that will be called back with each element when it becomes available.</p></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-11" class="pilcrow">¶</a></div><p>Let’s create a function <code>numbers</code>, that takes <code>min</code> and <code>max</code> numbers and returns a lazy stream of random numbers in a given range. To make the stream lazy, we will make its new elements available every 20ms.</p></td><td><div class="highlight"><pre><code>function numbers(min, max) { // Another high-order function to make streams
  var delta = max - min
  return function stream(next) { // Actual stream that generates 
    setInterval(function generate() {</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-12" class="pilcrow">¶</a></div><p>We yield a random number in given range every 20ms.</p></td><td><div class="highlight"><pre><code>      next(min + Math.round(Math.random() * delta))
    }, 20)
  }
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-13" class="pilcrow">¶</a></div><p>Make a stream of random numbers in the 0 - 100 range.</p></td><td><div class="highlight"><pre><code>var numberStream = numbers(0, 100)</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-14" class="pilcrow">¶</a></div><p>And we print it!!</p></td><td><div class="highlight"><pre><code>print(numberStream)</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-15" class="pilcrow">¶</a></div><pre><code> 29
 33
 45
 ....</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-16" class="pilcrow">¶</a></div><p>Oops! The stream keeps printing these numbers infinitely. Right, that’s because a stream is infinite! So we may have finite and infinite streams, the difference being that finite streams end / stop at some point. And if a stream stops we need to know when that happens. To do that we will add a second, optional <code>stop</code> callback argument that MUST be called once stream reaches its end. Let’s redefine our <code>print</code> function with this in mind:</p></td><td><div class="highlight"><pre><code>function print(stream) {
  console.log(&quot;&gt;&gt;&gt;&quot;)                    // Opening stream for reading
  stream(function onElement(element) {
    console.log(element)                // Print each element of stream.
  }, function onStop() {
    console.log(&quot;&lt;&lt;&lt;&quot;)                  // Stream is stopped.
  })
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-17" class="pilcrow">¶</a></div><p>Now we need a stream to print. Instead of creating another basic stream, this time we will take more generic approach by defining a function that takes an array as an argument and returns a stream of its elements:</p></td><td><div class="highlight"><pre><code>function list(array) {
  return function stream(next, stop) {
    array.forEach(function(element) {
      next(element)
    })
    stop()
  }
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-18" class="pilcrow">¶</a></div><p>Great let’s print something now!</p></td><td><div class="highlight"><pre><code>print(list(1, 2, 3))</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-19" class="pilcrow">¶</a></div><p>Right, we should have passed an array to the list. Yeah, so shit happens! And when it happens to the stream, it needs to do something about it. The only reasonable thing is to recover, and if that is not possible then stop and report the reason of failure. This means that the <code>stop</code> callback MAY be called with an error argument, indicating a reason of failure!</p></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-20" class="pilcrow">¶</a></div><p>Let’s adjust our print and streams to do that:</p></td><td><div class="highlight"><pre><code>function print(stream) {
  console.log(&quot;&gt;&gt;&gt;&quot;)                      // Opening stream for reading
  stream(function onElement(element) {
    console.log(element)                  // Print each element of stream.
  }, function onStop(error) {
    if (!error) return console.log(&#39;&lt;&lt;&lt;&#39;) // If no error is passed, stream ended</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-21" class="pilcrow">¶</a></div><p>If there is an error print it out as well.</p></td><td><div class="highlight"><pre><code>    console.log(&#39;!!!&#39;)
    console.error(error)
  })
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-22" class="pilcrow">¶</a></div><p>Let’s make another version of a function that returns a stream of given elements, in this case though we will use arguments instead of requiring an array argument.</p></td><td><div class="highlight"><pre><code>function list() {</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-23" class="pilcrow">¶</a></div><p>Capture arguments as an array.</p></td><td><div class="highlight"><pre><code>  var elements = Array.prototype.slice.call(arguments, 0)</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-24" class="pilcrow">¶</a></div><p>Stream takes two callback arguments, the first is called with each element when it becomes available, and the second after calling first with all the elements of the stream.</p></td><td><div class="highlight"><pre><code>  return function stream(next, stop) {</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-25" class="pilcrow">¶</a></div><p>Yield each element of the stream by calling the <code>next</code>. callback.</p></td><td><div class="highlight"><pre><code>    elements.forEach(function(element) {
      next(element)
    })</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-26" class="pilcrow">¶</a></div><p>When we reach the end we stop a stream by calling the <code>stop</code> callback if it’s passed.</p></td><td><div class="highlight"><pre><code>    if (stop) stop()
  }
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-27" class="pilcrow">¶</a></div><p>Another attempt to print:</p></td><td><div class="highlight"><pre><code>print(list(1, 2, 3))</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-28" class="pilcrow">¶</a></div><pre><code> &gt;&gt;&gt;
 1
 2
 3
 &lt;&lt;&lt;</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-29" class="pilcrow">¶</a></div><p>Let’s refine our stream definition again:</p></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-30" class="pilcrow">¶</a></div><p><em>Stream is a function representing a sequence of elements. It MAY be read by calling it with one function argument, that will be called every time an element becomes available. Stream takes a second optional function argument which is called once the stream is stopped, either without arguments when stream runs out of elements or with an error indicating the failure reason indicating why stream was stopped.</em></p></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-31" class="pilcrow">¶</a></div><p>Let’s do something interesting from real life, like create a stream of all directory entries including entries from all nested directories (lstree).</p><p>First we will have to create a few stream based wrappers around node’s fs functions. We will start with a function that takes the path for a directory and returns a lazy stream of its entries. If reading a directory fails we will stop the stream with an error:</p></td><td><div class="highlight"><pre><code>var fs = require(&quot;fs&quot;)
function ls(path) {
  return function stream(next, stop) {</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-32" class="pilcrow">¶</a></div><p>see: <a href="http://nodejs.org/docs/v0.4.8/api/fs.html#fs.readdir">http://nodejs.org/docs/v0.4.8/api/fs.html#fs.readdir</a></p></td><td><div class="highlight"><pre><code>    fs.readdir(path, function onEntries(error, entries) {
      var entry</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-33" class="pilcrow">¶</a></div><p>On error we stop a stream with that error.</p></td><td><div class="highlight"><pre><code>      if (error) return stop(error)</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-34" class="pilcrow">¶</a></div><p>Otherwise we yield each entry.</p></td><td><div class="highlight"><pre><code>      while ((entry = entries.shift())) next(entry)</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-35" class="pilcrow">¶</a></div><p>Once we yielded all entries we stop a stream.</p></td><td><div class="highlight"><pre><code>      stop()
    })
  }
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-36" class="pilcrow">¶</a></div><p>Try it out for the current working directory:</p></td><td><div class="highlight"><pre><code>print(ls(&#39;./&#39;))</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-37" class="pilcrow">¶</a></div><pre><code> &gt;&gt;&gt;
 .gitignore
 History.md
 package.json
 readme.js
 Readme.md
 streamer.js
 tests
 &lt;&lt;&lt;</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-38" class="pilcrow">¶</a></div><p>The next wrapper we will need is <code>fs.stat</code>. We define a function that <code>takes</code> a path and returns a lazy stream with only an element representing <code>stat</code> of the given <code>path</code>. A lazy steam with one element can been seen as a promise or deferred, but don’t worry if you are not familiar with that pattern.</p></td><td><div class="highlight"><pre><code>function stat(path) {
  return function stream(next, stop) {</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-39" class="pilcrow">¶</a></div><p>see: <a href="http://nodejs.org/docs/v0.4.8/api/fs.html#fs.stat">http://nodejs.org/docs/v0.4.8/api/fs.html#fs.stat</a></p></td><td><div class="highlight"><pre><code>    fs.stat(path, function onStat(error, stats) {</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-40" class="pilcrow">¶</a></div><p>On error we stop the stream with that error.</p></td><td><div class="highlight"><pre><code>      if (error) return stop(error)</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-41" class="pilcrow">¶</a></div><p>We add the path to the stat itself as it will be very convenient.</p></td><td><div class="highlight"><pre><code>      stats.path = path</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-42" class="pilcrow">¶</a></div><p>We yield <code>stats</code> and stop the stream.</p></td><td><div class="highlight"><pre><code>      next(stats)
      stop()
    })
  }
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-43" class="pilcrow">¶</a></div><p>Try it out for the current working directory:</p></td><td><div class="highlight"><pre><code>print(stat(&#39;./&#39;))</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-44" class="pilcrow">¶</a></div><pre><code> &gt;&gt;&gt;
 { dev: 234881026,
 ino: 19933437,
 mode: 16877,
 nlink: 17,
 uid: 502,
 gid: 20,
 rdev: 0,
 size: 578,
 blksize: 4096,
 blocks: 0,
 atime: Thu, 09 Jun 2011 10:51:25 GMT,
 mtime: Thu, 09 Jun 2011 12:48:32 GMT,
 ctime: Thu, 09 Jun 2011 12:48:32 GMT,
 path: &#39;./&#39; }
 &lt;&lt;&lt;</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-45" class="pilcrow">¶</a></div><p>Great we are done with the wrappers. Now we can list entries of the directory, but in order to list nested entries we need to distinguish directories from files. To do that we will create a function that takes a directory entries stream and returns a filtered stream containing only entries that are directories. We already can get stats from paths, so we just need to map entry paths to stats. Let’s make a generic map function that takes a stream and a mapper function and returns a stream of mapped elements.</p></td><td><div class="highlight"><pre><code>function map(lambda, source) {
  return function stream(next, stop) {
    source(function onElement(element) {
      next(lambda(element))
    }, stop)
  }
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-46" class="pilcrow">¶</a></div><p>Let’s try to map numbers into doubled values:</p></td><td><div class="highlight"><pre><code>print(map(function(x) { return x * 2 }, list(1, 2, 3)))</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-47" class="pilcrow">¶</a></div><pre><code> &gt;&gt;&gt;
 2
 4
 6
 &lt;&lt;&lt;</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-48" class="pilcrow">¶</a></div><p>Now we can implement a function that is the equivalent of <code>ls</code> with the difference that it returns a stream of paths instead of entry filenames.</p></td><td><div class="highlight"><pre><code>var join = require(&quot;path&quot;).join
function paths(path) { return map(join.bind(null, path), ls(path)) }</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-49" class="pilcrow">¶</a></div><p>Test drive:</p></td><td><div class="highlight"><pre><code>print(paths(process.cwd()))</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-50" class="pilcrow">¶</a></div><pre><code> &gt;&gt;&gt;
 /Users/gozala/Projects/streamer/History.md
 /Users/gozala/Projects/streamer/package.json
 ...
 &lt;&lt;&lt;</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-51" class="pilcrow">¶</a></div><p>Now we need another equivalent of <code>paths</code> that returns a stream of directory paths only. To do that we need to filter out directories. So let’s implement a generic filter function that takes a stream of elements and a filter function and returns the steam of elements for which the filterer returned true.</p></td><td><div class="highlight"><pre><code>function filter(lambda, source) {
  return function stream(next, stop) {
    source(function onElement(element) {
      if (lambda(element)) next(element)
    }, stop)
  }
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-52" class="pilcrow">¶</a></div><p>Simple example for filtering out odd numbers from a number stream.</p></td><td><div class="highlight"><pre><code>print(filter(function(x) { return x % 2 }, list(1, 2, 3, 4)))</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-53" class="pilcrow">¶</a></div><pre><code> &gt;&gt;&gt;
 1
 3
 &lt;&lt;&lt;</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-54" class="pilcrow">¶</a></div><p>Awesome, going back to our problem, to figure out weather we have a file path or directory path we need to map paths to stats and then filter out only ones from there that are directories:</p></td><td><div class="highlight"><pre><code>function dirs(paths) { 
  var stats = map(stat, paths)
  var dirStats = filter(function(stat) { return stat.isDirectory() }, stats)
  return map(function(stat) { return stat.path }, dirStats)
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-55" class="pilcrow">¶</a></div><p>Unfortunately dirs not going to work, because the <code>stats</code> stream is not a stream of <code>stat</code> elements, it is a stream of streams that are streams of <code>stat</code> elements. So what we need is sort of a flattened version of that stream. This is easy to do with another core <code>merge</code> function:</p></td><td><div class="highlight"><pre><code>function merge(source) {
  return function stream(next, stop) {
    var open = 1
    function onStop(error) {
      if (!open) return false
      if (error) open = 0
      else open --

      if (!open) stop(error)
    }
    source(function onStream(stream) {
      open ++
      stream(function onNext(value) { if (open) next(value) }, onStop)
    }, onStop)
  }
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-56" class="pilcrow">¶</a></div><p>Let’s try a simple example:</p></td><td><div class="highlight"><pre><code>print(merge(list(list(1, 2), list(&#39;a&#39;, &#39;b&#39;))))</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-57" class="pilcrow">¶</a></div><pre><code> &gt;&gt;&gt;
 1
 2
 a
 b
 &lt;&lt;&lt;</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-58" class="pilcrow">¶</a></div><p>Now we can refine our dirs function:</p></td><td><div class="highlight"><pre><code>function dirs(paths) {
  var stats = merge(map(paths, stat))
  var dirStats = filter(function(stat) { return stat.isDirectory() }, stats)
  return map(function(stat) { return stat.path }, dirStats)
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-59" class="pilcrow">¶</a></div><p>Test drive:</p></td><td><div class="highlight"><pre><code>print(dirs(paths(process.cwd())))</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-60" class="pilcrow">¶</a></div><pre><code> &gt;&gt;&gt;
 /Users/gozala/Projects/streamer/.git
 /Users/gozala/Projects/streamer/node_modules
 ...
 &lt;&lt;&lt;</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-61" class="pilcrow">¶</a></div><p>Finally we have all we need to implement <code>lstree</code>:</p></td><td><div class="highlight"><pre><code>function lstree(path) {
  var entries = paths(path)
  var nested = merge(map(lstree, dirs(entries)))
  return merge(list(entries, nested))
}</code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-62" class="pilcrow">¶</a></div><p>Crossing our fingers!!</p></td><td><div class="highlight"><pre><code>print(lstree(&#39;./&#39;))</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-63" class="pilcrow">¶</a></div><pre><code> &gt;&gt;&gt;
 .git
 .git/COMMIT_EDITMSG
 .git/config
 ....
 &lt;&lt;&lt;</code></pre></td><td><div class="highlight"><pre><code></code></pre></div></td></tr><tr class="even"><td><div class="pilwrap"><a href="#section-64" class="pilcrow">¶</a></div><p>So let’s take a look back now, if we ignore all the core stream functions that are part of the <a href="https://github.com/Gozala/streamer">streamer library</a> and some node <code>fs</code> wrappers, we have written code that deals with recursive asynchronous code, but that has a very linear flow. Take another look at it with all the noise removed:</p></td><td><div class="highlight"><pre><code>function paths(path) { return map(join.bind(null, path), ls(path)) }
function dirs(paths) { 
  var stats = map(stat, paths)
  var dirStats = filter(function(stat) { return stat.isDirectory() }, stats)
  return map(function(stat) { return stat.path }, dirStats)
}
function lstree(path) {
  var entries = paths(path)
  var nested = merge(map(lstree, dirs(entries)))
  return merge(list(entries, nested))
}</code></pre></div></td></tr><tr class="odd"><td><div class="pilwrap"><a href="#section-65" class="pilcrow">¶</a></div><p>Feel free to take a look at another example of using [streams in browser] (http://jeditoolkit.com/streamer/demos/axis.html). Or discover even more utility functions <a href="https://github.com/Gozala/streamer/blob/master/streamer.js">in the source</a></p></td><td><div class="highlight"><pre><code></code></pre></div></td></tr></tbody></table>
