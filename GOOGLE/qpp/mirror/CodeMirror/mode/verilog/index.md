CodeMirror: Verilog mode
========================

/\* Verilog demo code \*/ module butterfly \#( parameter WIDTH = 32, parameter MWIDTH = 1 ) ( input wire clk, input wire rst\_n, // m\_in contains data that passes through this block with no change. input wire \[MWIDTH-1:0\] m\_in, // The twiddle factor. input wire signed \[WIDTH-1:0\] w, // XA input wire signed \[WIDTH-1:0\] xa, // XB input wire signed \[WIDTH-1:0\] xb, // Set to 1 when new data is present on inputs. input wire x\_nd, // delayed version of m\_in. output reg \[MWIDTH-1:0\] m\_out, // YA = XA + W\*XB // YB = XA - W\*XB output wire signed \[WIDTH-1:0\] ya, output wire signed \[WIDTH-1:0\] yb, output reg y\_nd, output reg error ); // Set wire to the real and imag parts for convenience. wire signed \[WIDTH/2-1:0\] xa\_re; wire signed \[WIDTH/2-1:0\] xa\_im; assign xa\_re = xa\[WIDTH-1:WIDTH/2\]; assign xa\_im = xa\[WIDTH/2-1:0\]; wire signed \[WIDTH/2-1: 0\] ya\_re; wire signed \[WIDTH/2-1: 0\] ya\_im; assign ya = {ya\_re, ya\_im}; wire signed \[WIDTH/2-1: 0\] yb\_re; wire signed \[WIDTH/2-1: 0\] yb\_im; assign yb = {yb\_re, yb\_im}; // Delayed stuff. reg signed \[WIDTH/2-1:0\] xa\_re\_z; reg signed \[WIDTH/2-1:0\] xa\_im\_z; // Output of multiplier wire signed \[WIDTH-1:0\] xbw; wire signed \[WIDTH/2-1:0\] xbw\_re; wire signed \[WIDTH/2-1:0\] xbw\_im; assign xbw\_re = xbw\[WIDTH-1:WIDTH/2\]; assign xbw\_im = xbw\[WIDTH/2-1:0\]; // Do summing // I don't think we should get overflow here because of the // size of the twiddle factors. // If we do testing should catch it. assign ya\_re = xa\_re\_z + xbw\_re; assign ya\_im = xa\_im\_z + xbw\_im; assign yb\_re = xa\_re\_z - xbw\_re; assign yb\_im = xa\_im\_z - xbw\_im; // Create the multiply module. multiply\_complex \#(WIDTH) multiply\_complex\_0 (.clk(clk), .rst\_n(rst\_n), .x(xb), .y(w), .z(xbw) ); always @ (posedge clk) begin if (!rst\_n) begin y\_nd &lt;= 1'b0; error &lt;= 1'b0; end else begin // Set delay for x\_nd\_old and m. y\_nd &lt;= x\_nd; m\_out &lt;= m\_in; if (x\_nd) begin xa\_re\_z &lt;= xa\_re/2; xa\_im\_z &lt;= xa\_im/2; end end end endmodule

Simple mode that tries to handle Verilog-like languages as well as it can. Takes one configuration parameters: `keywords`, an object whose property names are the keywords in the language.

**MIME types defined:** `text/x-verilog` (Verilog code).
