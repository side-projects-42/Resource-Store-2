<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>index</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p>CodeMirror: XQuery mode</p>
<p><a href="http://codemirror.net"><img src="../../doc/logo.png" id="logo" /></a></p>
<ul>
<li><a href="../../index.html">Home</a></li>
<li><a href="../../doc/manual.html">Manual</a></li>
<li><a href="https://github.com/marijnh/codemirror">Code</a></li>
</ul>
<!-- -->
<ul>
<li><a href="../index.html">Language modes</a></li>
<li><a href="#" class="active">XQuery</a></li>
</ul>
<h2 id="xquery-mode">XQuery mode</h2>
<p>xquery version “1.0-ml”; (: this is : a “comment” :) let $let := &lt;x attr=“value”&gt;“test”&lt;func&gt;function() <span class="math inline">$var {function()} {$</span>var}&lt;/func&gt;&lt;/x&gt; let $joe:=1 return element element { attribute attribute { 1 }, element test { ‘a’ }, attribute foo { “bar” }, fn:doc()[ foo/<span class="citation" data-cites="bar">@bar</span> eq $let ], //x } (: a more ‘evil’ test :) (: Modified Blakeley example (: with nested comment :) … :) declare private function local:declare() {()}; declare private function local:private() {()}; declare private function local:function() {()}; declare private function local:local() {()}; let $let := &lt;let&gt;let <span class="math inline">$let := "let"&amp;lt;/let&amp;gt; return element element { attribute attribute { try { xdmp:version() } catch($</span>e) { xdmp:log($e) } }, attribute fn:doc { “bar” castable as xs:string }, element text { text { “text” } }, fn:doc()[ child::eq/(<span class="citation" data-cites="bar">@bar</span> | attribute::attribute) eq <span class="math inline">$let \], //fn:doc } xquery version "1.0-ml"; (: Copyright 2006-2010 Mark Logic Corporation. :) (: : Licensed under the Apache License, Version 2.0 (the "License"); : you may not use this file except in compliance with the License. : You may obtain a copy of the License at : : http://www.apache.org/licenses/LICENSE-2.0 : : Unless required by applicable law or agreed to in writing, software : distributed under the License is distributed on an "AS IS" BASIS, : WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. : See the License for the specific language governing permissions and : limitations under the License. :) module namespace json = "http://marklogic.com/json"; declare default function namespace "http://www.w3.org/2005/xpath-functions"; (: Need to backslash escape any double quotes, backslashes, and newlines :) declare function json:escape($</span>s as xs:string) as xs:string { let <span class="math inline"><em>s</em> := <em>r</em><em>e</em><em>p</em><em>l</em><em>a</em><em>c</em><em>e</em>(</span>s, “\\”, “\\\\”) let <span class="math inline"><em>s</em> := <em>r</em><em>e</em><em>p</em><em>l</em><em>a</em><em>c</em><em>e</em>(</span>s, """“,”\\""“) let <span class="math inline"><em>s</em> := <em>r</em><em>e</em><em>p</em><em>l</em><em>a</em><em>c</em><em>e</em>(</span>s, codepoints-to-string((13, 10)),”\\n“) let <span class="math inline"><em>s</em> := <em>r</em><em>e</em><em>p</em><em>l</em><em>a</em><em>c</em><em>e</em>(</span>s, codepoints-to-string(13),”\\n“) let <span class="math inline"><em>s</em> := <em>r</em><em>e</em><em>p</em><em>l</em><em>a</em><em>c</em><em>e</em>(</span>s, codepoints-to-string(10),”\\n“) return <span class="math inline">$s }; declare function json:atomize($</span>x as element()) as xs:string { if (count(<span class="math inline"><em>x</em>/<em>n</em><em>o</em><em>d</em><em>e</em>()) = 0)<em>t</em><em>h</em><em>e</em><em>n</em>′<em>n</em><em>u</em><em>l</em><em>l</em>′<em>e</em><em>l</em><em>s</em><em>e</em><em>i</em><em>f</em>(</span>x/<span class="citation" data-cites="type">@type</span> =”number“) then let $castable := $x castable as xs:float or $x castable as xs:double or <span class="math inline"><em>x</em><em>c</em><em>a</em><em>s</em><em>t</em><em>a</em><em>b</em><em>l</em><em>e</em><em>a</em><em>s</em><em>x</em><em>s</em> : <em>d</em><em>e</em><em>c</em><em>i</em><em>m</em><em>a</em><em>l</em><em>r</em><em>e</em><em>t</em><em>u</em><em>r</em><em>n</em><em>i</em><em>f</em>(</span>castable) then xs:string(<span class="math inline">$x) else error(concat("Not a number: ", xdmp:describe($</span>x))) else if ($x/<span class="citation" data-cites="type">@type</span> =”boolean“) then let $castable := <span class="math inline"><em>x</em><em>c</em><em>a</em><em>s</em><em>t</em><em>a</em><em>b</em><em>l</em><em>e</em><em>a</em><em>s</em><em>x</em><em>s</em> : <em>b</em><em>o</em><em>o</em><em>l</em><em>e</em><em>a</em><em>n</em><em>r</em><em>e</em><em>t</em><em>u</em><em>r</em><em>n</em><em>i</em><em>f</em>(</span>castable) then xs:string(xs:boolean(<span class="math inline">$x)) else error(concat("Not a boolean: ", xdmp:describe($</span>x))) else concat(‘“‘, json:escape(<span class="math inline">$x), '"') }; (: Print the thing that comes after the colon :) declare function json:print-value($</span>x as element()) as xs:string { if (count(<span class="math inline">$x/\*) = 0) then json:atomize($</span>x) else if (<span class="math inline">$x/@quote = "true") then concat('"', json:escape(xdmp:quote($</span>x/node())),’”’) else string-join((‘{’, string-join(for $i in <span class="math inline">$x/\* return json:print-name-value($</span>i),”,“), ‘}’),”“) }; (: Print the name and value both :) declare function json:print-name-value($x as element()) as xs:string? { let <span class="math inline"><em>n</em><em>a</em><em>m</em><em>e</em> := <em>n</em><em>a</em><em>m</em><em>e</em>(</span>x) let <span class="math inline"><em>f</em><em>i</em><em>r</em><em>s</em><em>t</em> − <em>i</em><em>n</em> − <em>a</em><em>r</em><em>r</em><em>a</em><em>y</em> := <em>c</em><em>o</em><em>u</em><em>n</em><em>t</em>(</span>x/preceding-sibling::*[name(.) = <span class="math inline">$name\]) = 0 and (count($</span>x/following-sibling::*[name(.) = $name]) &gt; 0 or $x/<span class="citation" data-cites="array">@array</span> =”true“) let <span class="math inline"><em>l</em><em>a</em><em>t</em><em>e</em><em>r</em> − <em>i</em><em>n</em> − <em>a</em><em>r</em><em>r</em><em>a</em><em>y</em> := <em>c</em><em>o</em><em>u</em><em>n</em><em>t</em>(</span>x/preceding-sibling::*[name(.) = <span class="math inline">$name\]) &amp;gt; 0 return if ($</span>later-in-array) then () (: I was handled previously :) else if (<span class="math inline">$first-in-array) then string-join(('"', json:escape($</span>name), ‘“:[‘, string-join((for <span class="math inline"><em>i</em><em>i</em><em>n</em>(</span>x, $x/following-sibling::*[name(.) = <span class="math inline">$name\]) return json:print-value($</span>i)), “,”),’]‘), "“) else string-join((’”’, json:escape(<span class="math inline">$name), '":', json:print-value($</span>x)),”“) }; (:~ Transforms an XML element into a JSON string representation. See http://json.org. &lt;p/&gt; Sample usage: &lt;pre&gt; xquery version”1.0-ml“; import module namespace json=”http://marklogic.com/json" at “json.xqy”; json:serialize(&lt;foo&gt;&lt;bar&gt;kid&lt;/bar&gt;&lt;/foo&gt;) &lt;/pre&gt; Sample transformations: &lt;pre&gt; &lt;e/&gt; becomes {“e”:null} &lt;e&gt;text&lt;/e&gt; becomes {“e”:“text”} &lt;e&gt;quote " escaping&lt;/e&gt; becomes {“e”:“quote \” escaping“} &lt;e&gt;backslash \ escaping&lt;/e&gt; becomes {”e“:”backslash \\ escaping“} &lt;e&gt;&lt;a&gt;text1&lt;/a&gt;&lt;b&gt;text2&lt;/b&gt;&lt;/e&gt; becomes {”e“:{”a“:”text1“,”b“:”text2“}} &lt;e&gt;&lt;a&gt;text1&lt;/a&gt;&lt;a&gt;text2&lt;/a&gt;&lt;/e&gt; becomes {”e“:{”a“:[”text1“,”text2“]}} &lt;e&gt;&lt;a array=”true“&gt;text1&lt;/a&gt;&lt;/e&gt; becomes {”e“:{”a“:[”text1“]}} &lt;e&gt;&lt;a type=”boolean“&gt;false&lt;/a&gt;&lt;/e&gt; becomes {”e“:{”a“:false}} &lt;e&gt;&lt;a type=”number“&gt;123.5&lt;/a&gt;&lt;/e&gt; becomes {”e“:{”a“:123.5}} &lt;e quote=”true“&gt;&lt;div attrib=”value“/&gt;&lt;/e&gt; becomes {”e“:”&lt;div attrib=\“value\”/&gt;“} &lt;/pre&gt; &lt;p/&gt; Namespace URIs are ignored. Namespace prefixes are included in the JSON name. &lt;p/&gt; Attributes are ignored, except for the special attribute <span class="citation" data-cites="array">@array</span>=”true" that indicates the JSON serialization should write the node, even if single, as an array, and the attribute <span class="citation" data-cites="type">@type</span> that can be set to “boolean” or “number” to dictate the value should be written as that type (unquoted). There’s also an <span class="citation" data-cites="quote">@quote</span> attribute that when set to true writes the inner content as text rather than as structured JSON, useful for sending some XHTML over the wire. &lt;p/&gt; Text nodes within mixed content are ignored. <span class="citation" data-cites="param">@param</span> $x Element node to convert <span class="citation" data-cites="return">@return</span> String holding JSON serialized representation of <span class="math inline"><em>x</em>@<em>a</em><em>u</em><em>t</em><em>h</em><em>o</em><em>r</em><em>J</em><em>a</em><em>s</em><em>o</em><em>n</em><em>H</em><em>u</em><em>n</em><em>t</em><em>e</em><em>r</em>@<em>v</em><em>e</em><em>r</em><em>s</em><em>i</em><em>o</em><em>n</em>1.0.1<em>P</em><em>o</em><em>r</em><em>t</em><em>e</em><em>d</em><em>t</em><em>o</em><em>x</em><em>q</em><em>u</em><em>e</em><em>r</em><em>y</em>1.0 − <em>m</em><em>l</em>; <em>d</em><em>o</em><em>u</em><em>b</em><em>l</em><em>e</em><em>e</em><em>s</em><em>c</em><em>a</em><em>p</em><em>e</em><em>d</em><em>b</em><em>a</em><em>c</em><em>k</em><em>s</em><em>l</em><em>a</em><em>s</em><em>h</em><em>e</em><em>s</em><em>i</em><em>n</em><em>j</em><em>s</em><em>o</em><em>n</em> : <em>e</em><em>s</em><em>c</em><em>a</em><em>p</em><em>e</em> : )<em>d</em><em>e</em><em>c</em><em>l</em><em>a</em><em>r</em><em>e</em><em>f</em><em>u</em><em>n</em><em>c</em><em>t</em><em>i</em><em>o</em><em>n</em><em>j</em><em>s</em><em>o</em><em>n</em> : <em>s</em><em>e</em><em>r</em><em>i</em><em>a</em><em>l</em><em>i</em><em>z</em><em>e</em>(</span>x as element()) as xs:string { string-join((’{‘, json:print-name-value($x),’}’),”") };</p>
<p><strong>MIME types defined:</strong> <code>application/xquery</code>.</p>
<p>Development of the CodeMirror XQuery mode was sponsored by <a href="http://marklogic.com">MarkLogic</a> and developed by <a href="https://twitter.com/mbrevoort">Mike Brevoort</a>.</p>
</body>
</html>
