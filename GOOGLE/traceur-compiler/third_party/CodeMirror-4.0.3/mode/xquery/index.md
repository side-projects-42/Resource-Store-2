CodeMirror: XQuery mode

[<img src="../../doc/logo.png" id="logo" />](http://codemirror.net)

-   [Home](../../index.html)
-   [Manual](../../doc/manual.html)
-   [Code](https://github.com/marijnh/codemirror)

<!-- -->

-   [Language modes](../index.html)
-   <a href="#" class="active">XQuery</a>

XQuery mode
-----------

xquery version “1.0-ml”; (: this is : a “comment” :) let $let := &lt;x attr=“value”&gt;“test”&lt;func&gt;function() <span class="math inline">$var {function()} {$</span>var}&lt;/func&gt;&lt;/x&gt; let $joe:=1 return element element { attribute attribute { 1 }, element test { ‘a’ }, attribute foo { “bar” }, fn:doc()\[ foo/<span class="citation" data-cites="bar">@bar</span> eq $let \], //x } (: a more ‘evil’ test :) (: Modified Blakeley example (: with nested comment :) … :) declare private function local:declare() {()}; declare private function local:private() {()}; declare private function local:function() {()}; declare private function local:local() {()}; let $let := &lt;let&gt;let <span class="math inline">$let := "let"&lt;/let&gt; return element element { attribute attribute { try { xdmp:version() } catch($</span>e) { xdmp:log($e) } }, attribute fn:doc { “bar” castable as xs:string }, element text { text { “text” } }, fn:doc()\[ child::eq/(<span class="citation" data-cites="bar">@bar</span> | attribute::attribute) eq <span class="math inline">$let \\\], //fn:doc } xquery version "1.0-ml"; (: Copyright 2006-2010 Mark Logic Corporation. :) (: : Licensed under the Apache License, Version 2.0 (the "License"); : you may not use this file except in compliance with the License. : You may obtain a copy of the License at : : http://www.apache.org/licenses/LICENSE-2.0 : : Unless required by applicable law or agreed to in writing, software : distributed under the License is distributed on an "AS IS" BASIS, : WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. : See the License for the specific language governing permissions and : limitations under the License. :) module namespace json = "http://marklogic.com/json"; declare default function namespace "http://www.w3.org/2005/xpath-functions"; (: Need to backslash escape any double quotes, backslashes, and newlines :) declare function json:escape($</span>s as xs:string) as xs:string { let <span class="math inline">*s* := *replace*(</span>s, “\\\\”, “\\\\\\\\”) let <span class="math inline">*s* := *replace*(</span>s, """“,”\\\\""“) let <span class="math inline">*s* := *replace*(</span>s, codepoints-to-string((13, 10)),”\\\\n“) let <span class="math inline">*s* := *replace*(</span>s, codepoints-to-string(13),”\\\\n“) let <span class="math inline">*s* := *replace*(</span>s, codepoints-to-string(10),”\\\\n“) return <span class="math inline">$s }; declare function json:atomize($</span>x as element()) as xs:string { if (count(<span class="math inline">*x*/*node*()) = 0)*then*′*null*′*elseif*(</span>x/<span class="citation" data-cites="type">@type</span> =”number“) then let $castable := $x castable as xs:float or $x castable as xs:double or <span class="math inline">*xcastableasxs* : *decimalreturnif*(</span>castable) then xs:string(<span class="math inline">$x) else error(concat("Not a number: ", xdmp:describe($</span>x))) else if ($x/<span class="citation" data-cites="type">@type</span> =”boolean“) then let $castable := <span class="math inline">*xcastableasxs* : *booleanreturnif*(</span>castable) then xs:string(xs:boolean(<span class="math inline">$x)) else error(concat("Not a boolean: ", xdmp:describe($</span>x))) else concat(‘“‘, json:escape(<span class="math inline">$x), '"') }; (: Print the thing that comes after the colon :) declare function json:print-value($</span>x as element()) as xs:string { if (count(<span class="math inline">$x/\\\*) = 0) then json:atomize($</span>x) else if (<span class="math inline">$x/@quote = "true") then concat('"', json:escape(xdmp:quote($</span>x/node())),’”’) else string-join((‘{’, string-join(for $i in <span class="math inline">$x/\\\* return json:print-name-value($</span>i),”,“), ‘}’),”“) }; (: Print the name and value both :) declare function json:print-name-value($x as element()) as xs:string? { let <span class="math inline">*name* := *name*(</span>x) let <span class="math inline">*first* − *in* − *array* := *count*(</span>x/preceding-sibling::\*\[name(.) = <span class="math inline">$name\\\]) = 0 and (count($</span>x/following-sibling::\*\[name(.) = $name\]) &gt; 0 or $x/<span class="citation" data-cites="array">@array</span> =”true“) let <span class="math inline">*later* − *in* − *array* := *count*(</span>x/preceding-sibling::\*\[name(.) = <span class="math inline">$name\\\]) &gt; 0 return if ($</span>later-in-array) then () (: I was handled previously :) else if (<span class="math inline">$first-in-array) then string-join(('"', json:escape($</span>name), ‘“:\[‘, string-join((for <span class="math inline">*iin*(</span>x, $x/following-sibling::\*\[name(.) = <span class="math inline">$name\\\]) return json:print-value($</span>i)), “,”),’\]‘), "“) else string-join((’”’, json:escape(<span class="math inline">$name), '":', json:print-value($</span>x)),”“) }; (:~ Transforms an XML element into a JSON string representation. See http://json.org. &lt;p/&gt; Sample usage: &lt;pre&gt; xquery version”1.0-ml“; import module namespace json=”http://marklogic.com/json" at “json.xqy”; json:serialize(&lt;foo&gt;&lt;bar&gt;kid&lt;/bar&gt;&lt;/foo&gt;) &lt;/pre&gt; Sample transformations: &lt;pre&gt; &lt;e/&gt; becomes {“e”:null} &lt;e&gt;text&lt;/e&gt; becomes {“e”:“text”} &lt;e&gt;quote " escaping&lt;/e&gt; becomes {“e”:“quote \\” escaping“} &lt;e&gt;backslash \\ escaping&lt;/e&gt; becomes {”e“:”backslash \\\\ escaping“} &lt;e&gt;&lt;a&gt;text1&lt;/a&gt;&lt;b&gt;text2&lt;/b&gt;&lt;/e&gt; becomes {”e“:{”a“:”text1“,”b“:”text2“}} &lt;e&gt;&lt;a&gt;text1&lt;/a&gt;&lt;a&gt;text2&lt;/a&gt;&lt;/e&gt; becomes {”e“:{”a“:\[”text1“,”text2“\]}} &lt;e&gt;&lt;a array=”true“&gt;text1&lt;/a&gt;&lt;/e&gt; becomes {”e“:{”a“:\[”text1“\]}} &lt;e&gt;&lt;a type=”boolean“&gt;false&lt;/a&gt;&lt;/e&gt; becomes {”e“:{”a“:false}} &lt;e&gt;&lt;a type=”number“&gt;123.5&lt;/a&gt;&lt;/e&gt; becomes {”e“:{”a“:123.5}} &lt;e quote=”true“&gt;&lt;div attrib=”value“/&gt;&lt;/e&gt; becomes {”e“:”&lt;div attrib=\\“value\\”/&gt;“} &lt;/pre&gt; &lt;p/&gt; Namespace URIs are ignored. Namespace prefixes are included in the JSON name. &lt;p/&gt; Attributes are ignored, except for the special attribute <span class="citation" data-cites="array">@array</span>=”true" that indicates the JSON serialization should write the node, even if single, as an array, and the attribute <span class="citation" data-cites="type">@type</span> that can be set to “boolean” or “number” to dictate the value should be written as that type (unquoted). There’s also an <span class="citation" data-cites="quote">@quote</span> attribute that when set to true writes the inner content as text rather than as structured JSON, useful for sending some XHTML over the wire. &lt;p/&gt; Text nodes within mixed content are ignored. <span class="citation" data-cites="param">@param</span> $x Element node to convert <span class="citation" data-cites="return">@return</span> String holding JSON serialized representation of <span class="math inline">*x*@*authorJasonHunter*@*version*1.0.1*Portedtoxquery*1.0 − *ml*; *doubleescapedbackslashesinjson* : *escape* : )*declarefunctionjson* : *serialize*(</span>x as element()) as xs:string { string-join((’{‘, json:print-name-value($x),’}’),”") };

**MIME types defined:** `application/xquery`.

Development of the CodeMirror XQuery mode was sponsored by [MarkLogic](http://marklogic.com) and developed by [Mike Brevoort](https://twitter.com/mbrevoort).
