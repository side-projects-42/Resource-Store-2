CodeMirror: D mode

[<img src="../../doc/logo.png" id="logo" />](http://codemirror.net)

-   [Home](../../index.html)
-   [Manual](../../doc/manual.html)
-   [Code](https://github.com/marijnh/codemirror)

<!-- -->

-   [Language modes](../index.html)
-   <a href="#" class="active">D</a>

D mode
------

/\* D demo code // copied from phobos/sd/metastrings.d \*/ // Written in the D programming language. /\*\* Templates with which to do compile-time manipulation of strings. Macros: WIKI = Phobos/StdMetastrings Copyright: Copyright Digital Mars 2007 - 2009. License: [Boost License 1.0](http://www.boost.org/LICENSE_1_0.txt). Authors: $(WEB digitalmars.com, Walter Bright), Don Clugston Source: $(PHOBOSSRC std/\_metastrings.d) \*/ /\* Copyright Digital Mars 2007 - 2009. Distributed under the Boost Software License, Version 1.0. (See accompanying file LICENSE\_1\_0.txt or copy at http://www.boost.org/LICENSE\_1\_0.txt) \*/ module std.metastrings; /\*\* Formats constants into a string at compile time. Analogous to <span class="math inline">$(XREF string,format). Parameters: A = tuple of constants, which can be strings, characters, or integral values. Formats: \\\* The formats supported are %s for strings, and %% \\\* for the % character. Example: --- import std.metastrings; import std.stdio; void main() { string s = Format!("Arg %s = %s", "foo", 27); writefln(s); // "Arg foo = 27" } \\\* --- \\\*/ template Format(A...) { static if (A.length == 0) enum Format = ""; else static if (is(typeof(A\\\[0\\\]) : const(char)\\\[\\\])) enum Format = FormatString!(A\\\[0\\\], A\\\[1..$</span>\]); else enum Format = toStringNow!(A\[0\]) ~ Format!(A\[1..<span class="math inline">$\\\]); } template FormatString(const(char)\\\[\\\] F, A...) { static if (F.length == 0) enum FormatString = Format!(A); else static if (F.length == 1) enum FormatString = F\\\[0\\\] ~ Format!(A); else static if (F\\\[0..2\\\] == "%s") enum FormatString = toStringNow!(A\\\[0\\\]) ~ FormatString!(F\\\[2..$</span>\],A\[1..<span class="math inline">$\\\]); else static if (F\\\[0..2\\\] == "%%") enum FormatString = "%" ~ FormatString!(F\\\[2..$</span>\],A); else { static assert(F\[0\] != ‘%’, “unrecognized format %” ~ F\[1\]); enum FormatString = F\[0\] ~ FormatString!(F\[1..<span class="math inline">$\\\],A); } } unittest { auto s = Format!("hel%slo", "world", -138, 'c', true); assert(s == "helworldlo-138ctrue", "\\\[" ~ s ~ "\\\]"); } /\\\*\\\* \\\* Convert constant argument to a string. \\\*/ template toStringNow(ulong v) { static if (v &lt; 10) enum toStringNow = "" ~ cast(char)(v + '0'); else enum toStringNow = toStringNow!(v / 10) ~ toStringNow!(v % 10); } unittest { static assert(toStringNow!(1uL &lt;&lt; 62) == "4611686018427387904"); } /// ditto template toStringNow(long v) { static if (v &lt; 0) enum toStringNow = "-" ~ toStringNow!(cast(ulong) -v); else enum toStringNow = toStringNow!(cast(ulong) v); } unittest { static assert(toStringNow!(0x100000000) == "4294967296"); static assert(toStringNow!(-138L) == "-138"); } /// ditto template toStringNow(uint U) { enum toStringNow = toStringNow!(cast(ulong)U); } /// ditto template toStringNow(int I) { enum toStringNow = toStringNow!(cast(long)I); } /// ditto template toStringNow(bool B) { enum toStringNow = B ? "true" : "false"; } /// ditto template toStringNow(string S) { enum toStringNow = S; } /// ditto template toStringNow(char C) { enum toStringNow = "" ~ C; } /\\\*\\\*\\\*\\\*\\\*\\\*\\\*\\\* \\\* Parse unsigned integer literal from the start of string s. \\\* returns: \\\* .value = the integer literal as a string, \\\* .rest = the string following the integer literal \\\* Otherwise: \\\* .value = null, \\\* .rest = s \\\*/ template parseUinteger(const(char)\\\[\\\] s) { static if (s.length == 0) { enum value = ""; enum rest = ""; } else static if (s\\\[0\\\] &gt;= '0' && s\\\[0\\\] &lt;= '9') { enum value = s\\\[0\\\] ~ parseUinteger!(s\\\[1..$</span>\]).value; enum rest = parseUinteger!(s\[1..$\]).rest; } else { enum value = "“; enum rest = s; } } /\*\*\*\*\*\*\*\* Parse integer literal optionally preceded by $(D ‘-’) from the start of string <span class="math inline">$(D s). Returns: .value = the integer literal as a string, .rest = the string following the integer literal Otherwise: .value = null, .rest = s \\\*/ template parseInteger(const(char)\\\[\\\] s) { static if (s.length == 0) { enum value = ""; enum rest = ""; } else static if (s\\\[0\\\] &gt;= '0' && s\\\[0\\\] &lt;= '9') { enum value = s\\\[0\\\] ~ parseUinteger!(s\\\[1..$</span>\]).value; enum rest = parseUinteger!(s\[1..<span class="math inline">$\\\]).rest; } else static if (s.length &gt;= 2 && s\\\[0\\\] == '-' && s\\\[1\\\] &gt;= '0' && s\\\[1\\\] &lt;= '9') { enum value = s\\\[0..2\\\] ~ parseUinteger!(s\\\[2..$</span>\]).value; enum rest = parseUinteger!(s\[2..$\]).rest; } else { enum value =”“; enum rest = s; } } unittest { assert(parseUinteger!(”1234abc“).value ==”1234“); assert(parseUinteger!(”1234abc“).rest ==”abc“); assert(parseInteger!(”-1234abc“).value ==”-1234“); assert(parseInteger!(”-1234abc“).rest ==”abc"); } /\*\* Deprecated aliases held for backward compatibility. \*/ deprecated alias toStringNow ToString; /// Ditto deprecated alias parseUinteger ParseUinteger; /// Ditto deprecated alias parseUinteger ParseInteger;

Simple mode that handle D-Syntax ([DLang Homepage](http://www.dlang.org)).

**MIME types defined:** `text/x-d` .
