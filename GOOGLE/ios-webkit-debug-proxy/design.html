<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>design</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p>Google BSD license <a href="https://developers.google.com/google-bsd-license" class="uri">https://developers.google.com/google-bsd-license</a><br />
Copyright 2012 Google Inc. <a href="mailto:wrightt@google.com" class="email">wrightt@google.com</a></p>
<h1 id="ios-webkit-debug-proxy-design">iOS WebKit Debug Proxy Design</h1>
<p>See the <a href="README.md">README.md</a> for an overview.</p>
<h2 id="source">Source</h2>
<ul>
<li><a href="src/ios_webkit_debug_proxy_main.c">src/ios_webkit_debug_proxy_main.c</a>
<ul>
<li>The “main”</li>
</ul></li>
<li><a href="src/ios_webkit_debug_proxy.c">src/ios_webkit_debug_proxy.c</a>
<ul>
<li>WebInspector to WebKit Remote Debugging Protocol translator<br />
</li>
<li>See <a href="examples/wdp_client.js">examples/wdp_client.js</a> and <a href="http://localhost:9221" class="uri">http://localhost:9221</a></li>
</ul></li>
<li><a href="src/webinspector.c">src/webinspector.c</a>
<ul>
<li>iOS WebInspector library<br />
</li>
<li>See <a href="examples/wi_client.c">examples/wi_client.c</a> - See <a href="src/rpc.c">src/rpc.c</a> parser</li>
</ul></li>
<li><a href="src/device_listener.c">src/device_listener.c</a>
<ul>
<li>iOS device add/remove listener<br />
</li>
<li>See <a href="examples/dl_client.c">examples/dl_client.c</a></li>
</ul></li>
<li><a href="src/websocket.c">src/websocket.c</a>
<ul>
<li>A generic WebSocket library<br />
</li>
<li>Uses base64.c and sha1.c from <a href="http://www.polarssl.org">PolarSSL</a><br />
</li>
<li>See <a href="examples/ws_echo1.c">examples/ws_echo1.c</a> and <a href="examples/ws_echo2.c">examples/ws_echo2.c</a></li>
</ul></li>
<li>Utilities:
<ul>
<li><a href="src/char_buffer.c">src/char_buffer.c</a> byte buffer<br />
</li>
<li><a href="src/hash_table.c">src/hash_table.c</a> dictionary<br />
</li>
<li><a href="src/port_config.c">src/port_config.c</a> parses device_id:port config files<br />
</li>
<li><a href="src/socket_manager.c">src/socket_manager.c</a> select-based socket controller</li>
</ul></li>
</ul>
<h2 id="architecture">Architecture</h2>
<p>The high-level design is shown below:</p>
<figure>
<img src="overview.png" title="Overview" alt="Alt overview" /><figcaption>Alt overview</figcaption>
</figure>
<p>The various clients are shown below:</p>
<figure>
<img src="clients.png" title="Clients" alt="Alt clients" /><figcaption>Alt clients</figcaption>
</figure>
<p>The major components of the ios_webkit_debug_proxy are:</p>
<ol type="1">
<li>A device_listener that listens for iOS device add/remove events</li>
<li>A (port, webinspector) pair for each device, e.g.:
<ul>
<li>[(port 9222 &lt;–&gt; iphoneX’s inspector),</li>
<li>(port 9223 &lt;–&gt; iphoneY’s inspector), …]</li>
</ul></li>
<li>Zero or more active WebSocket clients, e.g.:
<ul>
<li>[websocketA is connected to :9222/devtools/page/7, …]</li>
</ul></li>
<li>A socket_manager that handles all the socket I/O</li>
</ol>
<p>The code is object-oriented via the use of structs and function pointers. For example, the device_listener struct defines two “public API” functions:</p>
<pre><code>dl_status (*start)(dl_t self);
dl_status (*on_recv)(dl_t self, const char *buf, );</code></pre>
<p>and three “abstract” callback functions:</p>
<pre><code>dl_status (*send)(dl_t self, const char *buf, size_t length);
dl_status (*on_attach)(dl_t self, const char *device_id);
dl_status (*on_detach)(dl_t self, const char *device_id);</code></pre>
<p>plus a field for client use:</p>
<pre><code>void *state;</code></pre>
<p>For example, <a href="examples/dl_client.c">examples/dl_client.c</a> creates a listener and sets the missing callbacks:</p>
<pre><code>int fd = dl_connect();
dl_t dl = dl_new(); // sets the &quot;start&quot; and &quot;on_recv&quot; functions
dl-&gt;state = fd;     // for use by &quot;my_send&quot;
dl-&gt;send = my_send; // --&gt; send((int)dl-&gt;state, buf, length);
dl-&gt;on_attach = my_on_attach; // --&gt; printf(&quot;%s&quot;, device_id);
dl-&gt;on_detach = my_on_detach; // --&gt; ditto</code></pre>
<p>then does:</p>
<pre><code>dl-&gt;start();</code></pre>
<p>Lastly, the client forwards all socket input to the listener’s “on_recv” handler:</p>
<pre><code>char buf[1024];
while (1) {
   int len = recv(fd, buf, 1024);
   if (dl-&gt;on_recv(dl, buf, len)) break;
}</code></pre>
<p>where “on_recv” buffers the input and calls our “my_on_message” when it has a full message.</p>
<p>Note that the “on_recv” and “send” functions abstract the I/O from the interface, which simplifies debugging and unit testing.</p>
<p>The detailed design is shown below:</p>
<figure>
<img src="design.png" title="Design" alt="Alt design" /><figcaption>Alt design</figcaption>
</figure>
<p>Lines in red are controlled by the main “ios_webkit_debug_proxy”. For example, although the figure shows a direct red line from the socket_manager’s “on_recv” to the ios_webkit_debug_proxy’s handler, this is implemented as a callback through ios_webkit_debug_proxy_main’s “iwdpm_on_recv(…)”. This design isolate the components from one another and simplifies both offline and per-component unit testing.</p>
<p>The code is single-threaded and uses non-blocking I/O. Instead of having a thread per socket that does blocking reads, the single socket_manager’s non-blocking select forwards data to the “on_recv” function of websocket/webinspector/etc. This improves system scalability and makes it easier to debug and unit test.</p>
</body>
</html>
