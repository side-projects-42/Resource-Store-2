<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>wtf-trace</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="wtf-trace-file-format">wtf-trace File Format</h1>
<p><strong><em>WARNING: the JSON format is not yet implemented!</em></strong></p>
<p>Also known as the Chunked File Format. Code for this lives in wtf.io.cff.</p>
<p>The Chunked File Format (CFF) is an extensible, versioned skeleton that allows for data to be stored in both binary and JSON format. It’s possible to convert files between the two formats to allow for easy hand editing in the rare cases where that may be required but keep it in a compact, fast to generate and parse format otherwise.</p>
<p>Files are made up of typed chunks that contain typed parts. Parsers may ignore chunks and parts they don’t understand allowing for basic forwards compatibility. Backwards compatibility can be maintained by interpreting chunks and parts in new ways or by preserving legacy code.</p>
<p>When encoded as binary files in this format are designed for efficient construction during recording, streaming and partial loading, and very large file sizes. It’s not human readable and isn’t designed to be easy to write parsers for. If custom tools or readability is important see the JSON file format instead.</p>
<h2 id="file-layout">File Layout</h2>
<p>Each file consists of a header and a variable number of chunked data blobs.</p>
<h3 id="binary">Binary</h3>
<p>The code for this is in <code>wtf.io.cff.BinaryStreamSource</code> and <code>wtf.io.cff.BinaryStreamTarget</code>.</p>
<pre><code>- 4b magic number: 0xDEADBEEF
- 4b WTF version: wtf.version.getValue()
- 4b format version: wtf.data.formats.BinaryTrace.VERSION
- chunk 0 (file header)
  - header data
- chunk 1 (event data)
  - string table for event data in chunk
  - large embedded resource used in chunk
  - large embedded resource used in chunk
  - event data
- chunk 2 (event data)
  - string table for event data in chunk
  - event data
- ...</code></pre>
<p>Note: all values in little-endian.</p>
<h3 id="json">JSON</h3>
<p>The code for this is in <code>wtf.io.cff.JsonStreamSource</code> and <code>wtf.io.cff.JsonStreamTarget</code>.</p>
<h4 id="json-in-complete-mode">JSON in COMPLETE Mode</h4>
<p>In ‘COMPLETE’ mode the JSON string will be built over the course of a write operation and will be written out whole as a well-formed JSON blob. This means that there will be no trailing commas, etc. This makes it easy to load the files in standard JSON tools.</p>
<pre><code>{
  &quot;wtf_version&quot;: wtf.version.getValue(),
  &quot;format_version&quot;: wtf.data.formats.ChunkedFileFormat.VERSION,
  &quot;chunks&quot;: [
    { chunk 0 },
    { chunk 1 },
    { chunk N }
  ]
}</code></pre>
<h4 id="json-in-partial-mode">JSON in PARTIAL Mode</h4>
<p>In ‘PARTIAL’ mode the JSON will be written incrementally as a set of standalone JSON fragments. This makes it possible to stream the JSON fragments and load them without requiring the entire document to be present.</p>
<pre><code>// File header write:
{
  &quot;wtf_version&quot;: wtf.version.getValue(),
  &quot;format_version&quot;: wtf.data.formats.ChunkedFileFormat.VERSION,
}

// For each subsequent chunk write:
{ single chunk data }</code></pre>
<h2 id="chunks">Chunks</h2>
<p>All data within the file is organized into chunks. There are several chunk types designed to each hold different data types. Content in one chunk may not reference content in another, to ensure streaming and file slicing.</p>
<p>Each chunk consists of a small header plus a variable number of multiple parts. The parts present in a chunk vary from type to type.</p>
<h3 id="binary-1">Binary</h3>
<p>All part data within a chunk is aligned to 4b boundaries.</p>
<pre><code>4b  chunk id
4b  chunk type
4b  chunk length (including header)
4b  chunk starting time/value
4b  chunk ending time/value
4b  part count
list of length part count
4b  part type
4b  part offset in chunk (from header end)
4b  part length
/list
*   chunk data, if any</code></pre>
<h3 id="json-1">JSON</h3>
<pre><code>{
  &quot;id&quot;: numerical id,
  &quot;type&quot;: &quot;type&quot;,                           // from wtf.io.cff.ChunkType
  &quot;startTime&quot;: date time of start of data,  // optional
  &quot;endTime&quot;: date time of start of data,    // optional
  &quot;parts&quot;: [
    ... parts ...
  ]
}</code></pre>
<h2 id="chunk-types">Chunk Types</h2>
<h3 id="chunk-type-0x1file_header-file-header">Chunk Type 0x1/file_header: File Header</h3>
<p>The header chunk must be the first chunk in the file and contains the header data part used to describe the file.</p>
<p>Contains the following parts:</p>
<ul>
<li>File Header (required, only one)</li>
</ul>
<h3 id="chunk-type-0x2event_data-event-data">Chunk Type 0x2/event_data: Event Data</h3>
<p>Event data chunks contain an optional string table used by the actual event data buffer, optional binary resources referenced used by the event data, and finally the event data buffer itself.</p>
<p>Contains the following parts:</p>
<ul>
<li>Event Buffer (required, only one)</li>
<li>String Table (optional, only one)</li>
<li>Embedded Resource (optional, multiple allowed)</li>
</ul>
<p>Event data is read forward and all required information must be present by the time it starts parsing. Because of this event data must only reference data such as resources that are contained within its own chunk.</p>
<h2 id="chunk-part-types">Chunk Part Types</h2>
<h3 id="part-type-0x10000file_header-file-header">Part Type 0x10000/file_header: File Header</h3>
<p>The file header is encoded in JSON.</p>
<pre><code>{
  // General information:
  &quot;flags&quot;: [], // Strings representing a bitmask of wtf.data.formats.FileFlags.
  &quot;timebase&quot;: 123, // All times are relative to this.

  // The result of wtf.data.ScriptContextInfo.serialize:
  &quot;contextInfo&quot;: {
    // Required:
    &quot;contextType&quot;: &quot;script&quot;,
    &quot;uri&quot;: &quot;http://...&quot;,

    // Optional:
    &quot;title&quot;: &quot;My page&quot;,
    &quot;icon&quot;: {
      &quot;uri&quot;: &quot;http://...&quot;
    },
    &quot;taskId&quot;: &quot;process ID/etc&quot;,
    &quot;args&quot;: [arguments used on startup],
    &quot;userAgent&quot;: {
      &quot;value&quot;: &quot;user agent string&quot;,
      &quot;type&quot;: &quot;unknown|nodejs|opera|ie|gecko|webkit&quot;,
      &quot;platform&quot;: &quot;mac|windows|linux|other&quot;,
      &quot;platformVersion&quot;: &quot;OS version/etc&quot;,
      &quot;device&quot;: &quot;desktop|server|chrome|iphone|ipad|android|mobile&quot;
    }
  },

  // Optional:
  &quot;metadata&quot;: {
    // Various information values.
  }
}</code></pre>
<h3 id="part-type-0x20000json_event_buffer-json-format-event-buffer">Part Type 0x20000/json_event_buffer: JSON-format Event Buffer</h3>
<p>TODO</p>
<h3 id="part-type-0x20002binary_event_buffer-binary-format-event-buffer">Part Type 0x20002/binary_event_buffer: Binary-format Event Buffer</h3>
<p>Each event data entry shares a standard header followed by a variable number of bytes containing the event-specific arguments:</p>
<pre><code>4b  event wire ID
4b  time/value
*   argument data, if any</code></pre>
<h4 id="event-types-wire-ids">Event Types / Wire IDs</h4>
<p>Events are defined using the special <code>wtf.event#define</code> event that is built into the file loader. This is the only implicitly defined event and all others must be defined by the file. This event maps data from <code>wtf.trace.EventType</code>.</p>
<pre><code>wtf.event#define(uint16 wireId, uint16 eventClass, uint32 flags,
                 ascii name, ascii args)</code></pre>
<p>For efficiency an indirection table is built while the file is loaded. New events are defined in the file and are assigned a wire ID that is used to reference the event type in future entries. Events must be defined before any entry tries to reference its wire ID. The wire ID of <code>wtf.event#define</code> is always 1.</p>
<h4 id="argument-data">Argument Data</h4>
<p>There are many types of argument data values. See <code>wtf.trace.EventTypeBuilder</code> for the full list and how each is written into the file. In general, they follow the write* methods from <code>wtf.io.Buffer</code>.</p>
<h4 id="zones">Zones</h4>
<p>Events are attributed to zones of execution. Zones must be created via <code>wtf.zone#create</code> events and then made active via <code>wtf.zone#set</code>.</p>
<p>Typical flows look like this:</p>
<pre><code>wtf.event#define(... wtf.zone#create ...)
wtf.event#define(... wtf.zone#set ...)
wtf.event#define(... myEvent ...)
wtf.zone#create(zoneId=5, ...)
wtf.zone#create(zoneId=6, ...)
wtf.zone#set(zoneId=5)
myEvent() // in zone 5
myEvent() // also in zone 5, as it&#39;s a sticky setting
wtf.zone#set(zoneId=6)
myEvent() // in zone 6</code></pre>
<h3 id="part-type-0x30000string_table-string-table">Part Type 0x30000/string_table: String Table</h3>
<p>String tables are used to optimize the write time of strings during recording.</p>
<p>Strings in the table are given a string-table unique 4-byte ordinal. Identical string values may be present in the table multiple times but with different ordinals. The ordinal is a reference into the stored string list, though it should be treated as opaque. Strings may have zero length but may not be null.</p>
<p>Strings are stored in utf8 separated by <code>\0</code> with an additional trailing <code>\0</code>. Reading out the table is as simple as a <code>table.split('\0')</code> (and ignoring the trailing empty string, if desired).</p>
<p>Example:</p>
<pre><code>some\0strings\0in\0\a\0table\0</code></pre>
<h3 id="part-type-0x4xxxx-embedded-resource">Part Type 0x4XXXX: Embedded Resource</h3>
<p>Embedded resources are (often) large binary data resources that can be referenced by their part ordinal. They are designed for 1K+ data sizes (as there is file size overhead and extra time required to load/resolve them). For example, one would not store a 4x4 transformation matrix in as a binary resource, but texture contents or an XHR response would be a good candidate.</p>
<p>Embedded resources are identified by their ordinal with in their chunk, so the first embedded resource has ID 0, the second 1, etc. The part header is used to indicate the length of the resource body.</p>
<p>The lower 16 bits of the part type indicate the basic type of the resource:</p>
<ul>
<li>Part type 0x40000/binary_resource: binary (ArrayBuffer) contents</li>
<li>Part type 0x40001/string_resource: string contents</li>
</ul>
</body>
</html>
