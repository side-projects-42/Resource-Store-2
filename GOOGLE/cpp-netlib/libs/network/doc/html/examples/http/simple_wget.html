<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>simple_wget</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h3 id="navigation">Navigation</h3>
<ul>
<li><a href="hello_world_server.html" title="“Hello world” HTTP server">next</a></li>
<li><a href="http_client.html" title="HTTP client">previous</a> |</li>
<li><a href="../../contents.html">cpp-netlib v0.11.2</a> »</li>
<li><a href="../../examples.html">Examples</a> »</li>
</ul>
<p><span id="id1"></span></p>
<h1 id="simple-wget">Simple wget<a href="#simple-wget" class="headerlink" title="Permalink to this headline">¶</a></h1>
<p>This example is a very simple implementation of a <code>wget</code> style clone. It’s very similar to the previous example, but introduces the <code>uri</code> class.</p>
<h2 id="the-code">The code<a href="#the-code" class="headerlink" title="Permalink to this headline">¶</a></h2>
<pre><code>#include &lt;boost/network/protocol/http/client.hpp&gt;
#include &lt;boost/network/uri.hpp&gt;
#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;

namespace http = boost::network::http;
namespace uri = boost::network::uri;

namespace {
std::string get_filename(const uri::uri &amp;url) {
    std::string path = uri::path(url);
    std::size_t index = path.find_last_of(&#39;/&#39;);
    std::string filename = path.substr(index + 1);
    return filename.empty()? &quot;index.html&quot; : filename;
}
} // namespace

int
main(int argc, char *argv[]) {
    if (argc != 2) {
        std::cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; url&quot; &lt;&lt; std::endl;
        return 1;
    }

    try {
        http::client client;
        http::client::request request(argv[1]);
        http::client::response response = client.get(request);

        std::string filename = get_filename(request.uri());
        std::cout &lt;&lt; &quot;Saving to: &quot; &lt;&lt; filename &lt;&lt; std::endl;
        std::ofstream ofs(filename.c_str());
        ofs &lt;&lt; static_cast&lt;std::string&gt;(body(response)) &lt;&lt; std::endl;
    }
    catch (std::exception &amp;e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}</code></pre>
<h2 id="running-the-example">Running the example<a href="#running-the-example" class="headerlink" title="Permalink to this headline">¶</a></h2>
<p>You can then run this to copy the <a href="http://www.boost.org/" class="reference external">Boost</a> website:</p>
<pre><code>$ cd ~/cpp-netlib-build
$ make simple_wget
$ ./example/simple_wget http://www.boost.org/
$ cat index.html</code></pre>
<h2 id="diving-into-the-code">Diving into the code<a href="#diving-into-the-code" class="headerlink" title="Permalink to this headline">¶</a></h2>
<p>As with <code>wget</code>, this example simply makes an HTTP request to the specified resource, and saves it on the filesystem. If the file name is not specified, it names the resultant file as <code>index.html</code>.</p>
<p>The new thing to note here is use of the <code>uri</code> class. The <code>uri</code> takes a string as a constructor argument and parses it. The <code>uri</code> parser is fully-compliant with <a href="http://www.ietf.org/rfc/rfc3986.txt" class="reference external">RFC 3986</a>. The URI is provided in the following header:</p>
<pre><code>#include &lt;boost/network/uri.hpp&gt;</code></pre>
<p>Most of the rest of the code is familiar from the previous example. To retrieve the URI resource’s file name, the following function is provided:</p>
<pre><code>std::string get_filename(const uri::uri &amp;url) {
    std::string path = uri::path(url);
    std::size_t index = path.find_last_of(&#39;/&#39;);
    std::string filename = path.substr(index + 1);
    return filename.empty()? &quot;index.html&quot; : filename;
}</code></pre>
<p>The <code>uri</code> interface provides access to its different components: <code>scheme</code>, <code>user_info</code>, <code>host</code>, <code>port</code>, <code>path</code>, <code>query</code> and <code>fragment</code>. The code above takes the URI path to determine the resource name.</p>
<p>Next we’ll develop a simple client/server application using <code>http::server</code> and <code>http::client</code>.</p>
<h3 id="table-of-contents"><a href="../../contents.html">Table Of Contents</a></h3>
<ul>
<li><a href="#" class="reference internal">Simple wget</a>
<ul>
<li><a href="#the-code" class="reference internal">The code</a></li>
<li><a href="#running-the-example" class="reference internal">Running the example</a></li>
<li><a href="#diving-into-the-code" class="reference internal">Diving into the code</a></li>
</ul></li>
</ul>
<h4 id="previous-topic">Previous topic</h4>
<p><a href="http_client.html" title="previous chapter">HTTP client</a></p>
<h4 id="next-topic">Next topic</h4>
<p><a href="hello_world_server.html" title="next chapter">“Hello world” HTTP server</a></p>
<h3 id="quick-search">Quick search</h3>
<p>Enter search terms or a module, class or function name.</p>
<h3 id="navigation-1">Navigation</h3>
<ul>
<li><a href="hello_world_server.html" title="“Hello world” HTTP server">next</a></li>
<li><a href="http_client.html" title="HTTP client">previous</a> |</li>
<li><a href="../../contents.html">cpp-netlib v0.11.2</a> »</li>
<li><a href="../../examples.html">Examples</a> »</li>
</ul>
<p>© Copyright 2008-2014, Glyn Matthews, Dean Michael Berris; 2013 Google, Inc.. Last updated on Mar 29, 2016. Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.</p>
</body>
</html>
