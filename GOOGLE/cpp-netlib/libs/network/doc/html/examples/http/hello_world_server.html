<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>hello_world_server</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h3 id="navigation">Navigation</h3>
<ul>
<li><a href="hello_world_client.html" title="“Hello world” HTTP client">next</a></li>
<li><a href="simple_wget.html" title="Simple wget">previous</a> |</li>
<li><a href="../../contents.html">cpp-netlib v0.11.2</a> »</li>
<li><a href="../../examples.html">Examples</a> »</li>
</ul>
<p><span id="id1"></span></p>
<h1 id="hello-world-http-server">“Hello world” HTTP server<a href="#hello-world-http-server" class="headerlink" title="Permalink to this headline">¶</a></h1>
<p>Now that we’ve seen how we can deal with request and response objects from the client side, we’ll see how we can then use the same abstractions on the server side. In this example we’re going to create a simple HTTP Server in C++ using <code>cpp-netlib</code>.</p>
<h2 id="the-code">The code<a href="#the-code" class="headerlink" title="Permalink to this headline">¶</a></h2>
<p>The <code>cpp-netlib</code> provides the framework to develop embedded HTTP servers. For this example, the server is configured to return a simple response to any HTTP request.</p>
<pre><code>#include &lt;boost/network/protocol/http/server.hpp&gt;
#include &lt;iostream&gt;

namespace http = boost::network::http;

struct hello_world;
typedef http::server&lt;hello_world&gt; server;

struct hello_world {
    void operator()(server::request const &amp;request, server::response &amp;response) {
        server::string_type ip = source(request);
        unsigned int port = request.source_port;
        std::ostringstream data;
        data &lt;&lt; &quot;Hello, &quot; &lt;&lt; ip &lt;&lt; &#39;:&#39; &lt;&lt; port &lt;&lt; &#39;!&#39;;
        response = server::response::stock_reply(server::response::ok, data.str());
    }
    void log(const server::string_type&amp; message) {
        std::cerr &lt;&lt; &quot;ERROR: &quot; &lt;&lt; message &lt;&lt; std::endl;
    }
};

int main(int argc, char *argv[]) {

    if (argc != 3) {
        std::cerr &lt;&lt; &quot;Usage: &quot; &lt;&lt; argv[0] &lt;&lt; &quot; address port&quot; &lt;&lt; std::endl;
        return 1;
    }

    try {
        hello_world handler;
        server::options options(handler);
        server server_(options.address(argv[1]).port(argv[2]));
        server_.run();
    }
    catch (std::exception &amp;e) {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        return 1;
    }

    return 0;
}</code></pre>
<p>This is about a straightforward as server programming will get in C++.</p>
<h2 id="building-and-running-the-server">Building and running the server<a href="#building-and-running-the-server" class="headerlink" title="Permalink to this headline">¶</a></h2>
<p>Just like with the HTTP client, we can build this example by doing the following on the shell:</p>
<pre><code>$ cd ~/cpp-netlib-build
$ make hello_world_server</code></pre>
<p>The first two arguments to the <code>server</code> constructor are the host and the port on which the server will listen. The third argument is the the handler object defined previously. This example can be run from a command line as follows:</p>
<pre><code>$ ./example/hello_world_server 0.0.0.0 8000</code></pre>
<p>Note</p>
<p>If you’re going to run the server on port 80, you may have to run it as an administrator.</p>
<h2 id="diving-into-the-code">Diving into the code<a href="#diving-into-the-code" class="headerlink" title="Permalink to this headline">¶</a></h2>
<p>Let’s take a look at the code listing above in greater detail.</p>
<pre><code>#include &lt;boost/network/protocol/http/server.hpp&gt;</code></pre>
<p>This header contains all the code needed to develop an HTTP server with <code>cpp-netlib</code>.</p>
<pre><code>struct hello_world;
typedef http::server&lt;hello_world&gt; server;

struct hello_world {
    void operator()(server::request const &amp;request, server::response &amp;response) {
        server::string_type ip = source(request);
        unsigned int port = request.source_port;
        std::ostringstream data;
        data &lt;&lt; &quot;Hello, &quot; &lt;&lt; ip &lt;&lt; &#39;:&#39; &lt;&lt; port &lt;&lt; &#39;!&#39;;
        response = server::response::stock_reply(server::response::ok, data.str());
    }
    void log(const server::string_type&amp; message) {
        std::cerr &lt;&lt; &quot;ERROR: &quot; &lt;&lt; message &lt;&lt; std::endl;
    }
};</code></pre>
<p><code>hello_world</code> is a functor class which handles HTTP requests. All the operator does here is return an HTTP response with HTTP code 200 and the body <code>"Hello,                     &lt;ip&gt;:&lt;port&gt;!"</code>. The <code>&lt;ip&gt;</code> in this case would be the IP address of the client that made the request and <code>&lt;port&gt;</code> the clients port.</p>
<p>There are a number of pre-defined stock replies differentiated by status code with configurable bodies. All the supported enumeration values for the response status codes can be found in <code>boost/network/protocol/http/impl/response.ipp</code>.</p>
<pre><code>hello_world handler;
server::options options(handler);
server server_(options.address(argv[1]).port(argv[2]));
server_.run();</code></pre>
<p>The <code>server</code> constructor requires an object of the <code>options</code> class, this object stores all needed options, especially the host and the port on which the server will listen. The <code>options</code> constructor’s single argument is the handler object defined previously.</p>
<p>Note</p>
<p>In this example, the server is specifically made to be single-threaded. In a multi-threaded server, you would invoke the <code>hello_world::run</code> member method in a set of threads. In a multi-threaded environment you would also make sure that the handler does all the necessary synchronization for shared resources across threads. The handler is passed by reference to the server constructor and you should ensure that any calls to the <code>operator()</code> overload are thread-safe.</p>
<h3 id="table-of-contents"><a href="../../contents.html">Table Of Contents</a></h3>
<ul>
<li><a href="#" class="reference internal">“Hello world” HTTP server</a>
<ul>
<li><a href="#the-code" class="reference internal">The code</a></li>
<li><a href="#building-and-running-the-server" class="reference internal">Building and running the server</a></li>
<li><a href="#diving-into-the-code" class="reference internal">Diving into the code</a></li>
</ul></li>
</ul>
<h4 id="previous-topic">Previous topic</h4>
<p><a href="simple_wget.html" title="previous chapter">Simple wget</a></p>
<h4 id="next-topic">Next topic</h4>
<p><a href="hello_world_client.html" title="next chapter">“Hello world” HTTP client</a></p>
<h3 id="quick-search">Quick search</h3>
<p>Enter search terms or a module, class or function name.</p>
<h3 id="navigation-1">Navigation</h3>
<ul>
<li><a href="hello_world_client.html" title="“Hello world” HTTP client">next</a></li>
<li><a href="simple_wget.html" title="Simple wget">previous</a> |</li>
<li><a href="../../contents.html">cpp-netlib v0.11.2</a> »</li>
<li><a href="../../examples.html">Examples</a> »</li>
</ul>
<p>© Copyright 2008-2014, Glyn Matthews, Dean Michael Berris; 2013 Google, Inc.. Last updated on Mar 29, 2016. Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.</p>
</body>
</html>
