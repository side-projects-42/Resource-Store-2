<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>radial-gradient</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="radial-gradient">Radial Gradient</h1>
<p>```js chart-editor // <block:setup:3> const DATA_COUNT = 5; Utils.srand(110);</p>
<p>const chartColors = Utils.CHART_COLORS; const colors = [ chartColors.red, chartColors.orange, chartColors.yellow, chartColors.green, chartColors.blue,];</p>
<p>const cache = new Map(); let width = null; let height = null;</p>
<p>const actions = [ { name: “Randomize”, handler(chart) { chart.data.datasets.forEach((dataset) =&gt; { dataset.data = generateData(); }); chart.update(); }, },]; // </block:setup></p>
<p>// <block:createRadialGradient3:0> function createRadialGradient3(context, c1, c2, c3) { const chartArea = context.chart.chartArea; if (!chartArea) { // This case happens on initial chart load return null; }</p>
<p>const chartWidth = chartArea.right - chartArea.left; const chartHeight = chartArea.bottom - chartArea.top; if (width !== chartWidth || height !== chartHeight) { cache.clear(); } var gradient = cache.get(c1 + c2 + c3); if (!gradient) { // Create the gradient because this is either the first render // or the size of the chart has changed width = chartWidth; height = chartHeight; const centerX = (chartArea.left + chartArea.right) / 2; const centerY = (chartArea.top + chartArea.bottom) / 2; const r = Math.min( (chartArea.right - chartArea.left) / 2, (chartArea.bottom - chartArea.top) / 2 ); var ctx = context.chart.ctx; gradient = ctx.createRadialGradient( centerX, centerY, 0, centerX, centerY, r ); gradient.addColorStop(0, c1); gradient.addColorStop(0.5, c2); gradient.addColorStop(1, c3); cache.set(c1 + c2 + c3, gradient); }</p>
<p>return gradient; } // </block:createRadialGradient3></p>
<p>// <block:data:2> function generateData() { return Utils.numbers({ count: DATA_COUNT, min: 0, max: 100, }); }</p>
<p>const data = { labels: Utils.months({ count: DATA_COUNT }), datasets: [ { data: generateData(), }, ], }; // </block:data></p>
<p>// <block:config:1> const config = { type: “polarArea”, data: data, options: { plugins: { legend: false, tooltip: false, }, elements: { arc: { backgroundColor: function (context) { let c = colors[context.dataIndex]; if (!c) { return; } if (context.active) { c = helpers.getHoverColor(c); } const mid = helpers.color(c).desaturate(0.2).darken(0.2).rgbString(); const start = helpers.color(c).lighten(0.2).rotate(270).rgbString(); const end = helpers.color(c).lighten(0.1).rgbString(); return createRadialGradient3(context, start, mid, end); }, }, }, }, }; // </block:config></p>
<p>module.exports = { actions, config, }; ```</p>
</body>
</html>
